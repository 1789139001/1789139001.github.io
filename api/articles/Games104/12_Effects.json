{"title":"现代游戏引擎 - 游戏引擎中的粒子和声效系统（十二）","slug":"Games104/12_Effects","date":"2023-03-22T14:20:38.000Z","updated":"2023-11-29T02:42:01.740Z","comments":true,"path":"api/articles/Games104/12_Effects.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/12/Games104_12_01.png","/images/article/Games104/12/Games104_12_02.png","/images/article/Games104/12/Games104_12_03.png","/images/article/Games104/12/Games104_12_04.png","/images/article/Games104/12/Games104_12_05.png","/images/article/Games104/12/Games104_12_06.png","/images/article/Games104/12/Games104_12_07.png","/images/article/Games104/12/Games104_12_09.png","/images/article/Games104/12/Games104_12_11.png","/images/article/Games104/12/Games104_12_12.png","/images/article/Games104/12/Games104_12_13.png","/images/article/Games104/12/Games104_12_17.png","/images/article/Games104/12/Games104_12_18.png","/images/article/Games104/12/Games104_12_19.png","/images/article/Games104/12/Games104_12_20.png","/images/article/Games104/12/Games104_12_21.png","/images/article/Games104/12/Games104_12_23.png","/images/article/Games104/12/Games104_12_24.png","/images/article/Games104/12/Games104_12_25.png","/images/article/Games104/12/Games104_12_26.png","/images/article/Games104/12/Games104_12_27.png","/images/article/Games104/12/Games104_12_28.png","/images/article/Games104/12/Games104_12_29.png","/images/article/Games104/12/Games104_12_30.png","/images/article/Games104/12/Games104_12_31.png","/images/article/Games104/12/Games104_12_32.png","/images/article/Games104/12/Games104_12_34.png","/images/article/Games104/12/Games104_12_36.png","/images/article/Games104/12/Games104_12_39.png","/images/article/Games104/12/Games104_12_40.png","/images/article/Games104/12/Games104_12_41.png","/images/article/Games104/12/Games104_12_43.png","/images/article/Games104/12/Games104_12_44.png","/images/article/Games104/12/Games104_12_45.png","/images/article/Games104/12/Games104_12_46.png","/images/article/Games104/12/Games104_12_47.png","/images/article/Games104/12/Games104_12_48.png","/images/article/Games104/12/Games104_12_49.png","/images/article/Games104/12/Games104_12_50.png","/images/article/Games104/12/Games104_12_51.png","/images/article/Games104/12/Games104_12_53.png","/images/article/Games104/12/Games104_12_54.png","/images/article/Games104/12/Games104_12_56.png","/images/article/Games104/12/Games104_12_58.png","/images/article/Games104/12/Games104_12_59.png","/images/article/Games104/12/Games104_12_60.png","/images/article/Games104/12/Games104_12_61.png","/images/article/Games104/12/Games104_12_62.png","/images/article/Games104/12/Games104_12_63.png","/images/article/Games104/12/Games104_12_64.png","/images/article/Games104/12/Games104_12_65.png","/images/article/Games104/12/Games104_12_66.png","/images/article/Games104/12/Games104_12_67.png","/images/article/Games104/12/Games104_12_68.png","/images/article/Games104/12/Games104_12_70.png","/images/article/Games104/12/Games104_12_71.png","/images/article/Games104/12/Games104_12_73.png","/images/article/Games104/12/Games104_12_74.png","/images/article/Games104/12/Games104_12_76.png"],"cover":"/images/background/Effects.jpg","content":"<h1 id=\"游戏引擎中的粒子和声效系统\"><a href=\"#游戏引擎中的粒子和声效系统\" class=\"headerlink\" title=\"游戏引擎中的粒子和声效系统\"></a>游戏引擎中的粒子和声效系统</h1><h2 id=\"粒子系统（Particle-System）\"><a href=\"#粒子系统（Particle-System）\" class=\"headerlink\" title=\"粒子系统（Particle System）\"></a>粒子系统（Particle System）</h2><p><b>粒子系统(particle system)</b>是现代游戏中非常重要的组成部分，游戏中大量的特效都是基于粒子系统来实现的。<br><img src=\"/images/article/Games104/12/Games104_12_01.png\"><span class=\"image-caption\">粒子系统</span></p>\n<h3 id=\"粒子基础（Fundamentals）\"><a href=\"#粒子基础（Fundamentals）\" class=\"headerlink\" title=\"粒子基础（Fundamentals）\"></a>粒子基础（Fundamentals）</h3><p>实际上粒子系统来自于电影行业对于视觉特效的追求，它最早可以追溯到1982年的电影《星际迷航2：可汗之怒》。<br><img src=\"/images/article/Games104/12/Games104_12_02.png\"><span class=\"image-caption\">粒子系统的历史</span></p>\n<p>所谓的粒子是指具有一些物理信息的物体，常见的物理量包括位置、速度、大小、颜色等。<br><img src=\"/images/article/Games104/12/Games104_12_03.png\"><span class=\"image-caption\">粒子</span></p>\n<p>同时粒子还需要考虑自身的<b>生命周期(life cycle)</b>，当粒子的生命周期结束后需要被系统回收。<br><img src=\"/images/article/Games104/12/Games104_12_04.png\"><span class=\"image-caption\">粒子生命周期</span></p>\n<h4 id=\"粒子发射器（Particle-Emitter）\"><a href=\"#粒子发射器（Particle-Emitter）\" class=\"headerlink\" title=\"粒子发射器（Particle Emitter）\"></a>粒子发射器（Particle Emitter）</h4><p>每一种不同的粒子都是由相应的<b>粒子发射器(particle emitter)</b>生成的。每一种粒子发射器需要指定自身的生成规则同时为粒子赋予相应的仿真逻辑。<br><img src=\"/images/article/Games104/12/Games104_12_05.png\"><span class=\"image-caption\">粒子发射器</span></p>\n<p>在一个粒子系统中往往会同时具有多个不同的例子发射器进行工作，它们之间相互配合就实现了丰富的粒子效果。<br><img src=\"/images/article/Games104/12/Games104_12_06.png\"><span class=\"image-caption\">粒子系统</span></p>\n<h4 id=\"粒子生成（Particle-Spawn）\"><a href=\"#粒子生成（Particle-Spawn）\" class=\"headerlink\" title=\"粒子生成（Particle Spawn）\"></a>粒子生成（Particle Spawn）</h4><p>粒子系统在生成粒子时可以根据需求使用不同的生成策略。比较简单的生成方式是从单点生成粒子，而在现代粒子生成器中则可以从某个区域甚至从物体的网格来生成粒子。<br>同时粒子生成器也可以根据需求只产生一次性的粒子，或是源源不断地生成新的粒子。<br><img src=\"/images/article/Games104/12/Games104_12_07.png\"><span class=\"image-caption\">粒子生成位置</span><br><img src=\"/images/article/Games104/12/Games104_12_08.png\"><span class=\"image-caption\">粒子生成模式</span></p>\n<h4 id=\"模拟（Simulation）\"><a href=\"#模拟（Simulation）\" class=\"headerlink\" title=\"模拟（Simulation）\"></a>模拟（Simulation）</h4><p>完成粒子的生成后就可以利用质点运动学的相关方法对粒子进行仿真。由于粒子系统一般不需要严格地遵守物理规律，<br>在实践中往往只会使用最简单的前向积分来实现对粒子状态进行更新。<br><img src=\"/images/article/Games104/12/Games104_12_09.png\"><span class=\"image-caption\">模拟</span><br><img src=\"/images/article/Games104/12/Games104_12_10.png\"><span class=\"image-caption\">模拟2</span></p>\n<h4 id=\"粒子类型（Particle-Type）\"><a href=\"#粒子类型（Particle-Type）\" class=\"headerlink\" title=\"粒子类型（Particle Type）\"></a>粒子类型（Particle Type）</h4><p>早期的粒子系统会假定粒子都位于某个平面上进行运动，这种方法称为billboard particle。当观察者的视角发生变化时，<br>billboard会随着观察者的视角一起变化从而保证它一直位于观察者的正前方。<br><img src=\"/images/article/Games104/12/Games104_12_11.png\"><span class=\"image-caption\">粒子面片</span></p>\n<p>随着游戏技术的进步，后来还出现了mesh particle这种带有几何信息的粒子。这种形式的粒子可以用来模拟岩石、碎屑等带有明显几何信息的颗粒。<br><img src=\"/images/article/Games104/12/Games104_12_12.png\"><span class=\"image-caption\">网格粒子</span></p>\n<p>在很多游戏中还使用了ribbon particle这种带状的粒子用来模拟各种拖动的效果，比如说游戏中各种武器的特效一般都是使用这种技术来制作的。<br>在使用ribbon particle时一般还会结合Catmull曲线来形成光滑连贯的特效。<br><img src=\"/images/article/Games104/12/Games104_12_13.png\"><span class=\"image-caption\">带状粒子</span><br><img src=\"/images/article/Games104/12/Games104_12_14.png\"><span class=\"image-caption\">带状粒子2</span><br><img src=\"/images/article/Games104/12/Games104_12_15.png\"><span class=\"image-caption\">带状粒子3</span><br><img src=\"/images/article/Games104/12/Games104_12_16.png\"><span class=\"image-caption\">带状粒子4</span></p>\n<h3 id=\"粒子渲染（Particle-System-Rendering）\"><a href=\"#粒子渲染（Particle-System-Rendering）\" class=\"headerlink\" title=\"粒子渲染（Particle System Rendering）\"></a>粒子渲染（Particle System Rendering）</h3><h4 id=\"粒子排序（Particle-Sort）\"><a href=\"#粒子排序（Particle-Sort）\" class=\"headerlink\" title=\"粒子排序（Particle Sort）\"></a>粒子排序（Particle Sort）</h4><p>粒子在进行渲染时的一大难点在于如何进行排序。按照alpha混合的理论，我们需要从最远端开始由远及近地对场景中的物体进行绘制。<br><img src=\"/images/article/Games104/12/Games104_12_17.png\"><span class=\"image-caption\">alpha混合</span></p>\n<p>由于场景中往往同时存在巨量的粒子，对这些粒子进行排序往往会耗费大量的计算资源。目前对于粒子进行排序主要有两种做法：<br>其一是全局排序即无考虑发射器的信息单纯对所有的粒子进行排序，这种做法可以获得正确的结果但需要非常多的计算资源；<br>另一种做法是按照发射器进行排序，这种方法可以极大地减少计算资源但可能会出现错误的排序结果。<br><img src=\"/images/article/Games104/12/Games104_12_18.png\"><span class=\"image-caption\">alpha混合</span></p>\n<h4 id=\"分辨率（Resolution）\"><a href=\"#分辨率（Resolution）\" class=\"headerlink\" title=\"分辨率（Resolution）\"></a>分辨率（Resolution）</h4><p>当粒子充满场景时非透明的粒子会导致我们必须在同一像素上进行反复的绘制，这往往会导致帧数极大的下降。<br><img src=\"/images/article/Games104/12/Games104_12_19.png\"><span class=\"image-caption\">全分辨率粒子</span></p>\n<p>因此在对粒子进行渲染时还会结合降采样的技术来减少需要进行绘制的像素数。<br>把降采样后的图像和非透明的粒子按照透明度混合后在通过上采样来恢复原始分辨率。<br><img src=\"/images/article/Games104/12/Games104_12_20.png\"><span class=\"image-caption\">低分辨率粒子</span></p>\n<h3 id=\"GPU粒子\"><a href=\"#GPU粒子\" class=\"headerlink\" title=\"GPU粒子\"></a>GPU粒子</h3><p>显然粒子系统这种天然并行的系统非常适合使用GPU进行计算，在现代游戏中也确实是使用GPU来实现对粒子系统的仿真。<br>稍后我们会看到使用GPU来对粒子系统进行计算不仅可以节约CPU的计算资源，更可以加速整个渲染的流程。<br><img src=\"/images/article/Games104/12/Games104_12_21.png\"><span class=\"image-caption\">GPU处理粒子</span><br><img src=\"/images/article/Games104/12/Games104_12_22.png\"><span class=\"image-caption\">GPU粒子</span></p>\n<h4 id=\"粒子列表（Particle-Lists）\"><a href=\"#粒子列表（Particle-Lists）\" class=\"headerlink\" title=\"粒子列表（Particle Lists）\"></a>粒子列表（Particle Lists）</h4><p>我们可以通过维护若干个列表来实现对粒子系统的仿真。首先我们把系统中所有可能的粒子及其携带的信息放入particle pool中，并且在deal list中初始化所有的粒子编号。<br><img src=\"/images/article/Games104/12/Games104_12_23.png\"><span class=\"image-caption\">初始化状态</span></p>\n<p>当emitter生成新的粒子时只需要将dead list中的粒子推入当前帧的alive list即可。<br><img src=\"/images/article/Games104/12/Games104_12_24.png\"><span class=\"image-caption\">生成新粒子</span></p>\n<p>对粒子进行仿真时只需要考虑alive list中的粒子。如果某个粒子的生命周期结束了，则需要把该粒子编号重新放入dead list中，<br>然后在写入下一帧的alive list时跳过该编号。当需要切换到下一帧时只需交换两个alive list即可。<br><img src=\"/images/article/Games104/12/Games104_12_25.png\"><span class=\"image-caption\">模拟</span></p>\n<p>由于所有的数据都在GPU上，我们还可以方便地对粒子进行frustum culling以及排序。<br><img src=\"/images/article/Games104/12/Games104_12_26.png\"><span class=\"image-caption\">排序</span></p>\n<h4 id=\"并行合并排序（Parallel-Mergesort）\"><a href=\"#并行合并排序（Parallel-Mergesort）\" class=\"headerlink\" title=\"并行合并排序（Parallel Mergesort）\"></a>并行合并排序（Parallel Mergesort）</h4><p>在GPU上进行排序时需要使用并行的排序算法，其中比较经典的算法是<b>parallel mergesort</b>。<br><img src=\"/images/article/Games104/12/Games104_12_27.png\"><span class=\"image-caption\">并行合并排序</span></p>\n<p>在合并两个有序数组时还可以使用从目标队列出发寻找源队列的方式进一步提升性能。<br><img src=\"/images/article/Games104/12/Games104_12_28.png\"><span class=\"image-caption\">并行合并排序2</span></p>\n<h4 id=\"深度缓冲区碰撞（Depth-Buffer-Collision）\"><a href=\"#深度缓冲区碰撞（Depth-Buffer-Collision）\" class=\"headerlink\" title=\"深度缓冲区碰撞（Depth Buffer Collision）\"></a>深度缓冲区碰撞（Depth Buffer Collision）</h4><p>除此之外还可以在GPU中进行粒子和场景的碰撞检测。出于计算效率方面的考虑，<br>在对粒子进行碰撞检测时一般只会使用屏幕空间和深度图来简化计算。<br><img src=\"/images/article/Games104/12/Games104_12_29.png\"><span class=\"image-caption\">深度缓冲区碰撞</span></p>\n<h3 id=\"粒子应用（Advanced-Particles）\"><a href=\"#粒子应用（Advanced-Particles）\" class=\"headerlink\" title=\"粒子应用（Advanced Particles）\"></a>粒子应用（Advanced Particles）</h3><h4 id=\"人群模拟（Crowd-Simulation）\"><a href=\"#人群模拟（Crowd-Simulation）\" class=\"headerlink\" title=\"人群模拟（Crowd Simulation）\"></a>人群模拟（Crowd Simulation）</h4><p>现代游戏的粒子系统已经远不局限于实现不同的视觉特效，实际上我们可以基于粒子系统来实现更加丰富的功能。<br>比如说游戏中大量NPC的运动行为就可以利用粒子系统进行实现。此时每个粒子不仅仅具有常见的物理属性， 还会携带顶点等几何信息。<br><img src=\"/images/article/Games104/12/Games104_12_30.png\"><span class=\"image-caption\">动画粒子网格</span></p>\n<p>基于粒子的几何信息还可以让NPC动起来，甚至可以利用状态机的理论制作简单的动画。<br><img src=\"/images/article/Games104/12/Games104_12_31.png\"><span class=\"image-caption\">粒子动画贴图</span></p>\n<p>基于SDF的相关技术还可以控制群体的运动行为。<br><img src=\"/images/article/Games104/12/Games104_12_32.png\"><span class=\"image-caption\">导航贴图</span><br><img src=\"/images/article/Games104/12/Games104_12_33.png\"><span class=\"image-caption\">人群运行时行为</span></p>\n<p>在虚幻5引擎中就实现了非常强大的粒子系统，从而方便开发者设计各种复杂的玩法和场景。<br><img src=\"/images/article/Games104/12/Games104_12_34.png\"><span class=\"image-caption\">高级粒子展示</span><br><img src=\"/images/article/Games104/12/Games104_12_35.png\"><span class=\"image-caption\">高级粒子展示2</span></p>\n<h4 id=\"在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）\"><a href=\"#在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）\" class=\"headerlink\" title=\"在游戏中使用粒子系统（Utilizing Particle System in Games）\"></a>在游戏中使用粒子系统（Utilizing Particle System in Games）</h4><p><img src=\"/images/article/Games104/12/Games104_12_36.png\"><span class=\"image-caption\">设计理念-预设堆叠式模块</span><br><img src=\"/images/article/Games104/12/Games104_12_37.png\"><span class=\"image-caption\">设计理念-基于图形的设计</span><br><img src=\"/images/article/Games104/12/Games104_12_38.png\"><span class=\"image-caption\">混合动力设计</span></p>\n<h2 id=\"声音系统（Sound-System）\"><a href=\"#声音系统（Sound-System）\" class=\"headerlink\" title=\"声音系统（Sound System）\"></a>声音系统（Sound System）</h2><h3 id=\"声音基础\"><a href=\"#声音基础\" class=\"headerlink\" title=\"声音基础\"></a>声音基础</h3><p>音效是影响游戏氛围和玩家体验的重要一环，很多游戏都需要使用大量的音效来调动玩家的情绪。<br><img src=\"/images/article/Games104/12/Games104_12_39.png\"><span class=\"image-caption\">声音</span></p>\n<p>声音的大小称为<b>音量(volume)</b>，它表示声波的振幅。<br><img src=\"/images/article/Games104/12/Games104_12_40.png\"><span class=\"image-caption\">音量</span></p>\n<p>从物理的角度上讲，声音的本质是空气的振动。当空气发生振动时会产生相应的压强，这个压强的大小就对应人感知到的音量。<br>音量的单位是分贝(dB)，它是基于人对于声音的感知来定义的。<br><img src=\"/images/article/Games104/12/Games104_12_41.png\"><span class=\"image-caption\">音量术语</span><br><img src=\"/images/article/Games104/12/Games104_12_42.png\"><span class=\"image-caption\">音量术语2</span></p>\n<p><b>音高(pitch)</b>是描述人耳对声音调子感受的物理量，它取决于声音振动的频率。音高越高，声音就越尖锐。<br><img src=\"/images/article/Games104/12/Games104_12_43.png\"><span class=\"image-caption\">音高</span></p>\n<p><b>音色(timbre)</b>是描述声波形状的量。不同的乐器在演奏时会产生不同形式的基波，因此即使声波的频率相同也会产生不同的音色。<br><img src=\"/images/article/Games104/12/Games104_12_44.png\"><span class=\"image-caption\">音色</span></p>\n<p>由于声音的本质是空气振动，我们可以在接收端叠加一个与当前振动相反的振动从而产生静音的效果。这就是现代降噪耳机的基本原理。<br><img src=\"/images/article/Games104/12/Games104_12_45.png\"><span class=\"image-caption\">降噪</span></p>\n<p>人耳对不同频率声音的感受范围可参考下图：<br><img src=\"/images/article/Games104/12/Games104_12_46.png\"><span class=\"image-caption\">降噪</span></p>\n<h4 id=\"数字声音（Digital-Sound）\"><a href=\"#数字声音（Digital-Sound）\" class=\"headerlink\" title=\"数字声音（Digital Sound）\"></a>数字声音（Digital Sound）</h4><p>自然界中的声音是连续的信号，因此要使用计算机存储或者表达声音就需要对连续的信号进行离散。<br>最常用的声音采样设备是<b>PCM(pulse-code modulation)</b>，它可以把连续的信号量化为离散的数字信号。<br><img src=\"/images/article/Games104/12/Games104_12_47.png\"><span class=\"image-caption\">PCM</span></p>\n<p>根据Nyquist采样定理，我们只需要2倍于人耳接收频率的采样频率就可以完美的重建原始信号。<br>不过在实际采样时往往会使用更高一些的采样频率来获得更好的音质。<br><img src=\"/images/article/Games104/12/Games104_12_48.png\"><span class=\"image-caption\">取样</span></p>\n<p>采样后的信号需要通过量化的过程编码为数字。<br><img src=\"/images/article/Games104/12/Games104_12_49.png\"><span class=\"image-caption\">量化</span></p>\n<p>基于上面介绍的过程就可以把声音使用计算机可以识别和保存的数据。目前常用的声音格式如下：<br><img src=\"/images/article/Games104/12/Games104_12_50.png\"><span class=\"image-caption\">音频格式</span></p>\n<h3 id=\"三维音频渲染\"><a href=\"#三维音频渲染\" class=\"headerlink\" title=\"三维音频渲染\"></a>三维音频渲染</h3><p>在游戏设计中我们需要在三维的环境里设置音效从而让玩家有身临其境的感受，因此我们需要设置一个虚拟的麦克风来采集场景中的声音。<br>通常情况下这个虚拟麦克风需要包含位置、速度以及朝向等物理信息。<br><img src=\"/images/article/Games104/12/Games104_12_51.png\"><span class=\"image-caption\">3D声源</span><br><img src=\"/images/article/Games104/12/Games104_12_52.png\"><span class=\"image-caption\">接收</span></p>\n<p>对于人耳而言，我们可以利用双耳之间接收声音细微的变化来判断声源的大致位置。因此在游戏音效系统中可以利用人耳的这种效应来制造空间感。<br><img src=\"/images/article/Games104/12/Games104_12_53.png\"><span class=\"image-caption\">空间定位</span></p>\n<h4 id=\"位移（Panning）\"><a href=\"#位移（Panning）\" class=\"headerlink\" title=\"位移（Panning）\"></a>位移（Panning）</h4><p>当音响有多个通道时我们可以调整不同音响的参数来产生空间感，这种方法称为panning。最简单的panning是进行线性插值<br>，假设有某个声源从前方经过，我们可以对左右两通道的声音进行线性插值来模拟这种效果。<br><img src=\"/images/article/Games104/12/Games104_12_54.png\"><span class=\"image-caption\">扇形位移</span><br><img src=\"/images/article/Games104/12/Games104_12_55.png\"><span class=\"image-caption\">线性位移</span></p>\n<p>实际上人耳对于声音的感知是一个非线性函数，因此我们可以使用平方函数来改进线性插值的效果。<br>此时会出现当声源经过正前方时接收到的声音会小一点。<br><img src=\"/images/article/Games104/12/Games104_12_56.png\"><span class=\"image-caption\">线性位移2</span><br><img src=\"/images/article/Games104/12/Games104_12_57.png\"><span class=\"image-caption\">线性位移3</span></p>\n<p>更进一步还可以使用三角函数来描述声音的变化，这样可以得到更逼真的效果。<br><img src=\"/images/article/Games104/12/Games104_12_58.png\"><span class=\"image-caption\">线性位移4</span></p>\n<p>当然实际游戏中的panning算法会比上面介绍的要复杂得多，也可以表达更加复杂的空间位置变化。<br><img src=\"/images/article/Games104/12/Games104_12_59.png\"><span class=\"image-caption\">线性位移5</span></p>\n<h4 id=\"衰减（Attenuation）\"><a href=\"#衰减（Attenuation）\" class=\"headerlink\" title=\"衰减（Attenuation）\"></a>衰减（Attenuation）</h4><p>当声源远离麦克风时会出现<b>衰减(attenuation)</b>的现象，随着距离的增加虚拟麦克风能接受到的声音会不断减少。<br>实际上不仅是接收到的音量会发生变化，距离也会对接收到声音的频率产生一定的影响。<br><img src=\"/images/article/Games104/12/Games104_12_60.png\"><span class=\"image-caption\">衰减</span></p>\n<p>最简单的衰减模型是球形衰减，此时声音的变化只与声源和麦克风之间的距离有关。<br><img src=\"/images/article/Games104/12/Games104_12_61.png\"><span class=\"image-caption\">衰减形体 - 球体</span></p>\n<p>更复杂的模型是胶囊形的衰减模型，它主要与麦克风到中心轴的距离相关。当接收端沿轴方向运动时声音的衰减基本保持不变。<br><img src=\"/images/article/Games104/12/Games104_12_62.png\"><span class=\"image-caption\">衰减形体 - 胶囊</span></p>\n<p>对于室内场景可以考虑盒子形的衰减模型。<br><img src=\"/images/article/Games104/12/Games104_12_63.png\"><span class=\"image-caption\">衰减形体 - 盒子</span></p>\n<p>对于高音喇叭这种声源则可以使用锥形的衰减模型描述声源的朝向。<br><img src=\"/images/article/Games104/12/Games104_12_64.png\"><span class=\"image-caption\">衰减形体 - 锥体</span></p>\n<h4 id=\"障碍和遮挡（Obstruction-and-Occlusion）\"><a href=\"#障碍和遮挡（Obstruction-and-Occlusion）\" class=\"headerlink\" title=\"障碍和遮挡（Obstruction and Occlusion）\"></a>障碍和遮挡（Obstruction and Occlusion）</h4><p>由于声音的本质是波，在封闭环境中还需要考虑声波与环境的互动。当声音被场景中的障碍物阻挡时可以通过衍射的方式继续传播，<br>而如果声音的传播被完全阻挡它也可以通过阻挡物自身的振动继续向外传播。<br><img src=\"/images/article/Games104/12/Games104_12_65.png\"><span class=\"image-caption\">障碍和遮挡</span></p>\n<p>因此在复杂的场景中往往需要使用一些采样的方法来模拟声音传播的效果。<br><img src=\"/images/article/Games104/12/Games104_12_66.png\"><span class=\"image-caption\">障碍和遮挡2</span></p>\n<h4 id=\"混响（Reverb）\"><a href=\"#混响（Reverb）\" class=\"headerlink\" title=\"混响（Reverb）\"></a>混响（Reverb）</h4><p>除此之外声音在室内场景中还会出现<b>混响(reverb)</b>的现象，这是由于声波在场景中不断反射所导致的。<br><img src=\"/images/article/Games104/12/Games104_12_67.png\"><span class=\"image-caption\">混响</span></p>\n<p>混响的效果很大程度上取决于材质的吸声特性，不同材质往往在不同的频率上有着巨大的性能差异。另一方面混响也取决于场景的几何特征。<br><img src=\"/images/article/Games104/12/Games104_12_68.png\"><span class=\"image-caption\">混响2</span><br><img src=\"/images/article/Games104/12/Games104_12_69.png\"><span class=\"image-caption\">混响3</span></p>\n<p>通过调整不同的混响组合比例可以实现丰富的声学效果。<br><img src=\"/images/article/Games104/12/Games104_12_70.png\"><span class=\"image-caption\">基于声学参数的混响效果控制</span></p>\n<h4 id=\"运动中的声（Sound-in-Motion）\"><a href=\"#运动中的声（Sound-in-Motion）\" class=\"headerlink\" title=\"运动中的声（Sound in Motion）\"></a>运动中的声（Sound in Motion）</h4><p>当声源发生运动时由于Doppler效应会导致接收端接收到的频率发生变化。<br><img src=\"/images/article/Games104/12/Games104_12_71.png\"><span class=\"image-caption\">运动中的声：多普勒效应</span><br><img src=\"/images/article/Games104/12/Games104_12_72.png\"><span class=\"image-caption\">运动中的声：多普勒效应2</span></p>\n<h4 id=\"声场（Sound-Field）\"><a href=\"#声场（Sound-Field）\" class=\"headerlink\" title=\"声场（Sound Field）\"></a>声场（Sound Field）</h4><p>很多时候还可以对整个声场进行采集。<br><img src=\"/images/article/Games104/12/Games104_12_73.png\"><span class=\"image-caption\">空间化-声场</span></p>\n<p>目前市面上常用的专业级声学引擎包括fmod或wwise等，这些引擎可以更好地辅助专业的声学设计。<br><img src=\"/images/article/Games104/12/Games104_12_74.png\"><span class=\"image-caption\">常见的中间件</span><br><img src=\"/images/article/Games104/12/Games104_12_75.png\"><span class=\"image-caption\">音频中间件如何工作的</span></p>\n<p>目前想要表现大规模场景的声学特性仍是非常复杂的。<br><img src=\"/images/article/Games104/12/Games104_12_76.png\"><span class=\"image-caption\">模拟音频世界</span></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p><a href=\"https://peng00bo00.github.io/2022/06/15/GAMES104-NOTES-12.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1bU4y1R7x5/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture12_Effects.pdf\">课件PPT</a></p>\n","more":"<h1 id=\"游戏引擎中的粒子和声效系统\"><a href=\"#游戏引擎中的粒子和声效系统\" class=\"headerlink\" title=\"游戏引擎中的粒子和声效系统\"></a>游戏引擎中的粒子和声效系统</h1><h2 id=\"粒子系统（Particle-System）\"><a href=\"#粒子系统（Particle-System）\" class=\"headerlink\" title=\"粒子系统（Particle System）\"></a>粒子系统（Particle System）</h2><p><b>粒子系统(particle system)</b>是现代游戏中非常重要的组成部分，游戏中大量的特效都是基于粒子系统来实现的。<br><img  src=\"/images/article/Games104/12/Games104_12_01.png\"  ><span class=\"image-caption\">粒子系统</span></p>\n<h3 id=\"粒子基础（Fundamentals）\"><a href=\"#粒子基础（Fundamentals）\" class=\"headerlink\" title=\"粒子基础（Fundamentals）\"></a>粒子基础（Fundamentals）</h3><p>实际上粒子系统来自于电影行业对于视觉特效的追求，它最早可以追溯到1982年的电影《星际迷航2：可汗之怒》。<br><img  src=\"/images/article/Games104/12/Games104_12_02.png\"  ><span class=\"image-caption\">粒子系统的历史</span></p>\n<p>所谓的粒子是指具有一些物理信息的物体，常见的物理量包括位置、速度、大小、颜色等。<br><img  src=\"/images/article/Games104/12/Games104_12_03.png\"  ><span class=\"image-caption\">粒子</span></p>\n<p>同时粒子还需要考虑自身的<b>生命周期(life cycle)</b>，当粒子的生命周期结束后需要被系统回收。<br><img  src=\"/images/article/Games104/12/Games104_12_04.png\"  ><span class=\"image-caption\">粒子生命周期</span></p>\n<h4 id=\"粒子发射器（Particle-Emitter）\"><a href=\"#粒子发射器（Particle-Emitter）\" class=\"headerlink\" title=\"粒子发射器（Particle Emitter）\"></a>粒子发射器（Particle Emitter）</h4><p>每一种不同的粒子都是由相应的<b>粒子发射器(particle emitter)</b>生成的。每一种粒子发射器需要指定自身的生成规则同时为粒子赋予相应的仿真逻辑。<br><img  src=\"/images/article/Games104/12/Games104_12_05.png\"  ><span class=\"image-caption\">粒子发射器</span></p>\n<p>在一个粒子系统中往往会同时具有多个不同的例子发射器进行工作，它们之间相互配合就实现了丰富的粒子效果。<br><img  src=\"/images/article/Games104/12/Games104_12_06.png\"  ><span class=\"image-caption\">粒子系统</span></p>\n<h4 id=\"粒子生成（Particle-Spawn）\"><a href=\"#粒子生成（Particle-Spawn）\" class=\"headerlink\" title=\"粒子生成（Particle Spawn）\"></a>粒子生成（Particle Spawn）</h4><p>粒子系统在生成粒子时可以根据需求使用不同的生成策略。比较简单的生成方式是从单点生成粒子，而在现代粒子生成器中则可以从某个区域甚至从物体的网格来生成粒子。<br>同时粒子生成器也可以根据需求只产生一次性的粒子，或是源源不断地生成新的粒子。<br><img  src=\"/images/article/Games104/12/Games104_12_07.png\"  ><span class=\"image-caption\">粒子生成位置</span><br><img  src=\"/images/article/Games104/12/Games104_12_08.png\"  ><span class=\"image-caption\">粒子生成模式</span></p>\n<h4 id=\"模拟（Simulation）\"><a href=\"#模拟（Simulation）\" class=\"headerlink\" title=\"模拟（Simulation）\"></a>模拟（Simulation）</h4><p>完成粒子的生成后就可以利用质点运动学的相关方法对粒子进行仿真。由于粒子系统一般不需要严格地遵守物理规律，<br>在实践中往往只会使用最简单的前向积分来实现对粒子状态进行更新。<br><img  src=\"/images/article/Games104/12/Games104_12_09.png\"  ><span class=\"image-caption\">模拟</span><br><img  src=\"/images/article/Games104/12/Games104_12_10.png\"  ><span class=\"image-caption\">模拟2</span></p>\n<h4 id=\"粒子类型（Particle-Type）\"><a href=\"#粒子类型（Particle-Type）\" class=\"headerlink\" title=\"粒子类型（Particle Type）\"></a>粒子类型（Particle Type）</h4><p>早期的粒子系统会假定粒子都位于某个平面上进行运动，这种方法称为billboard particle。当观察者的视角发生变化时，<br>billboard会随着观察者的视角一起变化从而保证它一直位于观察者的正前方。<br><img  src=\"/images/article/Games104/12/Games104_12_11.png\"  ><span class=\"image-caption\">粒子面片</span></p>\n<p>随着游戏技术的进步，后来还出现了mesh particle这种带有几何信息的粒子。这种形式的粒子可以用来模拟岩石、碎屑等带有明显几何信息的颗粒。<br><img  src=\"/images/article/Games104/12/Games104_12_12.png\"  ><span class=\"image-caption\">网格粒子</span></p>\n<p>在很多游戏中还使用了ribbon particle这种带状的粒子用来模拟各种拖动的效果，比如说游戏中各种武器的特效一般都是使用这种技术来制作的。<br>在使用ribbon particle时一般还会结合Catmull曲线来形成光滑连贯的特效。<br><img  src=\"/images/article/Games104/12/Games104_12_13.png\"  ><span class=\"image-caption\">带状粒子</span><br><img  src=\"/images/article/Games104/12/Games104_12_14.png\"  ><span class=\"image-caption\">带状粒子2</span><br><img  src=\"/images/article/Games104/12/Games104_12_15.png\"  ><span class=\"image-caption\">带状粒子3</span><br><img  src=\"/images/article/Games104/12/Games104_12_16.png\"  ><span class=\"image-caption\">带状粒子4</span></p>\n<h3 id=\"粒子渲染（Particle-System-Rendering）\"><a href=\"#粒子渲染（Particle-System-Rendering）\" class=\"headerlink\" title=\"粒子渲染（Particle System Rendering）\"></a>粒子渲染（Particle System Rendering）</h3><h4 id=\"粒子排序（Particle-Sort）\"><a href=\"#粒子排序（Particle-Sort）\" class=\"headerlink\" title=\"粒子排序（Particle Sort）\"></a>粒子排序（Particle Sort）</h4><p>粒子在进行渲染时的一大难点在于如何进行排序。按照alpha混合的理论，我们需要从最远端开始由远及近地对场景中的物体进行绘制。<br><img  src=\"/images/article/Games104/12/Games104_12_17.png\"  ><span class=\"image-caption\">alpha混合</span></p>\n<p>由于场景中往往同时存在巨量的粒子，对这些粒子进行排序往往会耗费大量的计算资源。目前对于粒子进行排序主要有两种做法：<br>其一是全局排序即无考虑发射器的信息单纯对所有的粒子进行排序，这种做法可以获得正确的结果但需要非常多的计算资源；<br>另一种做法是按照发射器进行排序，这种方法可以极大地减少计算资源但可能会出现错误的排序结果。<br><img  src=\"/images/article/Games104/12/Games104_12_18.png\"  ><span class=\"image-caption\">alpha混合</span></p>\n<h4 id=\"分辨率（Resolution）\"><a href=\"#分辨率（Resolution）\" class=\"headerlink\" title=\"分辨率（Resolution）\"></a>分辨率（Resolution）</h4><p>当粒子充满场景时非透明的粒子会导致我们必须在同一像素上进行反复的绘制，这往往会导致帧数极大的下降。<br><img  src=\"/images/article/Games104/12/Games104_12_19.png\"  ><span class=\"image-caption\">全分辨率粒子</span></p>\n<p>因此在对粒子进行渲染时还会结合降采样的技术来减少需要进行绘制的像素数。<br>把降采样后的图像和非透明的粒子按照透明度混合后在通过上采样来恢复原始分辨率。<br><img  src=\"/images/article/Games104/12/Games104_12_20.png\"  ><span class=\"image-caption\">低分辨率粒子</span></p>\n<h3 id=\"GPU粒子\"><a href=\"#GPU粒子\" class=\"headerlink\" title=\"GPU粒子\"></a>GPU粒子</h3><p>显然粒子系统这种天然并行的系统非常适合使用GPU进行计算，在现代游戏中也确实是使用GPU来实现对粒子系统的仿真。<br>稍后我们会看到使用GPU来对粒子系统进行计算不仅可以节约CPU的计算资源，更可以加速整个渲染的流程。<br><img  src=\"/images/article/Games104/12/Games104_12_21.png\"  ><span class=\"image-caption\">GPU处理粒子</span><br><img  src=\"/images/article/Games104/12/Games104_12_22.png\"  ><span class=\"image-caption\">GPU粒子</span></p>\n<h4 id=\"粒子列表（Particle-Lists）\"><a href=\"#粒子列表（Particle-Lists）\" class=\"headerlink\" title=\"粒子列表（Particle Lists）\"></a>粒子列表（Particle Lists）</h4><p>我们可以通过维护若干个列表来实现对粒子系统的仿真。首先我们把系统中所有可能的粒子及其携带的信息放入particle pool中，并且在deal list中初始化所有的粒子编号。<br><img  src=\"/images/article/Games104/12/Games104_12_23.png\"  ><span class=\"image-caption\">初始化状态</span></p>\n<p>当emitter生成新的粒子时只需要将dead list中的粒子推入当前帧的alive list即可。<br><img  src=\"/images/article/Games104/12/Games104_12_24.png\"  ><span class=\"image-caption\">生成新粒子</span></p>\n<p>对粒子进行仿真时只需要考虑alive list中的粒子。如果某个粒子的生命周期结束了，则需要把该粒子编号重新放入dead list中，<br>然后在写入下一帧的alive list时跳过该编号。当需要切换到下一帧时只需交换两个alive list即可。<br><img  src=\"/images/article/Games104/12/Games104_12_25.png\"  ><span class=\"image-caption\">模拟</span></p>\n<p>由于所有的数据都在GPU上，我们还可以方便地对粒子进行frustum culling以及排序。<br><img  src=\"/images/article/Games104/12/Games104_12_26.png\"  ><span class=\"image-caption\">排序</span></p>\n<h4 id=\"并行合并排序（Parallel-Mergesort）\"><a href=\"#并行合并排序（Parallel-Mergesort）\" class=\"headerlink\" title=\"并行合并排序（Parallel Mergesort）\"></a>并行合并排序（Parallel Mergesort）</h4><p>在GPU上进行排序时需要使用并行的排序算法，其中比较经典的算法是<b>parallel mergesort</b>。<br><img  src=\"/images/article/Games104/12/Games104_12_27.png\"  ><span class=\"image-caption\">并行合并排序</span></p>\n<p>在合并两个有序数组时还可以使用从目标队列出发寻找源队列的方式进一步提升性能。<br><img  src=\"/images/article/Games104/12/Games104_12_28.png\"  ><span class=\"image-caption\">并行合并排序2</span></p>\n<h4 id=\"深度缓冲区碰撞（Depth-Buffer-Collision）\"><a href=\"#深度缓冲区碰撞（Depth-Buffer-Collision）\" class=\"headerlink\" title=\"深度缓冲区碰撞（Depth Buffer Collision）\"></a>深度缓冲区碰撞（Depth Buffer Collision）</h4><p>除此之外还可以在GPU中进行粒子和场景的碰撞检测。出于计算效率方面的考虑，<br>在对粒子进行碰撞检测时一般只会使用屏幕空间和深度图来简化计算。<br><img  src=\"/images/article/Games104/12/Games104_12_29.png\"  ><span class=\"image-caption\">深度缓冲区碰撞</span></p>\n<h3 id=\"粒子应用（Advanced-Particles）\"><a href=\"#粒子应用（Advanced-Particles）\" class=\"headerlink\" title=\"粒子应用（Advanced Particles）\"></a>粒子应用（Advanced Particles）</h3><h4 id=\"人群模拟（Crowd-Simulation）\"><a href=\"#人群模拟（Crowd-Simulation）\" class=\"headerlink\" title=\"人群模拟（Crowd Simulation）\"></a>人群模拟（Crowd Simulation）</h4><p>现代游戏的粒子系统已经远不局限于实现不同的视觉特效，实际上我们可以基于粒子系统来实现更加丰富的功能。<br>比如说游戏中大量NPC的运动行为就可以利用粒子系统进行实现。此时每个粒子不仅仅具有常见的物理属性， 还会携带顶点等几何信息。<br><img  src=\"/images/article/Games104/12/Games104_12_30.png\"  ><span class=\"image-caption\">动画粒子网格</span></p>\n<p>基于粒子的几何信息还可以让NPC动起来，甚至可以利用状态机的理论制作简单的动画。<br><img  src=\"/images/article/Games104/12/Games104_12_31.png\"  ><span class=\"image-caption\">粒子动画贴图</span></p>\n<p>基于SDF的相关技术还可以控制群体的运动行为。<br><img  src=\"/images/article/Games104/12/Games104_12_32.png\"  ><span class=\"image-caption\">导航贴图</span><br><img  src=\"/images/article/Games104/12/Games104_12_33.png\"  ><span class=\"image-caption\">人群运行时行为</span></p>\n<p>在虚幻5引擎中就实现了非常强大的粒子系统，从而方便开发者设计各种复杂的玩法和场景。<br><img  src=\"/images/article/Games104/12/Games104_12_34.png\"  ><span class=\"image-caption\">高级粒子展示</span><br><img  src=\"/images/article/Games104/12/Games104_12_35.png\"  ><span class=\"image-caption\">高级粒子展示2</span></p>\n<h4 id=\"在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）\"><a href=\"#在游戏中使用粒子系统（Utilizing-Particle-System-in-Games）\" class=\"headerlink\" title=\"在游戏中使用粒子系统（Utilizing Particle System in Games）\"></a>在游戏中使用粒子系统（Utilizing Particle System in Games）</h4><p><img  src=\"/images/article/Games104/12/Games104_12_36.png\"  ><span class=\"image-caption\">设计理念-预设堆叠式模块</span><br><img  src=\"/images/article/Games104/12/Games104_12_37.png\"  ><span class=\"image-caption\">设计理念-基于图形的设计</span><br><img  src=\"/images/article/Games104/12/Games104_12_38.png\"  ><span class=\"image-caption\">混合动力设计</span></p>\n<h2 id=\"声音系统（Sound-System）\"><a href=\"#声音系统（Sound-System）\" class=\"headerlink\" title=\"声音系统（Sound System）\"></a>声音系统（Sound System）</h2><h3 id=\"声音基础\"><a href=\"#声音基础\" class=\"headerlink\" title=\"声音基础\"></a>声音基础</h3><p>音效是影响游戏氛围和玩家体验的重要一环，很多游戏都需要使用大量的音效来调动玩家的情绪。<br><img  src=\"/images/article/Games104/12/Games104_12_39.png\"  ><span class=\"image-caption\">声音</span></p>\n<p>声音的大小称为<b>音量(volume)</b>，它表示声波的振幅。<br><img  src=\"/images/article/Games104/12/Games104_12_40.png\"  ><span class=\"image-caption\">音量</span></p>\n<p>从物理的角度上讲，声音的本质是空气的振动。当空气发生振动时会产生相应的压强，这个压强的大小就对应人感知到的音量。<br>音量的单位是分贝(dB)，它是基于人对于声音的感知来定义的。<br><img  src=\"/images/article/Games104/12/Games104_12_41.png\"  ><span class=\"image-caption\">音量术语</span><br><img  src=\"/images/article/Games104/12/Games104_12_42.png\"  ><span class=\"image-caption\">音量术语2</span></p>\n<p><b>音高(pitch)</b>是描述人耳对声音调子感受的物理量，它取决于声音振动的频率。音高越高，声音就越尖锐。<br><img  src=\"/images/article/Games104/12/Games104_12_43.png\"  ><span class=\"image-caption\">音高</span></p>\n<p><b>音色(timbre)</b>是描述声波形状的量。不同的乐器在演奏时会产生不同形式的基波，因此即使声波的频率相同也会产生不同的音色。<br><img  src=\"/images/article/Games104/12/Games104_12_44.png\"  ><span class=\"image-caption\">音色</span></p>\n<p>由于声音的本质是空气振动，我们可以在接收端叠加一个与当前振动相反的振动从而产生静音的效果。这就是现代降噪耳机的基本原理。<br><img  src=\"/images/article/Games104/12/Games104_12_45.png\"  ><span class=\"image-caption\">降噪</span></p>\n<p>人耳对不同频率声音的感受范围可参考下图：<br><img  src=\"/images/article/Games104/12/Games104_12_46.png\"  ><span class=\"image-caption\">降噪</span></p>\n<h4 id=\"数字声音（Digital-Sound）\"><a href=\"#数字声音（Digital-Sound）\" class=\"headerlink\" title=\"数字声音（Digital Sound）\"></a>数字声音（Digital Sound）</h4><p>自然界中的声音是连续的信号，因此要使用计算机存储或者表达声音就需要对连续的信号进行离散。<br>最常用的声音采样设备是<b>PCM(pulse-code modulation)</b>，它可以把连续的信号量化为离散的数字信号。<br><img  src=\"/images/article/Games104/12/Games104_12_47.png\"  ><span class=\"image-caption\">PCM</span></p>\n<p>根据Nyquist采样定理，我们只需要2倍于人耳接收频率的采样频率就可以完美的重建原始信号。<br>不过在实际采样时往往会使用更高一些的采样频率来获得更好的音质。<br><img  src=\"/images/article/Games104/12/Games104_12_48.png\"  ><span class=\"image-caption\">取样</span></p>\n<p>采样后的信号需要通过量化的过程编码为数字。<br><img  src=\"/images/article/Games104/12/Games104_12_49.png\"  ><span class=\"image-caption\">量化</span></p>\n<p>基于上面介绍的过程就可以把声音使用计算机可以识别和保存的数据。目前常用的声音格式如下：<br><img  src=\"/images/article/Games104/12/Games104_12_50.png\"  ><span class=\"image-caption\">音频格式</span></p>\n<h3 id=\"三维音频渲染\"><a href=\"#三维音频渲染\" class=\"headerlink\" title=\"三维音频渲染\"></a>三维音频渲染</h3><p>在游戏设计中我们需要在三维的环境里设置音效从而让玩家有身临其境的感受，因此我们需要设置一个虚拟的麦克风来采集场景中的声音。<br>通常情况下这个虚拟麦克风需要包含位置、速度以及朝向等物理信息。<br><img  src=\"/images/article/Games104/12/Games104_12_51.png\"  ><span class=\"image-caption\">3D声源</span><br><img  src=\"/images/article/Games104/12/Games104_12_52.png\"  ><span class=\"image-caption\">接收</span></p>\n<p>对于人耳而言，我们可以利用双耳之间接收声音细微的变化来判断声源的大致位置。因此在游戏音效系统中可以利用人耳的这种效应来制造空间感。<br><img  src=\"/images/article/Games104/12/Games104_12_53.png\"  ><span class=\"image-caption\">空间定位</span></p>\n<h4 id=\"位移（Panning）\"><a href=\"#位移（Panning）\" class=\"headerlink\" title=\"位移（Panning）\"></a>位移（Panning）</h4><p>当音响有多个通道时我们可以调整不同音响的参数来产生空间感，这种方法称为panning。最简单的panning是进行线性插值<br>，假设有某个声源从前方经过，我们可以对左右两通道的声音进行线性插值来模拟这种效果。<br><img  src=\"/images/article/Games104/12/Games104_12_54.png\"  ><span class=\"image-caption\">扇形位移</span><br><img  src=\"/images/article/Games104/12/Games104_12_55.png\"  ><span class=\"image-caption\">线性位移</span></p>\n<p>实际上人耳对于声音的感知是一个非线性函数，因此我们可以使用平方函数来改进线性插值的效果。<br>此时会出现当声源经过正前方时接收到的声音会小一点。<br><img  src=\"/images/article/Games104/12/Games104_12_56.png\"  ><span class=\"image-caption\">线性位移2</span><br><img  src=\"/images/article/Games104/12/Games104_12_57.png\"  ><span class=\"image-caption\">线性位移3</span></p>\n<p>更进一步还可以使用三角函数来描述声音的变化，这样可以得到更逼真的效果。<br><img  src=\"/images/article/Games104/12/Games104_12_58.png\"  ><span class=\"image-caption\">线性位移4</span></p>\n<p>当然实际游戏中的panning算法会比上面介绍的要复杂得多，也可以表达更加复杂的空间位置变化。<br><img  src=\"/images/article/Games104/12/Games104_12_59.png\"  ><span class=\"image-caption\">线性位移5</span></p>\n<h4 id=\"衰减（Attenuation）\"><a href=\"#衰减（Attenuation）\" class=\"headerlink\" title=\"衰减（Attenuation）\"></a>衰减（Attenuation）</h4><p>当声源远离麦克风时会出现<b>衰减(attenuation)</b>的现象，随着距离的增加虚拟麦克风能接受到的声音会不断减少。<br>实际上不仅是接收到的音量会发生变化，距离也会对接收到声音的频率产生一定的影响。<br><img  src=\"/images/article/Games104/12/Games104_12_60.png\"  ><span class=\"image-caption\">衰减</span></p>\n<p>最简单的衰减模型是球形衰减，此时声音的变化只与声源和麦克风之间的距离有关。<br><img  src=\"/images/article/Games104/12/Games104_12_61.png\"  ><span class=\"image-caption\">衰减形体 - 球体</span></p>\n<p>更复杂的模型是胶囊形的衰减模型，它主要与麦克风到中心轴的距离相关。当接收端沿轴方向运动时声音的衰减基本保持不变。<br><img  src=\"/images/article/Games104/12/Games104_12_62.png\"  ><span class=\"image-caption\">衰减形体 - 胶囊</span></p>\n<p>对于室内场景可以考虑盒子形的衰减模型。<br><img  src=\"/images/article/Games104/12/Games104_12_63.png\"  ><span class=\"image-caption\">衰减形体 - 盒子</span></p>\n<p>对于高音喇叭这种声源则可以使用锥形的衰减模型描述声源的朝向。<br><img  src=\"/images/article/Games104/12/Games104_12_64.png\"  ><span class=\"image-caption\">衰减形体 - 锥体</span></p>\n<h4 id=\"障碍和遮挡（Obstruction-and-Occlusion）\"><a href=\"#障碍和遮挡（Obstruction-and-Occlusion）\" class=\"headerlink\" title=\"障碍和遮挡（Obstruction and Occlusion）\"></a>障碍和遮挡（Obstruction and Occlusion）</h4><p>由于声音的本质是波，在封闭环境中还需要考虑声波与环境的互动。当声音被场景中的障碍物阻挡时可以通过衍射的方式继续传播，<br>而如果声音的传播被完全阻挡它也可以通过阻挡物自身的振动继续向外传播。<br><img  src=\"/images/article/Games104/12/Games104_12_65.png\"  ><span class=\"image-caption\">障碍和遮挡</span></p>\n<p>因此在复杂的场景中往往需要使用一些采样的方法来模拟声音传播的效果。<br><img  src=\"/images/article/Games104/12/Games104_12_66.png\"  ><span class=\"image-caption\">障碍和遮挡2</span></p>\n<h4 id=\"混响（Reverb）\"><a href=\"#混响（Reverb）\" class=\"headerlink\" title=\"混响（Reverb）\"></a>混响（Reverb）</h4><p>除此之外声音在室内场景中还会出现<b>混响(reverb)</b>的现象，这是由于声波在场景中不断反射所导致的。<br><img  src=\"/images/article/Games104/12/Games104_12_67.png\"  ><span class=\"image-caption\">混响</span></p>\n<p>混响的效果很大程度上取决于材质的吸声特性，不同材质往往在不同的频率上有着巨大的性能差异。另一方面混响也取决于场景的几何特征。<br><img  src=\"/images/article/Games104/12/Games104_12_68.png\"  ><span class=\"image-caption\">混响2</span><br><img  src=\"/images/article/Games104/12/Games104_12_69.png\"  ><span class=\"image-caption\">混响3</span></p>\n<p>通过调整不同的混响组合比例可以实现丰富的声学效果。<br><img  src=\"/images/article/Games104/12/Games104_12_70.png\"  ><span class=\"image-caption\">基于声学参数的混响效果控制</span></p>\n<h4 id=\"运动中的声（Sound-in-Motion）\"><a href=\"#运动中的声（Sound-in-Motion）\" class=\"headerlink\" title=\"运动中的声（Sound in Motion）\"></a>运动中的声（Sound in Motion）</h4><p>当声源发生运动时由于Doppler效应会导致接收端接收到的频率发生变化。<br><img  src=\"/images/article/Games104/12/Games104_12_71.png\"  ><span class=\"image-caption\">运动中的声：多普勒效应</span><br><img  src=\"/images/article/Games104/12/Games104_12_72.png\"  ><span class=\"image-caption\">运动中的声：多普勒效应2</span></p>\n<h4 id=\"声场（Sound-Field）\"><a href=\"#声场（Sound-Field）\" class=\"headerlink\" title=\"声场（Sound Field）\"></a>声场（Sound Field）</h4><p>很多时候还可以对整个声场进行采集。<br><img  src=\"/images/article/Games104/12/Games104_12_73.png\"  ><span class=\"image-caption\">空间化-声场</span></p>\n<p>目前市面上常用的专业级声学引擎包括fmod或wwise等，这些引擎可以更好地辅助专业的声学设计。<br><img  src=\"/images/article/Games104/12/Games104_12_74.png\"  ><span class=\"image-caption\">常见的中间件</span><br><img  src=\"/images/article/Games104/12/Games104_12_75.png\"  ><span class=\"image-caption\">音频中间件如何工作的</span></p>\n<p>目前想要表现大规模场景的声学特性仍是非常复杂的。<br><img  src=\"/images/article/Games104/12/Games104_12_76.png\"  ><span class=\"image-caption\">模拟音频世界</span></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p><a href=\"https://peng00bo00.github.io/2022/06/15/GAMES104-NOTES-12.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1bU4y1R7x5/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture12_Effects.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}