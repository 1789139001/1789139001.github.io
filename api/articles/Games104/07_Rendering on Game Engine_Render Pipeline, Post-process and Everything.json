{"title":"现代游戏引擎 - 游戏中渲染管线、后处理和其他的一切（七）","slug":"Games104/07_Rendering on Game Engine_Render Pipeline, Post-process and Everything","date":"2022-09-21T11:33:38.000Z","updated":"2023-11-29T02:42:01.737Z","comments":true,"path":"api/articles/Games104/07_Rendering on Game Engine_Render Pipeline, Post-process and Everything.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/07/Games104_07_01.png","/images/article/Games104/07/Games104_07_02.png","/images/article/Games104/07/Games104_07_03.png","/images/article/Games104/07/Games104_07_04.png","/images/article/Games104/07/Games104_07_05.png","/images/article/Games104/07/Games104_07_06.png","/images/article/Games104/07/Games104_07_07.png","/images/article/Games104/07/Games104_07_08.png","/images/article/Games104/07/Games104_07_09.png","/images/article/Games104/07/Games104_07_10.png","/images/article/Games104/07/Games104_07_11.png","/images/article/Games104/07/Games104_07_12.png","/images/article/Games104/07/Games104_07_13.png","/images/article/Games104/07/Games104_07_14.png","/images/article/Games104/07/Games104_07_15.png","/images/article/Games104/07/Games104_07_16.png","/images/article/Games104/07/Games104_07_17.png","/images/article/Games104/07/Games104_07_18.png","/images/article/Games104/07/Games104_07_19.png","/images/article/Games104/07/Games104_07_20.png","/images/article/Games104/07/Games104_07_21.png","/images/article/Games104/07/Games104_07_23.png","/images/article/Games104/07/Games104_07_24.png","/images/article/Games104/07/Games104_07_25.png","/images/article/Games104/07/Games104_07_26.png","/images/article/Games104/07/Games104_07_27.png","/images/article/Games104/07/Games104_07_28.png","/images/article/Games104/07/Games104_07_29.png","/images/article/Games104/07/Games104_07_30.png","/images/article/Games104/07/Games104_07_31.png","/images/article/Games104/07/Games104_07_32.png","/images/article/Games104/07/Games104_07_33.png","/images/article/Games104/07/Games104_07_35.png","/images/article/Games104/07/Games104_07_36.png","/images/article/Games104/07/Games104_07_37.png","/images/article/Games104/07/Games104_07_38.png","/images/article/Games104/07/Games104_07_39.png","/images/article/Games104/07/Games104_07_40.png","/images/article/Games104/07/Games104_07_41.png","/images/article/Games104/07/Games104_07_42.png"],"cover":"/images/background/Rendering-Game-Engine-03.jpg","content":"<h2 id=\"环境光遮蔽（Ambient-Occlusion）\"><a href=\"#环境光遮蔽（Ambient-Occlusion）\" class=\"headerlink\" title=\"环境光遮蔽（Ambient Occlusion）\"></a>环境光遮蔽（Ambient Occlusion）</h2><p>在之前的章节中，我们提到过对于阴影的处理，但有一种阴影是难以通过这种方式来处理的——物体自身局部对光线的遮挡，<br>比如人物眼角对皮肤、鼻子对面部的遮挡阴影。虽然从理论上来说，这种阴影也符合光照方程，但由于其局部遮挡的特性，<br>在统一的光照模型处理中很难得到较好的效果。<br><img src=\"/images/article/Games104/07/Games104_07_01.png\"><span class=\"image-caption\">Ambient Occlusion</span></p>\n<h3 id=\"预计算环境光遮蔽（Precomputed-AO）\"><a href=\"#预计算环境光遮蔽（Precomputed-AO）\" class=\"headerlink\" title=\"预计算环境光遮蔽（Precomputed AO）\"></a>预计算环境光遮蔽（Precomputed AO）</h3><p>Precomputed AO思想是将AO信息存储在角色纹理中，这样即使我们没有AO真正对应的网格结构，<br>也可以有较好的AO效果。这也是现在很多商业项目使用的方法。<br><img src=\"/images/article/Games104/07/Games104_07_02.png\"><span class=\"image-caption\">Precomputed AO</span><br>其特点也很明显：</p>\n<ol>\n<li>无需几何上的遮蔽关系；</li>\n<li>需要额外的纹理存储信息；</li>\n<li>只能处理静态对象。</li>\n</ol>\n<h3 id=\"屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）\"><a href=\"#屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）\" class=\"headerlink\" title=\"屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）\"></a>屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）</h3><p>SSAO的思想是将是对屏幕像素进行局部空间采样，计算点可显示的概率，作为最终颜色的比例系数。<br><img src=\"/images/article/Games104/07/Games104_07_03.png\"><span class=\"image-caption\">SSAO</span></p>\n<p>SSAO采样时使用的是球体区域采样，但实际我们看到一个平面时，可视区域只有半球。因此对其进行优化后改为SSAO+的方式进行处理：</p>\n<ol>\n<li>沿法线方向在视图空间生成半球面；</li>\n<li>多次区域采样，判断是否被遮蔽，计算颜色衰减比例。</li>\n</ol>\n<p><img src=\"/images/article/Games104/07/Games104_07_04.png\"><span class=\"image-caption\">SSAO+</span></p>\n<p>相比Precomputed AO优点：动态处理AO效果</p>\n<p>相比Precomputed AO缺点：</p>\n<ol>\n<li>实时计算量较大；</li>\n<li>需要有真实的遮蔽结构；</li>\n<li>AO判断错误（当一个像素覆盖的深度很大也就是距离摄像机很远时，用球面进行采样计算覆盖的区域很大，很可能不是局部遮挡关系了，<br>不应该进行处理。屏幕空间没有几何信息，因此无法判断采样区域内的对象关系，应该可以设定阈值进行一定的优化）</li>\n</ol>\n<h3 id=\"基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）\"><a href=\"#基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）\" class=\"headerlink\" title=\"基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）\"></a>基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）</h3><p>HBAO假设各个方向上的光贡献相同（这也是算法的缺陷），对SSAO+在计算衰减比例上做了简化：区域采样点计算比例 =&gt; 积分切面最大仰角<br><img src=\"/images/article/Games104/07/Games104_07_05.png\"><span class=\"image-caption\">HBAO</span></p>\n<h3 id=\"基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）\"><a href=\"#基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）\" class=\"headerlink\" title=\"基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）\"></a>基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）</h3><p>具体来说，GTAO在HBAO的基础上移除了随着距离衰减的可见性函数，转而使用一个常量1作为可见性（不过恢复了正常积分中的光线与法线之间的余弦项），<br>为了避免硬切导致的瑕疵，会考虑添加一个从一个较大的距离到最大的采样半径上使用一个从1到0的线性混合权重。为了模拟near-field的interreflection，<br>则是通过对多个具有代表性的场景在不同的albedo作用下的GI跟AO之间的数值关系进行匹配映射，得到了两者之间的关系的解析模拟解。<br><img src=\"/images/article/Games104/07/Games104_07_06.png\"><span class=\"image-caption\">GTAO</span></p>\n<h3 id=\"光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）\"><a href=\"#光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）\" class=\"headerlink\" title=\"光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）\"></a>光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）</h3><p>基于RTX的硬件，每个像素发出一些射线来进行遮蔽检测来计算AO情况。<br><img src=\"/images/article/Games104/07/Games104_07_07.png\"><span class=\"image-caption\">Ray-Tracing Ambient Occlusion</span></p>\n<h2 id=\"雾效（Fog）\"><a href=\"#雾效（Fog）\" class=\"headerlink\" title=\"雾效（Fog）\"></a>雾效（Fog）</h2><p>Fog越浓，透明度约低。</p>\n<h3 id=\"深度雾效（Depth-Fog）\"><a href=\"#深度雾效（Depth-Fog）\" class=\"headerlink\" title=\"深度雾效（Depth Fog）\"></a>深度雾效（Depth Fog）</h3><p>Depth Fog假设空间中充满了均匀的Fog，那么我们就只需要根据Depth缓冲就可以计算看到物体的透明度了。<br>常见的Fog透明度计算方式有三种：线性、指数、指数平方（最常用）。<br><img src=\"/images/article/Games104/07/Games104_07_08.png\"><span class=\"image-caption\">Depth Fog</span></p>\n<h3 id=\"高度雾效（Height-Fog）\"><a href=\"#高度雾效（Height-Fog）\" class=\"headerlink\" title=\"高度雾效（Height Fog）\"></a>高度雾效（Height Fog）</h3><p>Height Fog用来处理与高度相关的Fog，例如从山脚向上看，可以看到雾效；但在山顶缺看不到雾效。<br><img src=\"/images/article/Games104/07/Games104_07_09.png\"><span class=\"image-caption\">Height Fog</span></p>\n<h3 id=\"体积雾（Volumetric-Fog）\"><a href=\"#体积雾（Volumetric-Fog）\" class=\"headerlink\" title=\"体积雾（Volumetric Fog）\"></a>体积雾（Volumetric Fog）</h3><p>以上两种方式的Fog都是在屏幕空间进行处理的，这样有些效果就难以处理了，比如幽暗的环境，一束光透过fog。这就需要体积雾来处理了。</p>\n<p>体积雾根据视锥与摄像机的远近，对空间进行划分（近处密）。对切分后的视锥进行Ray Matching等计算，处理方式与云的处理类似。<br><img src=\"/images/article/Games104/07/Games104_07_10.png\"><span class=\"image-caption\">Volumetric Fog</span></p>\n<h2 id=\"抗锯齿\"><a href=\"#抗锯齿\" class=\"headerlink\" title=\"抗锯齿\"></a>抗锯齿</h2><p>走样的原因：想要表达的东西太细，但是采样频率不足。大概分为三类：</p>\n<ul>\n<li>边缘的采样</li>\n<li>纹理的采样</li>\n<li>高光的采样</li>\n</ul>\n<p><img src=\"/images/article/Games104/07/Games104_07_11.png\"><span class=\"image-caption\">走样的原因</span></p>\n<h3 id=\"Anti-aliasing\"><a href=\"#Anti-aliasing\" class=\"headerlink\" title=\"Anti-aliasing\"></a>Anti-aliasing</h3><p>常用解决方案就是：多采样获取更多的样本，然后对样本进行加权和求和，以产生一个像素颜色<br><img src=\"/images/article/Games104/07/Games104_07_12.png\"><span class=\"image-caption\">Anti-aliasing</span></p>\n<h3 id=\"Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA\"><a href=\"#Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA\" class=\"headerlink\" title=\"Super-sample AA (SSAA) and Multi-sample AA (MSAA)\"></a>Super-sample AA (SSAA) and Multi-sample AA (MSAA)</h3><p>SSAA是通过绘制一个高分辨率的图像做一下滤波变成低分辨率的结果，处理步骤如下：</p>\n<ol>\n<li>在一个像素内取若干个子采样点；</li>\n<li>对子像素点进行颜色计算（采样）；</li>\n<li>根据子像素的颜色和位置，利用一个称之为resolve的合成阶段，计算当前像素的最终颜色输出</li>\n</ol>\n<p>MSAA优化了SSAA的着色次数：每个像素只着色一次，根据子像素覆盖情况，将着色的数据复制到相应的Color位置。<br><img src=\"/images/article/Games104/07/Games104_07_13.png\"><span class=\"image-caption\">SSAA and MSAA</span></p>\n<h3 id=\"FXAA（Fast-Approximate-Anti-aliasing）\"><a href=\"#FXAA（Fast-Approximate-Anti-aliasing）\" class=\"headerlink\" title=\"FXAA（Fast Approximate Anti-aliasing）\"></a>FXAA（Fast Approximate Anti-aliasing）</h3><p>核心思想：提取边缘像素；将边缘像素与周围像素混合。<br><img src=\"/images/article/Games104/07/Games104_07_14.png\"><span class=\"image-caption\">FXAA</span></p>\n<p>为了判断边缘像素法线方向，通常会计算自身以及周围像素（8个）亮度，计算其中最大值与最小值之差作为判断依据。<br>（亮度不同的地方，以不同的阈值判断，缓解局部高频信息丢失）<br><img src=\"/images/article/Games104/07/Games104_07_15.png\"><span class=\"image-caption\">卷积计算偏移方向</span></p>\n<p>在确定像素边缘方向之后，就需要进一步确定边缘的法线方向。处理思路如下：若边缘为水平方向，则判断上下像素与自身像素亮度的差值；<br>若边缘为垂直方向，则判断左右像素与自身像素亮度的差值。(法线朝向亮度变化大的方向)<br><img src=\"/images/article/Games104/07/Games104_07_16.png\"><span class=\"image-caption\">边缘搜索算法</span></p>\n<p>FXAA算法在颜色混合时，首先会计算当前像素处于边线中的比例位置。然后根据比例位置，对当前像素的uv做偏移。<br><img src=\"/images/article/Games104/07/Games104_07_17.png\"><span class=\"image-caption\">计算混合系数</span></p>\n<h3 id=\"TAA（Temporal-Anti-aliasing）\"><a href=\"#TAA（Temporal-Anti-aliasing）\" class=\"headerlink\" title=\"TAA（Temporal Anti-aliasing）\"></a>TAA（Temporal Anti-aliasing）</h3><p>TAA分为采样（sampling）和合成（resolve）两个过程。</p>\n<ul>\n<li>采用：常见的做法是在每帧中对摄像机的视锥体矩阵做偏移，以达到多次采样的效果。</li>\n<li>合成：为了避免采样的像素差异过大，使用Motion Vector：计算像素点在当前帧和上一帧的移动，<br>在融合时进行差异判断，放弃掉那些颜色差异大的历史像素点</li>\n</ul>\n<p>这种采样方法存在很多问题：</p>\n<ol>\n<li>由于舍弃了历史像素，会出现部分顶点闪烁。</li>\n<li>当前画面的像素点与上一帧的矩形像素点有偏移，插值合成导致了像素的模糊。</li>\n<li>Ghosting问题：光照变化或物体运动，导致历史样本失效；</li>\n<li>骨骼动画、顶点动画需要额外计算处理<br><img src=\"/images/article/Games104/07/Games104_07_18.png\"><span class=\"image-caption\">TAA</span></li>\n</ol>\n<h2 id=\"后处理\"><a href=\"#后处理\" class=\"headerlink\" title=\"后处理\"></a>后处理</h2><p>后处理：在Camera渲染完成之后，拿到渲染的纹理再对其进行处理。通常后处理是用来保证画面正确以及特殊效果<br>，但我们之前提到的SSAO、Depth Fog其实也算是在后处理流程中实现的。这里简单介绍一下常见的后处理效果。</p>\n<h3 id=\"光晕（Bloom）\"><a href=\"#光晕（Bloom）\" class=\"headerlink\" title=\"光晕（Bloom）\"></a>光晕（Bloom）</h3><p>现实中，我们看到的强光源时，周围会有一圈光晕，Bloom就是为了处理这类效果。</p>\n<p>Bloom的产生：</p>\n<ul>\n<li>相机透镜不能完美聚焦</li>\n<li>Airy disk，光会在眼里产生散射</li>\n</ul>\n<p><img src=\"/images/article/Games104/07/Games104_07_19.png\"><span class=\"image-caption\">光晕</span></p>\n<h3 id=\"处理步骤\"><a href=\"#处理步骤\" class=\"headerlink\" title=\"处理步骤\"></a>处理步骤</h3><p><img src=\"/images/article/Games104/07/Games104_07_20.png\"><span class=\"image-caption\">提取高亮区域</span></p>\n<p>利用高斯模糊与低阶亮度对所提取的亮度区域进行模糊处理，以达到高效计算。然后将模糊化的亮度图与原图以一定比例进行叠加。<br><img src=\"/images/article/Games104/07/Games104_07_21.png\"><span class=\"image-caption\">高斯模糊</span><br><img src=\"/images/article/Games104/07/Games104_07_22.png\"><span class=\"image-caption\">高斯滤波金字塔</span></p>\n<h3 id=\"色调映射（Tone-Mapping）\"><a href=\"#色调映射（Tone-Mapping）\" class=\"headerlink\" title=\"色调映射（Tone Mapping）\"></a>色调映射（Tone Mapping）</h3><p>自然界中亮度范围很大，但我们用来显示的设备亮度范围是有限的。若不对颜色做任何处理，但显示的颜色亮度超出显示上限时就会被截断，产生过曝显现。</p>\n<p>为了处理这一问题，就需要Tone Mapping将显示的颜色映射到显示器能够处理的亮度范围内。<br>颜色的映射方案就是Tone Mapping的核心（Tone Mapping Curve）。</p>\n<h4 id=\"Filmic-s-curve\"><a href=\"#Filmic-s-curve\" class=\"headerlink\" title=\"Filmic s-curve\"></a>Filmic s-curve</h4><p>Filmic s-curve是行业早期剔除的颜色映射曲线，提出者在大量实践基础上进行参数化拟合。其效果然游戏画质有了极大提升。<br><img src=\"/images/article/Games104/07/Games104_07_23.png\"><span class=\"image-caption\">Filmic s-curve</span></p>\n<h4 id=\"ACES\"><a href=\"#ACES\" class=\"headerlink\" title=\"ACES\"></a>ACES</h4><p>ACES是目前最被认可的颜色曲线，能够有效得在各种终端有稳定的显示效果。<br><img src=\"/images/article/Games104/07/Games104_07_24.png\"><span class=\"image-caption\">ACES</span></p>\n<p><img src=\"/images/article/Games104/07/Games104_07_25.png\"><span class=\"image-caption\">三条色调映射效果对比</span></p>\n<h3 id=\"Color-Grading\"><a href=\"#Color-Grading\" class=\"headerlink\" title=\"Color Grading\"></a>Color Grading</h3><p>Color Grading用来调整画面的色调，以达到烘托气氛或特殊的画风效果。<br>通常的处理方式为：对原有像素颜色通过查表的变为需要的颜色。映射的表称为Lookup Table (LUT)<br><img src=\"/images/article/Games104/07/Games104_07_26.png\"><span class=\"image-caption\">LUT</span></p>\n<p>因为颜色是连续的，将3D颜色空间转换到2D纹理使用起来效果差不多。<br><img src=\"/images/article/Games104/07/Games104_07_27.png\"><span class=\"image-caption\">3D颜色空间到2D纹理</span></p>\n<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a>渲染管线</h2><p>到目前为止，渲染的需要处理的内容基本都涉及了：渲染方程、大地、天空、AO等。<br>但还有一个核心问题：如何将我们提到的渲染相关的内容串联起来，使得整个渲染系统能够正常工作？<br>渲染管线就是来管理整个渲染的流程。</p>\n<h3 id=\"前向渲染（Forward-Rendering）\"><a href=\"#前向渲染（Forward-Rendering）\" class=\"headerlink\" title=\"前向渲染（Forward Rendering）\"></a>前向渲染（Forward Rendering）</h3><p><img src=\"/images/article/Games104/07/Games104_07_28.png\"><span class=\"image-caption\">前向渲染</span></p>\n<p>物体渲染顺序：总体来说，先由近及远渲染不透明物体（避免OverDraw），再由远及近渲染半透明物体（处理颜色混合）</p>\n<p>半透明物体穿插绘制问题无法完美解决，只能用物体的中心点进行排序处理。<br><img src=\"/images/article/Games104/07/Games104_07_29.png\"><span class=\"image-caption\">排序和渲染透明对象</span></p>\n<h3 id=\"延迟渲染（Deferred-Rendering）\"><a href=\"#延迟渲染（Deferred-Rendering）\" class=\"headerlink\" title=\"延迟渲染（Deferred Rendering）\"></a>延迟渲染（Deferred Rendering）</h3><p>前向渲染的问题就在于，每有一个光源就要对渲染物体处理一遍。当场景中存在大量光源时，开销太大。Deferred Rendering为了避免这种情况，<br>提出了两个Pass的处理方案：第一个Pass存储屏幕像素需要的几何信息（GBuff）；第二个Pass针对像素进行逐光源处理。<br><img src=\"/images/article/Games104/07/Games104_07_30.png\"><span class=\"image-caption\">延迟渲染</span></p>\n<p>优点</p>\n<ul>\n<li>只计算可见顶点光照</li>\n<li>G-Buffer的数据，后处理能拿来用</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>高内存占用</li>\n<li>不支持透明对象</li>\n<li>对MSAA不友好<br><img src=\"/images/article/Games104/07/Games104_07_31.png\"><span class=\"image-caption\">延迟渲染优缺点</span></li>\n</ul>\n<h3 id=\"分块渲染（Tile-based-Rendering）\"><a href=\"#分块渲染（Tile-based-Rendering）\" class=\"headerlink\" title=\"分块渲染（Tile-based Rendering）\"></a>分块渲染（Tile-based Rendering）</h3><p>由于移动端的带宽、内存以及散热极其敏感，常规的PC GPU架构并不适合。为了应对这一问题，<br>现代移动端设备通常使用Tile-based Rendering的GPU架构：将画面拆分成许多小块（Tile），渲染绘制时针对Tile进行处理。<br><img src=\"/images/article/Games104/07/Games104_07_32.png\"><span class=\"image-caption\">分块渲染</span></p>\n<p>优点：</p>\n<ol>\n<li>较少GPU的读写压力；</li>\n<li>将Light附着到Tile优化Light处理；</li>\n<li>根据Pre-Z与光照范围减少光照计算<br><img src=\"/images/article/Games104/07/Games104_07_33.png\"><span class=\"image-caption\">屏幕瓷砖中的灯光列表</span><br><img src=\"/images/article/Games104/07/Games104_07_34.png\"><span class=\"image-caption\">深度范围优化</span></li>\n</ol>\n<p>Forward+(Tile-based Forward) Rendering ：对Forward模式使用Tile-based Rendering<br>TBDR（Tile-based Deferred Rendering）：对Deferred模式使用Tile-based Rendering<br><img src=\"/images/article/Games104/07/Games104_07_35.png\"><span class=\"image-caption\">Forward+ Rendering</span></p>\n<h3 id=\"基于集群的渲染（Cluster-based-Rendering）\"><a href=\"#基于集群的渲染（Cluster-based-Rendering）\" class=\"headerlink\" title=\"基于集群的渲染（Cluster-based Rendering）\"></a>基于集群的渲染（Cluster-based Rendering）</h3><p>将视图空间划分为多个四棱锥（Cluster），每个Tile单独计算Light的可见性。<br><img src=\"/images/article/Games104/07/Games104_07_36.png\"><span class=\"image-caption\">Cluster-based Rendering</span></p>\n<h3 id=\"可见性缓冲区（Visibility-Buffer）\"><a href=\"#可见性缓冲区（Visibility-Buffer）\" class=\"headerlink\" title=\"可见性缓冲区（Visibility Buffer）\"></a>可见性缓冲区（Visibility Buffer）</h3><p>Visibility Buffer的基本思路是在前一个Pass中生成一个类似于GBuffer的全屏Buffer，<br>其中的每个texel只存primitive ID、uv和贴图ID，进而得到与之关联的所有属性值，法线、粗糙度等等。</p>\n<p>Deferred Rendering在完成GBuff存储之后，就无法再获取原始的Mesh相关数据了；<br>而Visibility Buffer很好处理了这种问题， 对于复杂几何体来说，能够提供更好的细节效果。<br><img src=\"/images/article/Games104/07/Games104_07_37.png\"><span class=\"image-caption\">Visibility Buffer</span></p>\n<p>优点：</p>\n<ol>\n<li>提供更好的几何数据；</li>\n<li>内存、带宽压力小=&gt;可以使用MSAA</li>\n</ol>\n<p>缺点：计算消耗变大（索引不同纹理）</p>\n<h2 id=\"框架图（FrameGraph）\"><a href=\"#框架图（FrameGraph）\" class=\"headerlink\" title=\"框架图（FrameGraph）\"></a>框架图（FrameGraph）</h2><p>可视化依赖和分析管理pipeline<br><img src=\"/images/article/Games104/07/Games104_07_38.png\"><span class=\"image-caption\">FrameGraph</span></p>\n<h2 id=\"V-Sync-G-Sync\"><a href=\"#V-Sync-G-Sync\" class=\"headerlink\" title=\"V-Sync&amp;&amp;G-Sync\"></a>V-Sync&amp;&amp;G-Sync</h2><p>游戏画面出现画面撕裂问题，学术名叫Screen Tear<br><img src=\"/images/article/Games104/07/Games104_07_39.png\"><span class=\"image-caption\">画面撕裂</span></p>\n<p>画面撕裂的原因：引擎渲染不同帧复杂程度不同，所以GPU帧率不固定，但是显示器刷新是固定的。<br>如果在显示器的刷新间隔中间，GPU完成了渲染，就会造成屏幕撕裂<br><img src=\"/images/article/Games104/07/Games104_07_40.png\"><span class=\"image-caption\">画面撕裂原因</span></p>\n<p>垂直同步，是为了解决画面撕裂问题。就是降低帧率，等FrameBuffer写完，再一起刷新界面<br><img src=\"/images/article/Games104/07/Games104_07_41.png\"><span class=\"image-caption\">垂直同步</span></p>\n<h3 id=\"可变刷新率（Variable-Refresh-Rate）\"><a href=\"#可变刷新率（Variable-Refresh-Rate）\" class=\"headerlink\" title=\"可变刷新率（Variable Refresh Rate）\"></a>可变刷新率（Variable Refresh Rate）</h3><p>显示器自适配游戏帧率技术<br><img src=\"/images/article/Games104/07/Games104_07_42.png\"><span class=\"image-caption\">Variable Refresh Rate</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://zhuanlan.zhihu.com/p/533244258\">参考文章1</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/527697509\">参考文章2</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1kY411P7QM/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture07_Rendering%20on%20Game%20Engine_Render%20Pipeline,%20Post-process%20and%20Everything.pdf\">课件PPT</a></p>\n","more":"<h2 id=\"环境光遮蔽（Ambient-Occlusion）\"><a href=\"#环境光遮蔽（Ambient-Occlusion）\" class=\"headerlink\" title=\"环境光遮蔽（Ambient Occlusion）\"></a>环境光遮蔽（Ambient Occlusion）</h2><p>在之前的章节中，我们提到过对于阴影的处理，但有一种阴影是难以通过这种方式来处理的——物体自身局部对光线的遮挡，<br>比如人物眼角对皮肤、鼻子对面部的遮挡阴影。虽然从理论上来说，这种阴影也符合光照方程，但由于其局部遮挡的特性，<br>在统一的光照模型处理中很难得到较好的效果。<br><img  src=\"/images/article/Games104/07/Games104_07_01.png\"  ><span class=\"image-caption\">Ambient Occlusion</span></p>\n<h3 id=\"预计算环境光遮蔽（Precomputed-AO）\"><a href=\"#预计算环境光遮蔽（Precomputed-AO）\" class=\"headerlink\" title=\"预计算环境光遮蔽（Precomputed AO）\"></a>预计算环境光遮蔽（Precomputed AO）</h3><p>Precomputed AO思想是将AO信息存储在角色纹理中，这样即使我们没有AO真正对应的网格结构，<br>也可以有较好的AO效果。这也是现在很多商业项目使用的方法。<br><img  src=\"/images/article/Games104/07/Games104_07_02.png\"  ><span class=\"image-caption\">Precomputed AO</span><br>其特点也很明显：</p>\n<ol>\n<li>无需几何上的遮蔽关系；</li>\n<li>需要额外的纹理存储信息；</li>\n<li>只能处理静态对象。</li>\n</ol>\n<h3 id=\"屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）\"><a href=\"#屏幕空间环境遮挡（Screen-Space-Ambient-Occlusion-SSAO-）\" class=\"headerlink\" title=\"屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）\"></a>屏幕空间环境遮挡（Screen Space Ambient Occlusion+  - SSAO+）</h3><p>SSAO的思想是将是对屏幕像素进行局部空间采样，计算点可显示的概率，作为最终颜色的比例系数。<br><img  src=\"/images/article/Games104/07/Games104_07_03.png\"  ><span class=\"image-caption\">SSAO</span></p>\n<p>SSAO采样时使用的是球体区域采样，但实际我们看到一个平面时，可视区域只有半球。因此对其进行优化后改为SSAO+的方式进行处理：</p>\n<ol>\n<li>沿法线方向在视图空间生成半球面；</li>\n<li>多次区域采样，判断是否被遮蔽，计算颜色衰减比例。</li>\n</ol>\n<p><img  src=\"/images/article/Games104/07/Games104_07_04.png\"  ><span class=\"image-caption\">SSAO+</span></p>\n<p>相比Precomputed AO优点：动态处理AO效果</p>\n<p>相比Precomputed AO缺点：</p>\n<ol>\n<li>实时计算量较大；</li>\n<li>需要有真实的遮蔽结构；</li>\n<li>AO判断错误（当一个像素覆盖的深度很大也就是距离摄像机很远时，用球面进行采样计算覆盖的区域很大，很可能不是局部遮挡关系了，<br>不应该进行处理。屏幕空间没有几何信息，因此无法判断采样区域内的对象关系，应该可以设定阈值进行一定的优化）</li>\n</ol>\n<h3 id=\"基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）\"><a href=\"#基于地平线的环境光遮蔽（Horizon-basedAmbient-Occlusion-HBAO）\" class=\"headerlink\" title=\"基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）\"></a>基于地平线的环境光遮蔽（Horizon-basedAmbient Occlusion - HBAO）</h3><p>HBAO假设各个方向上的光贡献相同（这也是算法的缺陷），对SSAO+在计算衰减比例上做了简化：区域采样点计算比例 &#x3D;&gt; 积分切面最大仰角<br><img  src=\"/images/article/Games104/07/Games104_07_05.png\"  ><span class=\"image-caption\">HBAO</span></p>\n<h3 id=\"基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）\"><a href=\"#基于地面实况的环境遮挡（Ground-Truth-based-Ambient-Occlusion-GTAO）\" class=\"headerlink\" title=\"基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）\"></a>基于地面实况的环境遮挡（Ground Truth-based Ambient Occlusion - GTAO）</h3><p>具体来说，GTAO在HBAO的基础上移除了随着距离衰减的可见性函数，转而使用一个常量1作为可见性（不过恢复了正常积分中的光线与法线之间的余弦项），<br>为了避免硬切导致的瑕疵，会考虑添加一个从一个较大的距离到最大的采样半径上使用一个从1到0的线性混合权重。为了模拟near-field的interreflection，<br>则是通过对多个具有代表性的场景在不同的albedo作用下的GI跟AO之间的数值关系进行匹配映射，得到了两者之间的关系的解析模拟解。<br><img  src=\"/images/article/Games104/07/Games104_07_06.png\"  ><span class=\"image-caption\">GTAO</span></p>\n<h3 id=\"光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）\"><a href=\"#光线追踪环境光遮蔽（Ray-Tracing-Ambient-Occlusion）\" class=\"headerlink\" title=\"光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）\"></a>光线追踪环境光遮蔽（Ray-Tracing Ambient Occlusion）</h3><p>基于RTX的硬件，每个像素发出一些射线来进行遮蔽检测来计算AO情况。<br><img  src=\"/images/article/Games104/07/Games104_07_07.png\"  ><span class=\"image-caption\">Ray-Tracing Ambient Occlusion</span></p>\n<h2 id=\"雾效（Fog）\"><a href=\"#雾效（Fog）\" class=\"headerlink\" title=\"雾效（Fog）\"></a>雾效（Fog）</h2><p>Fog越浓，透明度约低。</p>\n<h3 id=\"深度雾效（Depth-Fog）\"><a href=\"#深度雾效（Depth-Fog）\" class=\"headerlink\" title=\"深度雾效（Depth Fog）\"></a>深度雾效（Depth Fog）</h3><p>Depth Fog假设空间中充满了均匀的Fog，那么我们就只需要根据Depth缓冲就可以计算看到物体的透明度了。<br>常见的Fog透明度计算方式有三种：线性、指数、指数平方（最常用）。<br><img  src=\"/images/article/Games104/07/Games104_07_08.png\"  ><span class=\"image-caption\">Depth Fog</span></p>\n<h3 id=\"高度雾效（Height-Fog）\"><a href=\"#高度雾效（Height-Fog）\" class=\"headerlink\" title=\"高度雾效（Height Fog）\"></a>高度雾效（Height Fog）</h3><p>Height Fog用来处理与高度相关的Fog，例如从山脚向上看，可以看到雾效；但在山顶缺看不到雾效。<br><img  src=\"/images/article/Games104/07/Games104_07_09.png\"  ><span class=\"image-caption\">Height Fog</span></p>\n<h3 id=\"体积雾（Volumetric-Fog）\"><a href=\"#体积雾（Volumetric-Fog）\" class=\"headerlink\" title=\"体积雾（Volumetric Fog）\"></a>体积雾（Volumetric Fog）</h3><p>以上两种方式的Fog都是在屏幕空间进行处理的，这样有些效果就难以处理了，比如幽暗的环境，一束光透过fog。这就需要体积雾来处理了。</p>\n<p>体积雾根据视锥与摄像机的远近，对空间进行划分（近处密）。对切分后的视锥进行Ray Matching等计算，处理方式与云的处理类似。<br><img  src=\"/images/article/Games104/07/Games104_07_10.png\"  ><span class=\"image-caption\">Volumetric Fog</span></p>\n<h2 id=\"抗锯齿\"><a href=\"#抗锯齿\" class=\"headerlink\" title=\"抗锯齿\"></a>抗锯齿</h2><p>走样的原因：想要表达的东西太细，但是采样频率不足。大概分为三类：</p>\n<ul>\n<li>边缘的采样</li>\n<li>纹理的采样</li>\n<li>高光的采样</li>\n</ul>\n<p><img  src=\"/images/article/Games104/07/Games104_07_11.png\"  ><span class=\"image-caption\">走样的原因</span></p>\n<h3 id=\"Anti-aliasing\"><a href=\"#Anti-aliasing\" class=\"headerlink\" title=\"Anti-aliasing\"></a>Anti-aliasing</h3><p>常用解决方案就是：多采样获取更多的样本，然后对样本进行加权和求和，以产生一个像素颜色<br><img  src=\"/images/article/Games104/07/Games104_07_12.png\"  ><span class=\"image-caption\">Anti-aliasing</span></p>\n<h3 id=\"Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA\"><a href=\"#Super-sample-AA-SSAA-and-Multi-sample-AA-MSAA\" class=\"headerlink\" title=\"Super-sample AA (SSAA) and Multi-sample AA (MSAA)\"></a>Super-sample AA (SSAA) and Multi-sample AA (MSAA)</h3><p>SSAA是通过绘制一个高分辨率的图像做一下滤波变成低分辨率的结果，处理步骤如下：</p>\n<ol>\n<li>在一个像素内取若干个子采样点；</li>\n<li>对子像素点进行颜色计算（采样）；</li>\n<li>根据子像素的颜色和位置，利用一个称之为resolve的合成阶段，计算当前像素的最终颜色输出</li>\n</ol>\n<p>MSAA优化了SSAA的着色次数：每个像素只着色一次，根据子像素覆盖情况，将着色的数据复制到相应的Color位置。<br><img  src=\"/images/article/Games104/07/Games104_07_13.png\"  ><span class=\"image-caption\">SSAA and MSAA</span></p>\n<h3 id=\"FXAA（Fast-Approximate-Anti-aliasing）\"><a href=\"#FXAA（Fast-Approximate-Anti-aliasing）\" class=\"headerlink\" title=\"FXAA（Fast Approximate Anti-aliasing）\"></a>FXAA（Fast Approximate Anti-aliasing）</h3><p>核心思想：提取边缘像素；将边缘像素与周围像素混合。<br><img  src=\"/images/article/Games104/07/Games104_07_14.png\"  ><span class=\"image-caption\">FXAA</span></p>\n<p>为了判断边缘像素法线方向，通常会计算自身以及周围像素（8个）亮度，计算其中最大值与最小值之差作为判断依据。<br>（亮度不同的地方，以不同的阈值判断，缓解局部高频信息丢失）<br><img  src=\"/images/article/Games104/07/Games104_07_15.png\"  ><span class=\"image-caption\">卷积计算偏移方向</span></p>\n<p>在确定像素边缘方向之后，就需要进一步确定边缘的法线方向。处理思路如下：若边缘为水平方向，则判断上下像素与自身像素亮度的差值；<br>若边缘为垂直方向，则判断左右像素与自身像素亮度的差值。(法线朝向亮度变化大的方向)<br><img  src=\"/images/article/Games104/07/Games104_07_16.png\"  ><span class=\"image-caption\">边缘搜索算法</span></p>\n<p>FXAA算法在颜色混合时，首先会计算当前像素处于边线中的比例位置。然后根据比例位置，对当前像素的uv做偏移。<br><img  src=\"/images/article/Games104/07/Games104_07_17.png\"  ><span class=\"image-caption\">计算混合系数</span></p>\n<h3 id=\"TAA（Temporal-Anti-aliasing）\"><a href=\"#TAA（Temporal-Anti-aliasing）\" class=\"headerlink\" title=\"TAA（Temporal Anti-aliasing）\"></a>TAA（Temporal Anti-aliasing）</h3><p>TAA分为采样（sampling）和合成（resolve）两个过程。</p>\n<ul>\n<li>采用：常见的做法是在每帧中对摄像机的视锥体矩阵做偏移，以达到多次采样的效果。</li>\n<li>合成：为了避免采样的像素差异过大，使用Motion Vector：计算像素点在当前帧和上一帧的移动，<br>在融合时进行差异判断，放弃掉那些颜色差异大的历史像素点</li>\n</ul>\n<p>这种采样方法存在很多问题：</p>\n<ol>\n<li>由于舍弃了历史像素，会出现部分顶点闪烁。</li>\n<li>当前画面的像素点与上一帧的矩形像素点有偏移，插值合成导致了像素的模糊。</li>\n<li>Ghosting问题：光照变化或物体运动，导致历史样本失效；</li>\n<li>骨骼动画、顶点动画需要额外计算处理<br><img  src=\"/images/article/Games104/07/Games104_07_18.png\"  ><span class=\"image-caption\">TAA</span></li>\n</ol>\n<h2 id=\"后处理\"><a href=\"#后处理\" class=\"headerlink\" title=\"后处理\"></a>后处理</h2><p>后处理：在Camera渲染完成之后，拿到渲染的纹理再对其进行处理。通常后处理是用来保证画面正确以及特殊效果<br>，但我们之前提到的SSAO、Depth Fog其实也算是在后处理流程中实现的。这里简单介绍一下常见的后处理效果。</p>\n<h3 id=\"光晕（Bloom）\"><a href=\"#光晕（Bloom）\" class=\"headerlink\" title=\"光晕（Bloom）\"></a>光晕（Bloom）</h3><p>现实中，我们看到的强光源时，周围会有一圈光晕，Bloom就是为了处理这类效果。</p>\n<p>Bloom的产生：</p>\n<ul>\n<li>相机透镜不能完美聚焦</li>\n<li>Airy disk，光会在眼里产生散射</li>\n</ul>\n<p><img  src=\"/images/article/Games104/07/Games104_07_19.png\"  ><span class=\"image-caption\">光晕</span></p>\n<h3 id=\"处理步骤\"><a href=\"#处理步骤\" class=\"headerlink\" title=\"处理步骤\"></a>处理步骤</h3><p><img  src=\"/images/article/Games104/07/Games104_07_20.png\"  ><span class=\"image-caption\">提取高亮区域</span></p>\n<p>利用高斯模糊与低阶亮度对所提取的亮度区域进行模糊处理，以达到高效计算。然后将模糊化的亮度图与原图以一定比例进行叠加。<br><img  src=\"/images/article/Games104/07/Games104_07_21.png\"  ><span class=\"image-caption\">高斯模糊</span><br><img  src=\"/images/article/Games104/07/Games104_07_22.png\"  ><span class=\"image-caption\">高斯滤波金字塔</span></p>\n<h3 id=\"色调映射（Tone-Mapping）\"><a href=\"#色调映射（Tone-Mapping）\" class=\"headerlink\" title=\"色调映射（Tone Mapping）\"></a>色调映射（Tone Mapping）</h3><p>自然界中亮度范围很大，但我们用来显示的设备亮度范围是有限的。若不对颜色做任何处理，但显示的颜色亮度超出显示上限时就会被截断，产生过曝显现。</p>\n<p>为了处理这一问题，就需要Tone Mapping将显示的颜色映射到显示器能够处理的亮度范围内。<br>颜色的映射方案就是Tone Mapping的核心（Tone Mapping Curve）。</p>\n<h4 id=\"Filmic-s-curve\"><a href=\"#Filmic-s-curve\" class=\"headerlink\" title=\"Filmic s-curve\"></a>Filmic s-curve</h4><p>Filmic s-curve是行业早期剔除的颜色映射曲线，提出者在大量实践基础上进行参数化拟合。其效果然游戏画质有了极大提升。<br><img  src=\"/images/article/Games104/07/Games104_07_23.png\"  ><span class=\"image-caption\">Filmic s-curve</span></p>\n<h4 id=\"ACES\"><a href=\"#ACES\" class=\"headerlink\" title=\"ACES\"></a>ACES</h4><p>ACES是目前最被认可的颜色曲线，能够有效得在各种终端有稳定的显示效果。<br><img  src=\"/images/article/Games104/07/Games104_07_24.png\"  ><span class=\"image-caption\">ACES</span></p>\n<p><img  src=\"/images/article/Games104/07/Games104_07_25.png\"  ><span class=\"image-caption\">三条色调映射效果对比</span></p>\n<h3 id=\"Color-Grading\"><a href=\"#Color-Grading\" class=\"headerlink\" title=\"Color Grading\"></a>Color Grading</h3><p>Color Grading用来调整画面的色调，以达到烘托气氛或特殊的画风效果。<br>通常的处理方式为：对原有像素颜色通过查表的变为需要的颜色。映射的表称为Lookup Table (LUT)<br><img  src=\"/images/article/Games104/07/Games104_07_26.png\"  ><span class=\"image-caption\">LUT</span></p>\n<p>因为颜色是连续的，将3D颜色空间转换到2D纹理使用起来效果差不多。<br><img  src=\"/images/article/Games104/07/Games104_07_27.png\"  ><span class=\"image-caption\">3D颜色空间到2D纹理</span></p>\n<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a>渲染管线</h2><p>到目前为止，渲染的需要处理的内容基本都涉及了：渲染方程、大地、天空、AO等。<br>但还有一个核心问题：如何将我们提到的渲染相关的内容串联起来，使得整个渲染系统能够正常工作？<br>渲染管线就是来管理整个渲染的流程。</p>\n<h3 id=\"前向渲染（Forward-Rendering）\"><a href=\"#前向渲染（Forward-Rendering）\" class=\"headerlink\" title=\"前向渲染（Forward Rendering）\"></a>前向渲染（Forward Rendering）</h3><p><img  src=\"/images/article/Games104/07/Games104_07_28.png\"  ><span class=\"image-caption\">前向渲染</span></p>\n<p>物体渲染顺序：总体来说，先由近及远渲染不透明物体（避免OverDraw），再由远及近渲染半透明物体（处理颜色混合）</p>\n<p>半透明物体穿插绘制问题无法完美解决，只能用物体的中心点进行排序处理。<br><img  src=\"/images/article/Games104/07/Games104_07_29.png\"  ><span class=\"image-caption\">排序和渲染透明对象</span></p>\n<h3 id=\"延迟渲染（Deferred-Rendering）\"><a href=\"#延迟渲染（Deferred-Rendering）\" class=\"headerlink\" title=\"延迟渲染（Deferred Rendering）\"></a>延迟渲染（Deferred Rendering）</h3><p>前向渲染的问题就在于，每有一个光源就要对渲染物体处理一遍。当场景中存在大量光源时，开销太大。Deferred Rendering为了避免这种情况，<br>提出了两个Pass的处理方案：第一个Pass存储屏幕像素需要的几何信息（GBuff）；第二个Pass针对像素进行逐光源处理。<br><img  src=\"/images/article/Games104/07/Games104_07_30.png\"  ><span class=\"image-caption\">延迟渲染</span></p>\n<p>优点</p>\n<ul>\n<li>只计算可见顶点光照</li>\n<li>G-Buffer的数据，后处理能拿来用</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>高内存占用</li>\n<li>不支持透明对象</li>\n<li>对MSAA不友好<br><img  src=\"/images/article/Games104/07/Games104_07_31.png\"  ><span class=\"image-caption\">延迟渲染优缺点</span></li>\n</ul>\n<h3 id=\"分块渲染（Tile-based-Rendering）\"><a href=\"#分块渲染（Tile-based-Rendering）\" class=\"headerlink\" title=\"分块渲染（Tile-based Rendering）\"></a>分块渲染（Tile-based Rendering）</h3><p>由于移动端的带宽、内存以及散热极其敏感，常规的PC GPU架构并不适合。为了应对这一问题，<br>现代移动端设备通常使用Tile-based Rendering的GPU架构：将画面拆分成许多小块（Tile），渲染绘制时针对Tile进行处理。<br><img  src=\"/images/article/Games104/07/Games104_07_32.png\"  ><span class=\"image-caption\">分块渲染</span></p>\n<p>优点：</p>\n<ol>\n<li>较少GPU的读写压力；</li>\n<li>将Light附着到Tile优化Light处理；</li>\n<li>根据Pre-Z与光照范围减少光照计算<br><img  src=\"/images/article/Games104/07/Games104_07_33.png\"  ><span class=\"image-caption\">屏幕瓷砖中的灯光列表</span><br><img  src=\"/images/article/Games104/07/Games104_07_34.png\"  ><span class=\"image-caption\">深度范围优化</span></li>\n</ol>\n<p>Forward+(Tile-based Forward) Rendering ：对Forward模式使用Tile-based Rendering<br>TBDR（Tile-based Deferred Rendering）：对Deferred模式使用Tile-based Rendering<br><img  src=\"/images/article/Games104/07/Games104_07_35.png\"  ><span class=\"image-caption\">Forward+ Rendering</span></p>\n<h3 id=\"基于集群的渲染（Cluster-based-Rendering）\"><a href=\"#基于集群的渲染（Cluster-based-Rendering）\" class=\"headerlink\" title=\"基于集群的渲染（Cluster-based Rendering）\"></a>基于集群的渲染（Cluster-based Rendering）</h3><p>将视图空间划分为多个四棱锥（Cluster），每个Tile单独计算Light的可见性。<br><img  src=\"/images/article/Games104/07/Games104_07_36.png\"  ><span class=\"image-caption\">Cluster-based Rendering</span></p>\n<h3 id=\"可见性缓冲区（Visibility-Buffer）\"><a href=\"#可见性缓冲区（Visibility-Buffer）\" class=\"headerlink\" title=\"可见性缓冲区（Visibility Buffer）\"></a>可见性缓冲区（Visibility Buffer）</h3><p>Visibility Buffer的基本思路是在前一个Pass中生成一个类似于GBuffer的全屏Buffer，<br>其中的每个texel只存primitive ID、uv和贴图ID，进而得到与之关联的所有属性值，法线、粗糙度等等。</p>\n<p>Deferred Rendering在完成GBuff存储之后，就无法再获取原始的Mesh相关数据了；<br>而Visibility Buffer很好处理了这种问题， 对于复杂几何体来说，能够提供更好的细节效果。<br><img  src=\"/images/article/Games104/07/Games104_07_37.png\"  ><span class=\"image-caption\">Visibility Buffer</span></p>\n<p>优点：</p>\n<ol>\n<li>提供更好的几何数据；</li>\n<li>内存、带宽压力小&#x3D;&gt;可以使用MSAA</li>\n</ol>\n<p>缺点：计算消耗变大（索引不同纹理）</p>\n<h2 id=\"框架图（FrameGraph）\"><a href=\"#框架图（FrameGraph）\" class=\"headerlink\" title=\"框架图（FrameGraph）\"></a>框架图（FrameGraph）</h2><p>可视化依赖和分析管理pipeline<br><img  src=\"/images/article/Games104/07/Games104_07_38.png\"  ><span class=\"image-caption\">FrameGraph</span></p>\n<h2 id=\"V-Sync-G-Sync\"><a href=\"#V-Sync-G-Sync\" class=\"headerlink\" title=\"V-Sync&amp;&amp;G-Sync\"></a>V-Sync&amp;&amp;G-Sync</h2><p>游戏画面出现画面撕裂问题，学术名叫Screen Tear<br><img  src=\"/images/article/Games104/07/Games104_07_39.png\"  ><span class=\"image-caption\">画面撕裂</span></p>\n<p>画面撕裂的原因：引擎渲染不同帧复杂程度不同，所以GPU帧率不固定，但是显示器刷新是固定的。<br>如果在显示器的刷新间隔中间，GPU完成了渲染，就会造成屏幕撕裂<br><img  src=\"/images/article/Games104/07/Games104_07_40.png\"  ><span class=\"image-caption\">画面撕裂原因</span></p>\n<p>垂直同步，是为了解决画面撕裂问题。就是降低帧率，等FrameBuffer写完，再一起刷新界面<br><img  src=\"/images/article/Games104/07/Games104_07_41.png\"  ><span class=\"image-caption\">垂直同步</span></p>\n<h3 id=\"可变刷新率（Variable-Refresh-Rate）\"><a href=\"#可变刷新率（Variable-Refresh-Rate）\" class=\"headerlink\" title=\"可变刷新率（Variable Refresh Rate）\"></a>可变刷新率（Variable Refresh Rate）</h3><p>显示器自适配游戏帧率技术<br><img  src=\"/images/article/Games104/07/Games104_07_42.png\"  ><span class=\"image-caption\">Variable Refresh Rate</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://zhuanlan.zhihu.com/p/533244258\">参考文章1</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/527697509\">参考文章2</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1kY411P7QM/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture07_Rendering%20on%20Game%20Engine_Render%20Pipeline,%20Post-process%20and%20Everything.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}