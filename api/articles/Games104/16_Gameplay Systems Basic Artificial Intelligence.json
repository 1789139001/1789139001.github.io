{"title":"现代游戏引擎 - 基础AI（十六）","slug":"Games104/16_Gameplay Systems Basic Artificial Intelligence","date":"2023-04-15T13:16:55.000Z","updated":"2023-11-29T02:42:01.741Z","comments":true,"path":"api/articles/Games104/16_Gameplay Systems Basic Artificial Intelligence.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/16/Games104_16_01.png","/images/article/Games104/16/Games104_16_02.png","/images/article/Games104/16/Games104_16_03.png","/images/article/Games104/16/Games104_16_04.png","/images/article/Games104/16/Games104_16_06.png","/images/article/Games104/16/Games104_16_07.png","/images/article/Games104/16/Games104_16_08.png","/images/article/Games104/16/Games104_16_09.png","/images/article/Games104/16/Games104_16_10.png","/images/article/Games104/16/Games104_16_11.png","/images/article/Games104/16/Games104_16_12.png","/images/article/Games104/16/Games104_16_14.png","/images/article/Games104/16/Games104_16_15.png","/images/article/Games104/16/Games104_16_16.png","/images/article/Games104/16/Games104_16_17.png","/images/article/Games104/16/Games104_16_19.png","/images/article/Games104/16/Games104_16_20.png","/images/article/Games104/16/Games104_16_21.png","/images/article/Games104/16/Games104_16_24.png","/images/article/Games104/16/Games104_16_26.png","/images/article/Games104/16/Games104_16_27.png","/images/article/Games104/16/Games104_16_30.png","/images/article/Games104/16/Games104_16_31.png","/images/article/Games104/16/Games104_16_32.png","/images/article/Games104/16/Games104_16_34.png","/images/article/Games104/16/Games104_16_35.png","/images/article/Games104/16/Games104_16_40.png","/images/article/Games104/16/Games104_16_41.png","/images/article/Games104/16/Games104_16_42.png","/images/article/Games104/16/Games104_16_43.png","/images/article/Games104/16/Games104_16_44.png","/images/article/Games104/16/Games104_16_45.png","/images/article/Games104/16/Games104_16_47.png","/images/article/Games104/16/Games104_16_48.png","/images/article/Games104/16/Games104_16_49.png","/images/article/Games104/16/Games104_16_50.png","/images/article/Games104/16/Games104_16_51.png","/images/article/Games104/16/Games104_16_53.png","/images/article/Games104/16/Games104_16_54.png","/images/article/Games104/16/Games104_16_55.png","/images/article/Games104/16/Games104_16_57.png","/images/article/Games104/16/Games104_16_58.png","/images/article/Games104/16/Games104_16_59.png","/images/article/Games104/16/Games104_16_60.png","/images/article/Games104/16/Games104_16_61.png","/images/article/Games104/16/Games104_16_62.png","/images/article/Games104/16/Games104_16_63.png","/images/article/Games104/16/Games104_16_65.png","/images/article/Games104/16/Games104_16_66.png","/images/article/Games104/16/Games104_16_67.png","/images/article/Games104/16/Games104_16_69.png","/images/article/Games104/16/Games104_16_70.png","/images/article/Games104/16/Games104_16_71.png","/images/article/Games104/16/Games104_16_72.png","/images/article/Games104/16/Games104_16_73.png","/images/article/Games104/16/Games104_16_74.png","/images/article/Games104/16/Games104_16_76.png","/images/article/Games104/16/Games104_16_78.png","/images/article/Games104/16/Games104_16_81.png","/images/article/Games104/16/Games104_16_82.png","/images/article/Games104/16/Games104_16_84.png","/images/article/Games104/16/Games104_16_86.png","/images/article/Games104/16/Games104_16_89.png"],"cover":"/images/background/Gameplay Systems Basic Artificial Intelligence.jpg","content":"<h2 id=\"AI课程大纲\"><a href=\"#AI课程大纲\" class=\"headerlink\" title=\"AI课程大纲\"></a>AI课程大纲</h2><p><img src=\"/images/article/Games104/16/Games104_16_01.png\"><span class=\"image-caption\">AI课程大纲</span></p>\n<h2 id=\"寻路系统（Navigation）\"><a href=\"#寻路系统（Navigation）\" class=\"headerlink\" title=\"寻路系统（Navigation）\"></a>寻路系统（Navigation）</h2><p>游戏AI是玩法系统重要的组成部分，其中最基本的功能是允许玩家选择目的地进行<b>导航(navigation)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_02.png\"><span class=\"image-caption\">游戏中导航</span></p>\n<p>导航算法需要考虑游戏地图的不同表达形式，然后寻找到从起点到目的地的最短路径，有时还需要结合一些其它算法来获得更加光滑的路线。<br><img src=\"/images/article/Games104/16/Games104_16_03.png\"><span class=\"image-caption\">导航步骤</span></p>\n<h3 id=\"地图制图表达（Map-Representation）\"><a href=\"#地图制图表达（Map-Representation）\" class=\"headerlink\" title=\"地图制图表达（Map Representation）\"></a>地图制图表达（Map Representation）</h3><p>因此我们首先需要考虑游戏中如何来表达地图，我们可以认为地图是玩家和NPC可以行动的区域。游戏中常见的地图形式包括路点<b>网络图(waypoint network)</b>、<b>网格(grid)</b>、<b>寻路网格(navigation mesh)</b>以及<b>八叉树(sparse voxel octree)</b>等<br><img src=\"/images/article/Games104/16/Games104_16_04.png\"><span class=\"image-caption\">地图表达-可走区域</span><br><img src=\"/images/article/Games104/16/Games104_16_05.png\"><span class=\"image-caption\">地图表达-格式</span></p>\n<h4 id=\"网络图（Waypoint-Network）\"><a href=\"#网络图（Waypoint-Network）\" class=\"headerlink\" title=\"网络图（Waypoint Network）\"></a>网络图（Waypoint Network）</h4><p>waypoint network是早期游戏中最常用的地图表示方式。我们可以把地图上的路标使用节点来表示，然后可通行的节点使用边来连接起来就形成了一个网络结构。<br><img src=\"/images/article/Games104/16/Games104_16_06.png\"><span class=\"image-caption\">航路点网络</span></p>\n<p>当玩家需要进行导航时只需要选择距离起点和目的地最近的两个路标，然后在网络图上进行导航即可。<br><img src=\"/images/article/Games104/16/Games104_16_07.png\"><span class=\"image-caption\">航路点网络2</span></p>\n<p>waypoint network的优势在于它非常易于实现，而且我们有成熟的路径搜索算法可以直接应用在网络图上；但它的缺陷在于路网图需要不断地和开发中的地图进行更新，而且使用路网进行导航时角色会倾向于沿路径中心前进而无法利用两边的通道。因此在现代游戏中路网的应用并不是很多。<br><img src=\"/images/article/Games104/16/Games104_16_08.png\"><span class=\"image-caption\">航路点网络3</span></p>\n<h4 id=\"网格（Grid）\"><a href=\"#网格（Grid）\" class=\"headerlink\" title=\"网格（Grid）\"></a>网格（Grid）</h4><p>网格同样是表达游戏地图的经典方法，常用的网格地图包括方格地图、三角形地图或是六边形地图等。<br><img src=\"/images/article/Games104/16/Games104_16_09.png\"><span class=\"image-caption\">网格</span></p>\n<p>使用网格来表示地图时只需要把不可通行的区域遮挡住就可以了，因此网格可以动态地反映地图环境的变化。<br><img src=\"/images/article/Games104/16/Games104_16_10.png\"><span class=\"image-caption\">网格2</span></p>\n<p>显然网格地图同样非常容易实现，而且支持动态更新，也便于调试；而它的缺陷在于网格地图的精度受制于地图分辨率，而且比较占用存储空间，最严重的问题是网格很难表示重叠区域之间的连接关系。<br><img src=\"/images/article/Games104/16/Games104_16_11.png\"><span class=\"image-caption\">网格3</span></p>\n<h4 id=\"寻路网格（Navigation-Mesh）\"><a href=\"#寻路网格（Navigation-Mesh）\" class=\"headerlink\" title=\"寻路网格（Navigation Mesh）\"></a>寻路网格（Navigation Mesh）</h4><p>为了克服网格地图的这些问题，人们开发出了寻路网格这样的地图表达形式。在寻路网格中可通行的区域会使用多边形来进行覆盖，这样可以方便地表达不同区域直接相互连接的拓扑关系。<br><img src=\"/images/article/Games104/16/Games104_16_12.png\"><span class=\"image-caption\">寻路网格</span><br><img src=\"/images/article/Games104/16/Games104_16_13.png\"><span class=\"image-caption\">寻路网格例子</span></p>\n<p>在寻路网格中我们还会要求每个多边形都必须是凸多边形，这样才能保证角色在行进中不会穿过网格。<br><img src=\"/images/article/Games104/16/Games104_16_14.png\"><span class=\"image-caption\">寻路网格多边形</span></p>\n<p>寻路网格是现代游戏中广泛应用的地图表达形式，而它的缺陷主要在于生成寻路网格的算法相对比较复杂，而且它无法表达三维空间的拓扑连接关系。<br><img src=\"/images/article/Games104/16/Games104_16_15.png\"><span class=\"image-caption\">寻路网格优点和缺点</span></p>\n<h4 id=\"八叉树（Sparse-Voxel-Octree）\"><a href=\"#八叉树（Sparse-Voxel-Octree）\" class=\"headerlink\" title=\"八叉树（Sparse Voxel Octree）\"></a>八叉树（Sparse Voxel Octree）</h4><p>如果要制作三维空间中的地图则可以考虑八叉树这样的数据结构。<br><img src=\"/images/article/Games104/16/Games104_16_16.png\"><span class=\"image-caption\">八叉树</span></p>\n<h3 id=\"寻路（Path-Finding）\"><a href=\"#寻路（Path-Finding）\" class=\"headerlink\" title=\"寻路（Path Finding）\"></a>寻路（Path Finding）</h3><p>得到游戏地图后就可以使用寻路算法来计算路径了，当然无论我们使用什么样的地图表达方式我们首先都需要把游戏地图转换为拓扑地图，然后再使用相应的算法进行寻路。<br><img src=\"/images/article/Games104/16/Games104_16_17.png\"><span class=\"image-caption\">寻路</span><br><img src=\"/images/article/Games104/16/Games104_16_18.png\"><span class=\"image-caption\">寻路2</span></p>\n<h4 id=\"深度优先搜索（Depth-First-Search）\"><a href=\"#深度优先搜索（Depth-First-Search）\" class=\"headerlink\" title=\"深度优先搜索（Depth-First Search）\"></a>深度优先搜索（Depth-First Search）</h4><p>寻路算法的本质是在图上进行搜索，因此我们可以使用<b>深度优先搜索(depth-first search, DFS)</b>来进行求解。<br><img src=\"/images/article/Games104/16/Games104_16_19.png\"><span class=\"image-caption\">深度优先搜索</span></p>\n<h4 id=\"广度优先搜索（Breadth-First-Search）\"><a href=\"#广度优先搜索（Breadth-First-Search）\" class=\"headerlink\" title=\"广度优先搜索（Breadth-First Search）\"></a>广度优先搜索（Breadth-First Search）</h4><p>另一种常用的图搜索算法是<b>广度优先搜索(breadth-first search, BSF)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_20.png\"><span class=\"image-caption\">广度优先搜索</span></p>\n<h4 id=\"Dijkstra算法（Dijkstra-Algorithm）\"><a href=\"#Dijkstra算法（Dijkstra-Algorithm）\" class=\"headerlink\" title=\"Dijkstra算法（Dijkstra Algorithm）\"></a>Dijkstra算法（Dijkstra Algorithm）</h4><p>直接使用DFS或是BFS往往是过于低效的，实践中更常用的寻路算法是<b>Dijkstra算法(Dijkstra algorithm)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_21.png\"><span class=\"image-caption\">Dijkstra算法</span><br><img src=\"/images/article/Games104/16/Games104_16_22.png\"><span class=\"image-caption\">Dijkstra算法2</span><br><img src=\"/images/article/Games104/16/Games104_16_23.png\"><span class=\"image-caption\">Dijkstra算法3</span></p>\n<h4 id=\"A-Star（A-）\"><a href=\"#A-Star（A-）\" class=\"headerlink\" title=\"A Star（A*）\"></a>A Star（A*）</h4><p>Dijkstra算法可以计算从起始节点出发到图上任意节点的最短路径，但它的缺陷在于图上很多节点对于我们想要计算的路径是没有意义的。因此人们还提出了A star算法来进行改进，在<b>A star</b>算法中通过引入一个启发式函数来控制节点访问的倾向性，使得路径的搜索会更倾向于访问目标点。<br><img src=\"/images/article/Games104/16/Games104_16_24.png\"><span class=\"image-caption\">A*</span><br><img src=\"/images/article/Games104/16/Games104_16_25.png\"><span class=\"image-caption\">A*-成本计算</span></p>\n<p>在网格地图中常用的启发函数包括Manhattan距离等。<br><img src=\"/images/article/Games104/16/Games104_16_26.png\"><span class=\"image-caption\">A*-网格上的启发</span></p>\n<p>而在寻路网格中则可以使用欧氏距离作为启发函数。<br><img src=\"/images/article/Games104/16/Games104_16_27.png\"><span class=\"image-caption\">A*-寻路网格上的启发</span><br><img src=\"/images/article/Games104/16/Games104_16_28.png\"><span class=\"image-caption\">A*-寻路网格上的启发2</span><br><img src=\"/images/article/Games104/16/Games104_16_29.png\"><span class=\"image-caption\">A*-寻路网格预排</span></p>\n<p>显然启发式算法的设计对于最终计算得到的路径会产生显著的影响。当启发函数的值过低时可能会需要更多次循环才能寻找到路径，而当启发函数值过高时则可能无法找到最短路径。因此在实际应用中需要进行一定的权衡。<br><img src=\"/images/article/Games104/16/Games104_16_30.png\"><span class=\"image-caption\">A*-启发</span></p>\n<h3 id=\"路径平滑（Path-Smoothing）\"><a href=\"#路径平滑（Path-Smoothing）\" class=\"headerlink\" title=\"路径平滑（Path Smoothing）\"></a>路径平滑（Path Smoothing）</h3><p>直接使用寻路算法得到的路径往往包含各种各样的折线不够光滑，因此我们还需要使用一些路径平滑的算法来获得更加光滑的路径。<br><img src=\"/images/article/Games104/16/Games104_16_31.png\"><span class=\"image-caption\">路径平滑</span></p>\n<p>游戏导航中比较常用funnel算法来对折线路径进行平滑，它不仅可以应用在二维平面上也可以应用在寻路网格上。<br><img src=\"/images/article/Games104/16/Games104_16_32.png\"><span class=\"image-caption\">路径平滑-漏斗算法</span><br><img src=\"/images/article/Games104/16/Games104_16_33.png\"><span class=\"image-caption\">路径平滑-漏斗算法2</span></p>\n<h3 id=\"导航网格生成（NavMesh-Generation）\"><a href=\"#导航网格生成（NavMesh-Generation）\" class=\"headerlink\" title=\"导航网格生成（NavMesh Generation）\"></a>导航网格生成（NavMesh Generation）</h3><p>如何从游戏地图上生成寻路网格是一个相对困难的问题。<br><img src=\"/images/article/Games104/16/Games104_16_34.png\"><span class=\"image-caption\">导航网格生成</span></p>\n<p>一般来说想要生成寻路网格首先需要将地图转换为体素，然后在体素地图上计算距离场得到区域的划分，最后就可以在划分好的区域中生成一个凸多边形网格作为寻路网格。<br><img src=\"/images/article/Games104/16/Games104_16_35.png\"><span class=\"image-caption\">导航网格生成-区域分割</span><br><img src=\"/images/article/Games104/16/Games104_16_36.png\"><span class=\"image-caption\">导航网格生成-区域分割2</span><br><img src=\"/images/article/Games104/16/Games104_16_37.png\"><span class=\"image-caption\">导航网格生成-区域分割3</span><br><img src=\"/images/article/Games104/16/Games104_16_38.png\"><span class=\"image-caption\">导航网格生成-区域分割4</span><br><img src=\"/images/article/Games104/16/Games104_16_39.png\"><span class=\"image-caption\">导航网格生成-网格生成</span></p>\n<p>除此之外我们还可以在多边形上设置不同的flag来触发不同的动画、声效以及粒子效果。<br><img src=\"/images/article/Games104/16/Games104_16_40.png\"><span class=\"image-caption\">导航网格高级特征-多边形标志</span></p>\n<p>对于动态的环境我们可以把巨大的场景地图划分为若干个tile。当某个tile中的环境发生改变时只需要重新计算该处的路径就可以得到新的路径。<br><img src=\"/images/article/Games104/16/Games104_16_41.png\"><span class=\"image-caption\">导航网格高级特征-瓦片</span></p>\n<p>还需要注意的是使用自动化算法生成的寻路网格是不包括传送点这样的信息的，有时为了提升玩家和场景的互动我们还需要手动设置这些传送点。当然这会导致寻路算法更加复杂。<br><img src=\"/images/article/Games104/16/Games104_16_42.png\"><span class=\"image-caption\">导航网格高级特征-非网格链接</span></p>\n<h2 id=\"转向系统（Steering）\"><a href=\"#转向系统（Steering）\" class=\"headerlink\" title=\"转向系统（Steering）\"></a>转向系统（Steering）</h2><p>得到最优路径后就可以根据路径来控制角色前进了。但在实际游戏中角色可能包含自身的运动学约束使得我们无法严格按照计算出的路径进行运动，这一点对于各种载具尤为明显。因此我们还需要结合<b>steering</b>算法来调整实际的行进路径。<br><img src=\"/images/article/Games104/16/Games104_16_43.png\"><span class=\"image-caption\">从路径到运动</span></p>\n<p>steering算法可以按照行为分为以下几种：<b>追赶和逃脱(seek/flee)</b>、<b>速度匹配(velocity match)</b>以及<b>对齐(align)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_44.png\"><span class=\"image-caption\">转向行为</span></p>\n<h3 id=\"躲避或巡逻（Seek-Flee）\"><a href=\"#躲避或巡逻（Seek-Flee）\" class=\"headerlink\" title=\"躲避或巡逻（Seek/Flee）\"></a>躲避或巡逻（Seek/Flee）</h3><p>seek/flee的要求是根据自身和目标当前的位置来调整自身的加速度从而实现追赶或是逃脱的行为，像游戏中的跟踪、躲避或是巡逻等行为都可以使用seek/flee来实现。<br><img src=\"/images/article/Games104/16/Games104_16_45.png\"><span class=\"image-caption\">躲避或巡逻</span><br><img src=\"/images/article/Games104/16/Games104_16_46.png\"><span class=\"image-caption\">躲避或巡逻变化</span></p>\n<h3 id=\"速度匹配（Velocity-Match）\"><a href=\"#速度匹配（Velocity-Match）\" class=\"headerlink\" title=\"速度匹配（Velocity Match）\"></a>速度匹配（Velocity Match）</h3><p>velocity match的目的是利用当前自身和目标的相对速度以及匹配时间来进行控制，使得自身可以按指定的速度到达目标位置。<br><img src=\"/images/article/Games104/16/Games104_16_47.png\"><span class=\"image-caption\">速度匹配</span></p>\n<h3 id=\"对齐（Align）\"><a href=\"#对齐（Align）\" class=\"headerlink\" title=\"对齐（Align）\"></a>对齐（Align）</h3><p>align则是从角度和角加速度的层面进行控制，使得自身的朝向可以接近目标。<br><img src=\"/images/article/Games104/16/Games104_16_48.png\"><span class=\"image-caption\">对齐</span></p>\n<h2 id=\"群体模拟（Crowd-Simulation）\"><a href=\"#群体模拟（Crowd-Simulation）\" class=\"headerlink\" title=\"群体模拟（Crowd Simulation）\"></a>群体模拟（Crowd Simulation）</h2><p><b>群体模拟(crowd simulation)</b>是游戏AI必须要处理的问题。在游戏场景中往往会具有大量的NPC，如何控制和模拟群体性的行为是现代游戏的一大挑战。<br><img src=\"/images/article/Games104/16/Games104_16_49.png\"><span class=\"image-caption\">群体</span></p>\n<p>游戏场景中群体模拟的先驱是Reynolds，他同时也是steering系统的提出者。目前游戏中群体行为模拟的方法主要可以分为三种：<b>微观模型(microscopic models)</b>、<b>宏观模型(macroscopic models)</b>以及<b>混合模型(mesoscopic models)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_50.png\"><span class=\"image-caption\">群体模拟模型</span></p>\n<h3 id=\"微观模型（Microscopic-Models）\"><a href=\"#微观模型（Microscopic-Models）\" class=\"headerlink\" title=\"微观模型（Microscopic Models）\"></a>微观模型（Microscopic Models）</h3><p>微观模型的思想是对群体中每一个个体进行控制从而模拟群体的行为，通常情况下我们可以设计一些规则来控制个体的行为。<br><img src=\"/images/article/Games104/16/Games104_16_51.png\"><span class=\"image-caption\">微观模型-基于规则的模型</span><br><img src=\"/images/article/Games104/16/Games104_16_52.png\"><span class=\"image-caption\">微观模型-基于规则的模型2</span></p>\n<h3 id=\"宏观模型（Macroscopic-Models）\"><a href=\"#宏观模型（Macroscopic-Models）\" class=\"headerlink\" title=\"宏观模型（Macroscopic Models）\"></a>宏观模型（Macroscopic Models）</h3><p>宏观模型的思想则是在场景中设计一个势场或流场来控制群体中每个个体的行为。<br><img src=\"/images/article/Games104/16/Games104_16_53.png\"><span class=\"image-caption\">宏观模型</span></p>\n<h3 id=\"混合模型（Mesoscopic-Models）\"><a href=\"#混合模型（Mesoscopic-Models）\" class=\"headerlink\" title=\"混合模型（Mesoscopic Models）\"></a>混合模型（Mesoscopic Models）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img src=\"/images/article/Games104/16/Games104_16_54.png\"><span class=\"image-caption\">混合模型</span></p>\n<h3 id=\"碰撞（Collision-Avoidance）\"><a href=\"#碰撞（Collision-Avoidance）\" class=\"headerlink\" title=\"碰撞（Collision Avoidance）\"></a>碰撞（Collision Avoidance）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img src=\"/images/article/Games104/16/Games104_16_55.png\"><span class=\"image-caption\">碰撞-基于力的模型</span><br><img src=\"/images/article/Games104/16/Games104_16_56.png\"><span class=\"image-caption\">碰撞-基于力的模型2</span></p>\n<p>另一种处理的方法是基于<b>速度障碍(velocity obstacle, VO)</b>来进行控制。<br><img src=\"/images/article/Games104/16/Games104_16_57.png\"><span class=\"image-caption\">碰撞-速度障碍</span></p>\n<p>VO的思想是当两个物体将要发生碰撞时相当于在速度域上形成了一定的障碍，因此需要调整自身的速度来避免相撞。<br><img src=\"/images/article/Games104/16/Games104_16_58.png\"><span class=\"image-caption\">速度障碍</span></p>\n<p>当参与避让的个体数比较多时还需要进行一些整体的优化，此时可以使用ORCA等算法进行处理。<br><img src=\"/images/article/Games104/16/Games104_16_59.png\"><span class=\"image-caption\">反向速度障碍</span></p>\n<h2 id=\"感知（Sensing）\"><a href=\"#感知（Sensing）\" class=\"headerlink\" title=\"感知（Sensing）\"></a>感知（Sensing）</h2><p><b>感知(sensing)</b>是游戏AI的基础，根据获得信息的不同我们可以把感知的内容分为<b>内部信息(internal information)</b>和<b>外部信息(external information)</b>。<br><img src=\"/images/article/Games104/16/Games104_16_60.png\"><span class=\"image-caption\">感测或感知</span></p>\n<p>内部信息包括AI自身的位置、HP以及各种状态。这些信息一般可以被AI直接访问到，而且它们是AI进行决策的基础。<br><img src=\"/images/article/Games104/16/Games104_16_61.png\"><span class=\"image-caption\">内部信息</span></p>\n<p>而外部信息则主要包括AI所处的场景中的信息，它会随着游戏进程和场景变化而发生改变。<br><img src=\"/images/article/Games104/16/Games104_16_62.png\"><span class=\"image-caption\">静态空间信息</span></p>\n<p>外部信息的一种常用表达方式是influence map，场景的变化会直接反映在<b>influence map</b>上。当AI需要进行决策时会同时考虑自身的状态并且查询当前的influence map来选择自身的行为。<br><img src=\"/images/article/Games104/16/Games104_16_63.png\"><span class=\"image-caption\">动态空间信息-影响图</span><br><img src=\"/images/article/Games104/16/Games104_16_64.png\"><span class=\"image-caption\">动态空间信息-游戏对象</span></p>\n<p>游戏AI进行感知时还需要注意我们不能假设AI可以直接获得所有游戏的信息，而是希望AI能够像玩家一样只利用局部感知的信息来进行决策。<br><img src=\"/images/article/Games104/16/Games104_16_65.png\"><span class=\"image-caption\">传感仿真</span></p>\n<h2 id=\"经典决策算法（Classic-Decision-Making-Algorithms）\"><a href=\"#经典决策算法（Classic-Decision-Making-Algorithms）\" class=\"headerlink\" title=\"经典决策算法（Classic Decision Making Algorithms）\"></a>经典决策算法（Classic Decision Making Algorithms）</h2><p>在上面这些知识的基础上就可以开始构建游戏AI系统了。游戏AI算法的核心是<b>决策(decision making)</b>系统，经典的决策系统包括<b>有限状态机(finite state machine, FSM)</b>和<b>行为树(behavior tree, BT)</b>两种。<br><img src=\"/images/article/Games104/16/Games104_16_66.png\"><span class=\"image-caption\">决策算法</span></p>\n<h3 id=\"有限状态机（Finite-State-Machine）\"><a href=\"#有限状态机（Finite-State-Machine）\" class=\"headerlink\" title=\"有限状态机（Finite State Machine）\"></a>有限状态机（Finite State Machine）</h3><p>在有限状态机模型中我们认为AI的行为可以建模为在不同状态之间的游走，不同状态之间的切换称为<b>转移(transition)</b>。以吃豆人游戏为例，游戏AI可以使用一个包含3个状态的状态机来表示。<br><img src=\"/images/article/Games104/16/Games104_16_67.png\"><span class=\"image-caption\">有限状态机</span><br><img src=\"/images/article/Games104/16/Games104_16_68.png\"><span class=\"image-caption\">有限状态机2</span></p>\n<p>有限状态机的缺陷在于现代游戏中AI的状态空间可能是非常巨大的，因此状态之间的转移会无比复杂。<br><img src=\"/images/article/Games104/16/Games104_16_69.png\"><span class=\"image-caption\">有限状态机-利弊</span></p>\n<p>为了克服有限状态机过于复杂的问题，人们还提出了<b>hierarchical finite state machine(HFSM)</b>这样的模型。在HFSM中我们把整个复杂的状态机分为若干层，不同层之间通过有向的接口进行连接，这样可以增加模型的可读性。<br><img src=\"/images/article/Games104/16/Games104_16_70.png\"><span class=\"image-caption\">分层有限状态机</span></p>\n<h3 id=\"行为树（Behavior-Tree）\"><a href=\"#行为树（Behavior-Tree）\" class=\"headerlink\" title=\"行为树（Behavior Tree）\"></a>行为树（Behavior Tree）</h3><p>在现代游戏中更为常用的决策算法是行为树，它的决策行为更接近人脑的决策过程。<br><img src=\"/images/article/Games104/16/Games104_16_71.png\"><span class=\"image-caption\">行为树</span></p>\n<p>行为树中的<b>执行节点(excution node)</b>表示AI执行的过程，它包括条件判断以及具体执行的动作两种节点。<br><img src=\"/images/article/Games104/16/Games104_16_72.png\"><span class=\"image-caption\">行为树-执行节点</span></p>\n<p>行为树中的另一种节点是<b>控制节点(control node)</b>，它用来表示决策过程的控制流。control node包括sequence、selector、parallel以及decorator等几种。<br><img src=\"/images/article/Games104/16/Games104_16_73.png\"><span class=\"image-caption\">行为树-控制节点</span></p>\n<p><b>sequence</b>是表示对当前节点的子节点依次进行访问和执行，一般可以用来表示AI在当前状态下的行为计划。<br><img src=\"/images/article/Games104/16/Games104_16_74.png\"><span class=\"image-caption\">控制节点-序列</span><br><img src=\"/images/article/Games104/16/Games104_16_75.png\"><span class=\"image-caption\">控制节点-序列2</span></p>\n<p><b>selector</b>同样会遍历当前节点的子节点，但不同于sequence的地方是如果某个子节点返回True则会终止遍历。<br><img src=\"/images/article/Games104/16/Games104_16_76.png\"><span class=\"image-caption\">控制节点-选择器</span><br><img src=\"/images/article/Games104/16/Games104_16_77.png\"><span class=\"image-caption\">控制节点-选择器2</span></p>\n<p><b>parallel</b>会同时执行当前节点下的所有子节点。<br><img src=\"/images/article/Games104/16/Games104_16_78.png\"><span class=\"image-caption\">控制节点-并行</span><br><img src=\"/images/article/Games104/16/Games104_16_79.png\"><span class=\"image-caption\">控制节点-并行2</span><br><img src=\"/images/article/Games104/16/Games104_16_80.png\"><span class=\"image-caption\">行为树</span></p>\n<p>行为树在进行执行时需要注意每一次执行时都需要返回根节点。<br><img src=\"/images/article/Games104/16/Games104_16_81.png\"><span class=\"image-caption\">执行行为树</span></p>\n<p>在现代游戏中还提出了<b>decorator</b>节点来丰富可以执行的行为。<br><img src=\"/images/article/Games104/16/Games104_16_82.png\"><span class=\"image-caption\">行为树-装饰器</span><br><img src=\"/images/article/Games104/16/Games104_16_83.png\"><span class=\"image-caption\">行为树-装饰器2</span></p>\n<p>我们还可以使用<b>precondition</b>和<b>blackborad</b>来提升决策过程的可读性。<br><img src=\"/images/article/Games104/16/Games104_16_84.png\"><span class=\"image-caption\">行为树-先决条件</span><br><img src=\"/images/article/Games104/16/Games104_16_85.png\"><span class=\"image-caption\">行为树-黑板</span></p>\n<p>行为树的决策过程非常符合人的决策行为而且也易于调试，因此广泛应用在各种游戏AI中。当然行为树也有一些缺点，比如说每次调用时都必须从根节点出发重新执行，这样的效率是比较低的。<br><img src=\"/images/article/Games104/16/Games104_16_86.png\"><span class=\"image-caption\">行为树-优点</span><br><img src=\"/images/article/Games104/16/Games104_16_87.png\"><span class=\"image-caption\">行为树-优点2</span><br><img src=\"/images/article/Games104/16/Games104_16_88.png\"><span class=\"image-caption\">行为树-缺点</span></p>\n<p>目前随着AI技术的发展，游戏AI也开始使用一些<b>规划(planning)</b>算法来进行决策。这些更先进的算法我们会在后面的课程进行介绍。<br><img src=\"/images/article/Games104/16/Games104_16_89.png\"><span class=\"image-caption\">即将到来的目标是：人工智能规划和目标</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/07/26/GAMES104-NOTES-16.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV19N4y1T7eU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7a2542c6c909b3ee1fab551277360826\">课程视频</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1r34y1J7Sg/?spm_id_from=333.788&amp;vd_source=7a2542c6c909b3ee1fab551277360826\">课程视频2</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture16_GameplaySystemsBasicArtificialIntelligence.pdf\">课件PPT</a></p>\n","more":"<h2 id=\"AI课程大纲\"><a href=\"#AI课程大纲\" class=\"headerlink\" title=\"AI课程大纲\"></a>AI课程大纲</h2><p><img  src=\"/images/article/Games104/16/Games104_16_01.png\"  ><span class=\"image-caption\">AI课程大纲</span></p>\n<h2 id=\"寻路系统（Navigation）\"><a href=\"#寻路系统（Navigation）\" class=\"headerlink\" title=\"寻路系统（Navigation）\"></a>寻路系统（Navigation）</h2><p>游戏AI是玩法系统重要的组成部分，其中最基本的功能是允许玩家选择目的地进行<b>导航(navigation)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_02.png\"  ><span class=\"image-caption\">游戏中导航</span></p>\n<p>导航算法需要考虑游戏地图的不同表达形式，然后寻找到从起点到目的地的最短路径，有时还需要结合一些其它算法来获得更加光滑的路线。<br><img  src=\"/images/article/Games104/16/Games104_16_03.png\"  ><span class=\"image-caption\">导航步骤</span></p>\n<h3 id=\"地图制图表达（Map-Representation）\"><a href=\"#地图制图表达（Map-Representation）\" class=\"headerlink\" title=\"地图制图表达（Map Representation）\"></a>地图制图表达（Map Representation）</h3><p>因此我们首先需要考虑游戏中如何来表达地图，我们可以认为地图是玩家和NPC可以行动的区域。游戏中常见的地图形式包括路点<b>网络图(waypoint network)</b>、<b>网格(grid)</b>、<b>寻路网格(navigation mesh)</b>以及<b>八叉树(sparse voxel octree)</b>等<br><img  src=\"/images/article/Games104/16/Games104_16_04.png\"  ><span class=\"image-caption\">地图表达-可走区域</span><br><img  src=\"/images/article/Games104/16/Games104_16_05.png\"  ><span class=\"image-caption\">地图表达-格式</span></p>\n<h4 id=\"网络图（Waypoint-Network）\"><a href=\"#网络图（Waypoint-Network）\" class=\"headerlink\" title=\"网络图（Waypoint Network）\"></a>网络图（Waypoint Network）</h4><p>waypoint network是早期游戏中最常用的地图表示方式。我们可以把地图上的路标使用节点来表示，然后可通行的节点使用边来连接起来就形成了一个网络结构。<br><img  src=\"/images/article/Games104/16/Games104_16_06.png\"  ><span class=\"image-caption\">航路点网络</span></p>\n<p>当玩家需要进行导航时只需要选择距离起点和目的地最近的两个路标，然后在网络图上进行导航即可。<br><img  src=\"/images/article/Games104/16/Games104_16_07.png\"  ><span class=\"image-caption\">航路点网络2</span></p>\n<p>waypoint network的优势在于它非常易于实现，而且我们有成熟的路径搜索算法可以直接应用在网络图上；但它的缺陷在于路网图需要不断地和开发中的地图进行更新，而且使用路网进行导航时角色会倾向于沿路径中心前进而无法利用两边的通道。因此在现代游戏中路网的应用并不是很多。<br><img  src=\"/images/article/Games104/16/Games104_16_08.png\"  ><span class=\"image-caption\">航路点网络3</span></p>\n<h4 id=\"网格（Grid）\"><a href=\"#网格（Grid）\" class=\"headerlink\" title=\"网格（Grid）\"></a>网格（Grid）</h4><p>网格同样是表达游戏地图的经典方法，常用的网格地图包括方格地图、三角形地图或是六边形地图等。<br><img  src=\"/images/article/Games104/16/Games104_16_09.png\"  ><span class=\"image-caption\">网格</span></p>\n<p>使用网格来表示地图时只需要把不可通行的区域遮挡住就可以了，因此网格可以动态地反映地图环境的变化。<br><img  src=\"/images/article/Games104/16/Games104_16_10.png\"  ><span class=\"image-caption\">网格2</span></p>\n<p>显然网格地图同样非常容易实现，而且支持动态更新，也便于调试；而它的缺陷在于网格地图的精度受制于地图分辨率，而且比较占用存储空间，最严重的问题是网格很难表示重叠区域之间的连接关系。<br><img  src=\"/images/article/Games104/16/Games104_16_11.png\"  ><span class=\"image-caption\">网格3</span></p>\n<h4 id=\"寻路网格（Navigation-Mesh）\"><a href=\"#寻路网格（Navigation-Mesh）\" class=\"headerlink\" title=\"寻路网格（Navigation Mesh）\"></a>寻路网格（Navigation Mesh）</h4><p>为了克服网格地图的这些问题，人们开发出了寻路网格这样的地图表达形式。在寻路网格中可通行的区域会使用多边形来进行覆盖，这样可以方便地表达不同区域直接相互连接的拓扑关系。<br><img  src=\"/images/article/Games104/16/Games104_16_12.png\"  ><span class=\"image-caption\">寻路网格</span><br><img  src=\"/images/article/Games104/16/Games104_16_13.png\"  ><span class=\"image-caption\">寻路网格例子</span></p>\n<p>在寻路网格中我们还会要求每个多边形都必须是凸多边形，这样才能保证角色在行进中不会穿过网格。<br><img  src=\"/images/article/Games104/16/Games104_16_14.png\"  ><span class=\"image-caption\">寻路网格多边形</span></p>\n<p>寻路网格是现代游戏中广泛应用的地图表达形式，而它的缺陷主要在于生成寻路网格的算法相对比较复杂，而且它无法表达三维空间的拓扑连接关系。<br><img  src=\"/images/article/Games104/16/Games104_16_15.png\"  ><span class=\"image-caption\">寻路网格优点和缺点</span></p>\n<h4 id=\"八叉树（Sparse-Voxel-Octree）\"><a href=\"#八叉树（Sparse-Voxel-Octree）\" class=\"headerlink\" title=\"八叉树（Sparse Voxel Octree）\"></a>八叉树（Sparse Voxel Octree）</h4><p>如果要制作三维空间中的地图则可以考虑八叉树这样的数据结构。<br><img  src=\"/images/article/Games104/16/Games104_16_16.png\"  ><span class=\"image-caption\">八叉树</span></p>\n<h3 id=\"寻路（Path-Finding）\"><a href=\"#寻路（Path-Finding）\" class=\"headerlink\" title=\"寻路（Path Finding）\"></a>寻路（Path Finding）</h3><p>得到游戏地图后就可以使用寻路算法来计算路径了，当然无论我们使用什么样的地图表达方式我们首先都需要把游戏地图转换为拓扑地图，然后再使用相应的算法进行寻路。<br><img  src=\"/images/article/Games104/16/Games104_16_17.png\"  ><span class=\"image-caption\">寻路</span><br><img  src=\"/images/article/Games104/16/Games104_16_18.png\"  ><span class=\"image-caption\">寻路2</span></p>\n<h4 id=\"深度优先搜索（Depth-First-Search）\"><a href=\"#深度优先搜索（Depth-First-Search）\" class=\"headerlink\" title=\"深度优先搜索（Depth-First Search）\"></a>深度优先搜索（Depth-First Search）</h4><p>寻路算法的本质是在图上进行搜索，因此我们可以使用<b>深度优先搜索(depth-first search, DFS)</b>来进行求解。<br><img  src=\"/images/article/Games104/16/Games104_16_19.png\"  ><span class=\"image-caption\">深度优先搜索</span></p>\n<h4 id=\"广度优先搜索（Breadth-First-Search）\"><a href=\"#广度优先搜索（Breadth-First-Search）\" class=\"headerlink\" title=\"广度优先搜索（Breadth-First Search）\"></a>广度优先搜索（Breadth-First Search）</h4><p>另一种常用的图搜索算法是<b>广度优先搜索(breadth-first search, BSF)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_20.png\"  ><span class=\"image-caption\">广度优先搜索</span></p>\n<h4 id=\"Dijkstra算法（Dijkstra-Algorithm）\"><a href=\"#Dijkstra算法（Dijkstra-Algorithm）\" class=\"headerlink\" title=\"Dijkstra算法（Dijkstra Algorithm）\"></a>Dijkstra算法（Dijkstra Algorithm）</h4><p>直接使用DFS或是BFS往往是过于低效的，实践中更常用的寻路算法是<b>Dijkstra算法(Dijkstra algorithm)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_21.png\"  ><span class=\"image-caption\">Dijkstra算法</span><br><img  src=\"/images/article/Games104/16/Games104_16_22.png\"  ><span class=\"image-caption\">Dijkstra算法2</span><br><img  src=\"/images/article/Games104/16/Games104_16_23.png\"  ><span class=\"image-caption\">Dijkstra算法3</span></p>\n<h4 id=\"A-Star（A-）\"><a href=\"#A-Star（A-）\" class=\"headerlink\" title=\"A Star（A*）\"></a>A Star（A*）</h4><p>Dijkstra算法可以计算从起始节点出发到图上任意节点的最短路径，但它的缺陷在于图上很多节点对于我们想要计算的路径是没有意义的。因此人们还提出了A star算法来进行改进，在<b>A star</b>算法中通过引入一个启发式函数来控制节点访问的倾向性，使得路径的搜索会更倾向于访问目标点。<br><img  src=\"/images/article/Games104/16/Games104_16_24.png\"  ><span class=\"image-caption\">A*</span><br><img  src=\"/images/article/Games104/16/Games104_16_25.png\"  ><span class=\"image-caption\">A*-成本计算</span></p>\n<p>在网格地图中常用的启发函数包括Manhattan距离等。<br><img  src=\"/images/article/Games104/16/Games104_16_26.png\"  ><span class=\"image-caption\">A*-网格上的启发</span></p>\n<p>而在寻路网格中则可以使用欧氏距离作为启发函数。<br><img  src=\"/images/article/Games104/16/Games104_16_27.png\"  ><span class=\"image-caption\">A*-寻路网格上的启发</span><br><img  src=\"/images/article/Games104/16/Games104_16_28.png\"  ><span class=\"image-caption\">A*-寻路网格上的启发2</span><br><img  src=\"/images/article/Games104/16/Games104_16_29.png\"  ><span class=\"image-caption\">A*-寻路网格预排</span></p>\n<p>显然启发式算法的设计对于最终计算得到的路径会产生显著的影响。当启发函数的值过低时可能会需要更多次循环才能寻找到路径，而当启发函数值过高时则可能无法找到最短路径。因此在实际应用中需要进行一定的权衡。<br><img  src=\"/images/article/Games104/16/Games104_16_30.png\"  ><span class=\"image-caption\">A*-启发</span></p>\n<h3 id=\"路径平滑（Path-Smoothing）\"><a href=\"#路径平滑（Path-Smoothing）\" class=\"headerlink\" title=\"路径平滑（Path Smoothing）\"></a>路径平滑（Path Smoothing）</h3><p>直接使用寻路算法得到的路径往往包含各种各样的折线不够光滑，因此我们还需要使用一些路径平滑的算法来获得更加光滑的路径。<br><img  src=\"/images/article/Games104/16/Games104_16_31.png\"  ><span class=\"image-caption\">路径平滑</span></p>\n<p>游戏导航中比较常用funnel算法来对折线路径进行平滑，它不仅可以应用在二维平面上也可以应用在寻路网格上。<br><img  src=\"/images/article/Games104/16/Games104_16_32.png\"  ><span class=\"image-caption\">路径平滑-漏斗算法</span><br><img  src=\"/images/article/Games104/16/Games104_16_33.png\"  ><span class=\"image-caption\">路径平滑-漏斗算法2</span></p>\n<h3 id=\"导航网格生成（NavMesh-Generation）\"><a href=\"#导航网格生成（NavMesh-Generation）\" class=\"headerlink\" title=\"导航网格生成（NavMesh Generation）\"></a>导航网格生成（NavMesh Generation）</h3><p>如何从游戏地图上生成寻路网格是一个相对困难的问题。<br><img  src=\"/images/article/Games104/16/Games104_16_34.png\"  ><span class=\"image-caption\">导航网格生成</span></p>\n<p>一般来说想要生成寻路网格首先需要将地图转换为体素，然后在体素地图上计算距离场得到区域的划分，最后就可以在划分好的区域中生成一个凸多边形网格作为寻路网格。<br><img  src=\"/images/article/Games104/16/Games104_16_35.png\"  ><span class=\"image-caption\">导航网格生成-区域分割</span><br><img  src=\"/images/article/Games104/16/Games104_16_36.png\"  ><span class=\"image-caption\">导航网格生成-区域分割2</span><br><img  src=\"/images/article/Games104/16/Games104_16_37.png\"  ><span class=\"image-caption\">导航网格生成-区域分割3</span><br><img  src=\"/images/article/Games104/16/Games104_16_38.png\"  ><span class=\"image-caption\">导航网格生成-区域分割4</span><br><img  src=\"/images/article/Games104/16/Games104_16_39.png\"  ><span class=\"image-caption\">导航网格生成-网格生成</span></p>\n<p>除此之外我们还可以在多边形上设置不同的flag来触发不同的动画、声效以及粒子效果。<br><img  src=\"/images/article/Games104/16/Games104_16_40.png\"  ><span class=\"image-caption\">导航网格高级特征-多边形标志</span></p>\n<p>对于动态的环境我们可以把巨大的场景地图划分为若干个tile。当某个tile中的环境发生改变时只需要重新计算该处的路径就可以得到新的路径。<br><img  src=\"/images/article/Games104/16/Games104_16_41.png\"  ><span class=\"image-caption\">导航网格高级特征-瓦片</span></p>\n<p>还需要注意的是使用自动化算法生成的寻路网格是不包括传送点这样的信息的，有时为了提升玩家和场景的互动我们还需要手动设置这些传送点。当然这会导致寻路算法更加复杂。<br><img  src=\"/images/article/Games104/16/Games104_16_42.png\"  ><span class=\"image-caption\">导航网格高级特征-非网格链接</span></p>\n<h2 id=\"转向系统（Steering）\"><a href=\"#转向系统（Steering）\" class=\"headerlink\" title=\"转向系统（Steering）\"></a>转向系统（Steering）</h2><p>得到最优路径后就可以根据路径来控制角色前进了。但在实际游戏中角色可能包含自身的运动学约束使得我们无法严格按照计算出的路径进行运动，这一点对于各种载具尤为明显。因此我们还需要结合<b>steering</b>算法来调整实际的行进路径。<br><img  src=\"/images/article/Games104/16/Games104_16_43.png\"  ><span class=\"image-caption\">从路径到运动</span></p>\n<p>steering算法可以按照行为分为以下几种：<b>追赶和逃脱(seek&#x2F;flee)</b>、<b>速度匹配(velocity match)</b>以及<b>对齐(align)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_44.png\"  ><span class=\"image-caption\">转向行为</span></p>\n<h3 id=\"躲避或巡逻（Seek-Flee）\"><a href=\"#躲避或巡逻（Seek-Flee）\" class=\"headerlink\" title=\"躲避或巡逻（Seek&#x2F;Flee）\"></a>躲避或巡逻（Seek&#x2F;Flee）</h3><p>seek&#x2F;flee的要求是根据自身和目标当前的位置来调整自身的加速度从而实现追赶或是逃脱的行为，像游戏中的跟踪、躲避或是巡逻等行为都可以使用seek&#x2F;flee来实现。<br><img  src=\"/images/article/Games104/16/Games104_16_45.png\"  ><span class=\"image-caption\">躲避或巡逻</span><br><img  src=\"/images/article/Games104/16/Games104_16_46.png\"  ><span class=\"image-caption\">躲避或巡逻变化</span></p>\n<h3 id=\"速度匹配（Velocity-Match）\"><a href=\"#速度匹配（Velocity-Match）\" class=\"headerlink\" title=\"速度匹配（Velocity Match）\"></a>速度匹配（Velocity Match）</h3><p>velocity match的目的是利用当前自身和目标的相对速度以及匹配时间来进行控制，使得自身可以按指定的速度到达目标位置。<br><img  src=\"/images/article/Games104/16/Games104_16_47.png\"  ><span class=\"image-caption\">速度匹配</span></p>\n<h3 id=\"对齐（Align）\"><a href=\"#对齐（Align）\" class=\"headerlink\" title=\"对齐（Align）\"></a>对齐（Align）</h3><p>align则是从角度和角加速度的层面进行控制，使得自身的朝向可以接近目标。<br><img  src=\"/images/article/Games104/16/Games104_16_48.png\"  ><span class=\"image-caption\">对齐</span></p>\n<h2 id=\"群体模拟（Crowd-Simulation）\"><a href=\"#群体模拟（Crowd-Simulation）\" class=\"headerlink\" title=\"群体模拟（Crowd Simulation）\"></a>群体模拟（Crowd Simulation）</h2><p><b>群体模拟(crowd simulation)</b>是游戏AI必须要处理的问题。在游戏场景中往往会具有大量的NPC，如何控制和模拟群体性的行为是现代游戏的一大挑战。<br><img  src=\"/images/article/Games104/16/Games104_16_49.png\"  ><span class=\"image-caption\">群体</span></p>\n<p>游戏场景中群体模拟的先驱是Reynolds，他同时也是steering系统的提出者。目前游戏中群体行为模拟的方法主要可以分为三种：<b>微观模型(microscopic models)</b>、<b>宏观模型(macroscopic models)</b>以及<b>混合模型(mesoscopic models)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_50.png\"  ><span class=\"image-caption\">群体模拟模型</span></p>\n<h3 id=\"微观模型（Microscopic-Models）\"><a href=\"#微观模型（Microscopic-Models）\" class=\"headerlink\" title=\"微观模型（Microscopic Models）\"></a>微观模型（Microscopic Models）</h3><p>微观模型的思想是对群体中每一个个体进行控制从而模拟群体的行为，通常情况下我们可以设计一些规则来控制个体的行为。<br><img  src=\"/images/article/Games104/16/Games104_16_51.png\"  ><span class=\"image-caption\">微观模型-基于规则的模型</span><br><img  src=\"/images/article/Games104/16/Games104_16_52.png\"  ><span class=\"image-caption\">微观模型-基于规则的模型2</span></p>\n<h3 id=\"宏观模型（Macroscopic-Models）\"><a href=\"#宏观模型（Macroscopic-Models）\" class=\"headerlink\" title=\"宏观模型（Macroscopic Models）\"></a>宏观模型（Macroscopic Models）</h3><p>宏观模型的思想则是在场景中设计一个势场或流场来控制群体中每个个体的行为。<br><img  src=\"/images/article/Games104/16/Games104_16_53.png\"  ><span class=\"image-caption\">宏观模型</span></p>\n<h3 id=\"混合模型（Mesoscopic-Models）\"><a href=\"#混合模型（Mesoscopic-Models）\" class=\"headerlink\" title=\"混合模型（Mesoscopic Models）\"></a>混合模型（Mesoscopic Models）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img  src=\"/images/article/Games104/16/Games104_16_54.png\"  ><span class=\"image-caption\">混合模型</span></p>\n<h3 id=\"碰撞（Collision-Avoidance）\"><a href=\"#碰撞（Collision-Avoidance）\" class=\"headerlink\" title=\"碰撞（Collision Avoidance）\"></a>碰撞（Collision Avoidance）</h3><p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种RTS游戏中有着广泛的应用。<br><img  src=\"/images/article/Games104/16/Games104_16_55.png\"  ><span class=\"image-caption\">碰撞-基于力的模型</span><br><img  src=\"/images/article/Games104/16/Games104_16_56.png\"  ><span class=\"image-caption\">碰撞-基于力的模型2</span></p>\n<p>另一种处理的方法是基于<b>速度障碍(velocity obstacle, VO)</b>来进行控制。<br><img  src=\"/images/article/Games104/16/Games104_16_57.png\"  ><span class=\"image-caption\">碰撞-速度障碍</span></p>\n<p>VO的思想是当两个物体将要发生碰撞时相当于在速度域上形成了一定的障碍，因此需要调整自身的速度来避免相撞。<br><img  src=\"/images/article/Games104/16/Games104_16_58.png\"  ><span class=\"image-caption\">速度障碍</span></p>\n<p>当参与避让的个体数比较多时还需要进行一些整体的优化，此时可以使用ORCA等算法进行处理。<br><img  src=\"/images/article/Games104/16/Games104_16_59.png\"  ><span class=\"image-caption\">反向速度障碍</span></p>\n<h2 id=\"感知（Sensing）\"><a href=\"#感知（Sensing）\" class=\"headerlink\" title=\"感知（Sensing）\"></a>感知（Sensing）</h2><p><b>感知(sensing)</b>是游戏AI的基础，根据获得信息的不同我们可以把感知的内容分为<b>内部信息(internal information)</b>和<b>外部信息(external information)</b>。<br><img  src=\"/images/article/Games104/16/Games104_16_60.png\"  ><span class=\"image-caption\">感测或感知</span></p>\n<p>内部信息包括AI自身的位置、HP以及各种状态。这些信息一般可以被AI直接访问到，而且它们是AI进行决策的基础。<br><img  src=\"/images/article/Games104/16/Games104_16_61.png\"  ><span class=\"image-caption\">内部信息</span></p>\n<p>而外部信息则主要包括AI所处的场景中的信息，它会随着游戏进程和场景变化而发生改变。<br><img  src=\"/images/article/Games104/16/Games104_16_62.png\"  ><span class=\"image-caption\">静态空间信息</span></p>\n<p>外部信息的一种常用表达方式是influence map，场景的变化会直接反映在<b>influence map</b>上。当AI需要进行决策时会同时考虑自身的状态并且查询当前的influence map来选择自身的行为。<br><img  src=\"/images/article/Games104/16/Games104_16_63.png\"  ><span class=\"image-caption\">动态空间信息-影响图</span><br><img  src=\"/images/article/Games104/16/Games104_16_64.png\"  ><span class=\"image-caption\">动态空间信息-游戏对象</span></p>\n<p>游戏AI进行感知时还需要注意我们不能假设AI可以直接获得所有游戏的信息，而是希望AI能够像玩家一样只利用局部感知的信息来进行决策。<br><img  src=\"/images/article/Games104/16/Games104_16_65.png\"  ><span class=\"image-caption\">传感仿真</span></p>\n<h2 id=\"经典决策算法（Classic-Decision-Making-Algorithms）\"><a href=\"#经典决策算法（Classic-Decision-Making-Algorithms）\" class=\"headerlink\" title=\"经典决策算法（Classic Decision Making Algorithms）\"></a>经典决策算法（Classic Decision Making Algorithms）</h2><p>在上面这些知识的基础上就可以开始构建游戏AI系统了。游戏AI算法的核心是<b>决策(decision making)</b>系统，经典的决策系统包括<b>有限状态机(finite state machine, FSM)</b>和<b>行为树(behavior tree, BT)</b>两种。<br><img  src=\"/images/article/Games104/16/Games104_16_66.png\"  ><span class=\"image-caption\">决策算法</span></p>\n<h3 id=\"有限状态机（Finite-State-Machine）\"><a href=\"#有限状态机（Finite-State-Machine）\" class=\"headerlink\" title=\"有限状态机（Finite State Machine）\"></a>有限状态机（Finite State Machine）</h3><p>在有限状态机模型中我们认为AI的行为可以建模为在不同状态之间的游走，不同状态之间的切换称为<b>转移(transition)</b>。以吃豆人游戏为例，游戏AI可以使用一个包含3个状态的状态机来表示。<br><img  src=\"/images/article/Games104/16/Games104_16_67.png\"  ><span class=\"image-caption\">有限状态机</span><br><img  src=\"/images/article/Games104/16/Games104_16_68.png\"  ><span class=\"image-caption\">有限状态机2</span></p>\n<p>有限状态机的缺陷在于现代游戏中AI的状态空间可能是非常巨大的，因此状态之间的转移会无比复杂。<br><img  src=\"/images/article/Games104/16/Games104_16_69.png\"  ><span class=\"image-caption\">有限状态机-利弊</span></p>\n<p>为了克服有限状态机过于复杂的问题，人们还提出了<b>hierarchical finite state machine(HFSM)</b>这样的模型。在HFSM中我们把整个复杂的状态机分为若干层，不同层之间通过有向的接口进行连接，这样可以增加模型的可读性。<br><img  src=\"/images/article/Games104/16/Games104_16_70.png\"  ><span class=\"image-caption\">分层有限状态机</span></p>\n<h3 id=\"行为树（Behavior-Tree）\"><a href=\"#行为树（Behavior-Tree）\" class=\"headerlink\" title=\"行为树（Behavior Tree）\"></a>行为树（Behavior Tree）</h3><p>在现代游戏中更为常用的决策算法是行为树，它的决策行为更接近人脑的决策过程。<br><img  src=\"/images/article/Games104/16/Games104_16_71.png\"  ><span class=\"image-caption\">行为树</span></p>\n<p>行为树中的<b>执行节点(excution node)</b>表示AI执行的过程，它包括条件判断以及具体执行的动作两种节点。<br><img  src=\"/images/article/Games104/16/Games104_16_72.png\"  ><span class=\"image-caption\">行为树-执行节点</span></p>\n<p>行为树中的另一种节点是<b>控制节点(control node)</b>，它用来表示决策过程的控制流。control node包括sequence、selector、parallel以及decorator等几种。<br><img  src=\"/images/article/Games104/16/Games104_16_73.png\"  ><span class=\"image-caption\">行为树-控制节点</span></p>\n<p><b>sequence</b>是表示对当前节点的子节点依次进行访问和执行，一般可以用来表示AI在当前状态下的行为计划。<br><img  src=\"/images/article/Games104/16/Games104_16_74.png\"  ><span class=\"image-caption\">控制节点-序列</span><br><img  src=\"/images/article/Games104/16/Games104_16_75.png\"  ><span class=\"image-caption\">控制节点-序列2</span></p>\n<p><b>selector</b>同样会遍历当前节点的子节点，但不同于sequence的地方是如果某个子节点返回True则会终止遍历。<br><img  src=\"/images/article/Games104/16/Games104_16_76.png\"  ><span class=\"image-caption\">控制节点-选择器</span><br><img  src=\"/images/article/Games104/16/Games104_16_77.png\"  ><span class=\"image-caption\">控制节点-选择器2</span></p>\n<p><b>parallel</b>会同时执行当前节点下的所有子节点。<br><img  src=\"/images/article/Games104/16/Games104_16_78.png\"  ><span class=\"image-caption\">控制节点-并行</span><br><img  src=\"/images/article/Games104/16/Games104_16_79.png\"  ><span class=\"image-caption\">控制节点-并行2</span><br><img  src=\"/images/article/Games104/16/Games104_16_80.png\"  ><span class=\"image-caption\">行为树</span></p>\n<p>行为树在进行执行时需要注意每一次执行时都需要返回根节点。<br><img  src=\"/images/article/Games104/16/Games104_16_81.png\"  ><span class=\"image-caption\">执行行为树</span></p>\n<p>在现代游戏中还提出了<b>decorator</b>节点来丰富可以执行的行为。<br><img  src=\"/images/article/Games104/16/Games104_16_82.png\"  ><span class=\"image-caption\">行为树-装饰器</span><br><img  src=\"/images/article/Games104/16/Games104_16_83.png\"  ><span class=\"image-caption\">行为树-装饰器2</span></p>\n<p>我们还可以使用<b>precondition</b>和<b>blackborad</b>来提升决策过程的可读性。<br><img  src=\"/images/article/Games104/16/Games104_16_84.png\"  ><span class=\"image-caption\">行为树-先决条件</span><br><img  src=\"/images/article/Games104/16/Games104_16_85.png\"  ><span class=\"image-caption\">行为树-黑板</span></p>\n<p>行为树的决策过程非常符合人的决策行为而且也易于调试，因此广泛应用在各种游戏AI中。当然行为树也有一些缺点，比如说每次调用时都必须从根节点出发重新执行，这样的效率是比较低的。<br><img  src=\"/images/article/Games104/16/Games104_16_86.png\"  ><span class=\"image-caption\">行为树-优点</span><br><img  src=\"/images/article/Games104/16/Games104_16_87.png\"  ><span class=\"image-caption\">行为树-优点2</span><br><img  src=\"/images/article/Games104/16/Games104_16_88.png\"  ><span class=\"image-caption\">行为树-缺点</span></p>\n<p>目前随着AI技术的发展，游戏AI也开始使用一些<b>规划(planning)</b>算法来进行决策。这些更先进的算法我们会在后面的课程进行介绍。<br><img  src=\"/images/article/Games104/16/Games104_16_89.png\"  ><span class=\"image-caption\">即将到来的目标是：人工智能规划和目标</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/07/26/GAMES104-NOTES-16.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV19N4y1T7eU/?spm_id_from=333.337.search-card.all.click&vd_source=7a2542c6c909b3ee1fab551277360826\">课程视频</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1r34y1J7Sg/?spm_id_from=333.788&vd_source=7a2542c6c909b3ee1fab551277360826\">课程视频2</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture16_GameplaySystemsBasicArtificialIntelligence.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}