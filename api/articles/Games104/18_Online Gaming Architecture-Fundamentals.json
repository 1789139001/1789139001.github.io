{"title":"现代游戏引擎 - 网络游戏的架构基础（十八）","slug":"Games104/18_Online Gaming Architecture-Fundamentals","date":"2023-04-24T14:33:57.000Z","updated":"2023-11-29T02:42:01.742Z","comments":true,"path":"api/articles/Games104/18_Online Gaming Architecture-Fundamentals.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/18/Games104_18_01.png","/images/article/Games104/18/Games104_18_02.png","/images/article/Games104/18/Games104_18_07.png","/images/article/Games104/18/Games104_18_08.png","/images/article/Games104/18/Games104_18_09.png","/images/article/Games104/18/Games104_18_11.png","/images/article/Games104/18/Games104_18_12.png","/images/article/Games104/18/Games104_18_13.png","/images/article/Games104/18/Games104_18_14.png","/images/article/Games104/18/Games104_18_15.png","/images/article/Games104/18/Games104_18_16.png","/images/article/Games104/18/Games104_18_17.png","/images/article/Games104/18/Games104_18_18.png","/images/article/Games104/18/Games104_18_19.png","/images/article/Games104/18/Games104_18_21.png","/images/article/Games104/18/Games104_18_22.png","/images/article/Games104/18/Games104_18_24.png","/images/article/Games104/18/Games104_18_25.png","/images/article/Games104/18/Games104_18_26.png","/images/article/Games104/18/Games104_18_27.png","/images/article/Games104/18/Games104_18_29.png","/images/article/Games104/18/Games104_18_30.png","/images/article/Games104/18/Games104_18_31.png","/images/article/Games104/18/Games104_18_32.png","/images/article/Games104/18/Games104_18_34.png","/images/article/Games104/18/Games104_18_35.png","/images/article/Games104/18/Games104_18_37.png","/images/article/Games104/18/Games104_18_40.png","/images/article/Games104/18/Games104_18_41.png","/images/article/Games104/18/Games104_18_42.png","/images/article/Games104/18/Games104_18_43.png","/images/article/Games104/18/Games104_18_44.png","/images/article/Games104/18/Games104_18_47.png","/images/article/Games104/18/Games104_18_49.png","/images/article/Games104/18/Games104_18_52.png","/images/article/Games104/18/Games104_18_53.png","/images/article/Games104/18/Games104_18_56.png","/images/article/Games104/18/Games104_18_57.png","/images/article/Games104/18/Games104_18_59.png","/images/article/Games104/18/Games104_18_60.png","/images/article/Games104/18/Games104_18_61.png","/images/article/Games104/18/Games104_18_62.png","/images/article/Games104/18/Games104_18_63.png","/images/article/Games104/18/Games104_18_64.png","/images/article/Games104/18/Games104_18_66.png","/images/article/Games104/18/Games104_18_67.png","/images/article/Games104/18/Games104_18_68.png","/images/article/Games104/18/Games104_18_69.png","/images/article/Games104/18/Games104_18_70.png","/images/article/Games104/18/Games104_18_71.png","/images/article/Games104/18/Games104_18_73.png","/images/article/Games104/18/Games104_18_75.png","/images/article/Games104/18/Games104_18_76.png","/images/article/Games104/18/Games104_18_77.png","/images/article/Games104/18/Games104_18_78.png","/images/article/Games104/18/Games104_18_81.png","/images/article/Games104/18/Games104_18_82.png","/images/article/Games104/18/Games104_18_83.png","/images/article/Games104/18/Games104_18_84.png","/images/article/Games104/18/Games104_18_85.png","/images/article/Games104/18/Games104_18_87.png","/images/article/Games104/18/Games104_18_88.png","/images/article/Games104/18/Games104_18_90.png","/images/article/Games104/18/Games104_18_91.png","/images/article/Games104/18/Games104_18_92.png","/images/article/Games104/18/Games104_18_93.png","/images/article/Games104/18/Games104_18_95.png","/images/article/Games104/18/Games104_18_96.png","/images/article/Games104/18/Games104_18_97.png","/images/article/Games104/18/Games104_18_98.png","/images/article/Games104/18/Games104_18_102.png","/images/article/Games104/18/Games104_18_105.png","/images/article/Games104/18/Games104_18_107.png","/images/article/Games104/18/Games104_18_109.png","/images/article/Games104/18/Games104_18_111.png","/images/article/Games104/18/Games104_18_112.png","/images/article/Games104/18/Games104_18_116.png","/images/article/Games104/18/Games104_18_117.png","/images/article/Games104/18/Games104_18_119.png","/images/article/Games104/18/Games104_18_123.png","/images/article/Games104/18/Games104_18_124.png","/images/article/Games104/18/Games104_18_125.png"],"cover":"/images/background/Online Gaming Architecture-Fundamentals.jpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网络游戏的出现是游戏发展历程中的重要里程碑，基于互联网玩家可以同时和全球的其它玩家一起进行游玩。<br><img src=\"/images/article/Games104/18/Games104_18_01.png\"><span class=\"image-caption\">和任何人一起玩</span></p>\n<p>网络游戏和单机游戏相比有很多难点，比如说如何保证每个玩家的游戏状态是一致的、如何进行网络同步、如何处理延迟和丢包、如何检测玩家的作弊行为、如何处理不同的设备和系统、如何设计高性能的服务器系统等等。这些网络游戏专有的问题都为游戏引擎的开发提出了更大的挑战。<br><img src=\"/images/article/Games104/18/Games104_18_02.png\"><span class=\"image-caption\">多人在线游戏中的挑战</span><br><img src=\"/images/article/Games104/18/Games104_18_03.png\"><span class=\"image-caption\">多人在线游戏中的挑战2</span><br><img src=\"/images/article/Games104/18/Games104_18_04.png\"><span class=\"image-caption\">多人在线游戏中的挑战3</span><br><img src=\"/images/article/Games104/18/Games104_18_05.png\"><span class=\"image-caption\">多人在线游戏中的挑战4</span><br><img src=\"/images/article/Games104/18/Games104_18_06.png\"><span class=\"image-caption\">多人在线游戏中的挑战5</span></p>\n<p>所以网络游戏是一个非常复杂庞大的系统，在这一部分我们同样分为两节来介绍相关的技术。<br><img src=\"/images/article/Games104/18/Games104_18_07.png\"><span class=\"image-caption\">大纲</span></p>\n<h2 id=\"网络协议（Network-Protocols）\"><a href=\"#网络协议（Network-Protocols）\" class=\"headerlink\" title=\"网络协议（Network Protocols）\"></a>网络协议（Network Protocols）</h2><p>在介绍网络游戏相关的内容前我们先来介绍一下<b>网络协议(network protocols)</b>。实际上互联网的概念最早是由Vint和Robert提出的，他们设计了TCP/IP协议从而实现了不同设备基于电话线和卫星的通信。<br><img src=\"/images/article/Games104/18/Games104_18_08.png\"><span class=\"image-caption\">互联网的开国元勋们</span></p>\n<h3 id=\"通信问题（The-Problem-of-Communication）\"><a href=\"#通信问题（The-Problem-of-Communication）\" class=\"headerlink\" title=\"通信问题（The Problem of Communication）\"></a>通信问题（The Problem of Communication）</h3><p>网络协议要解决的核心问题是如何实现两台计算机之间的数据通信，当软件应用和硬件连接不断地变得复杂时直接进行通信是非常困难的。<br><img src=\"/images/article/Games104/18/Games104_18_09.png\"><span class=\"image-caption\">如何在两台个人电脑之间进行通信</span><br><img src=\"/images/article/Games104/18/Games104_18_10.png\"><span class=\"image-caption\">通信问题</span></p>\n<p>因此人们提出了<b>中间层(intermediate layer)</b>的概念来隔绝掉应用和硬件，使得开发者可以专注于程序本身而不是具体的通信过程。<br><img src=\"/images/article/Games104/18/Games104_18_11.png\"><span class=\"image-caption\">解决方案：分层</span></p>\n<p>在现代计算机网络中人们设计了<b>OSI模型(OSI model)</b>来对通信过程进行封装和抽象。<br><img src=\"/images/article/Games104/18/Games104_18_12.png\"><span class=\"image-caption\">在互联网-OSI模型中的分层</span></p>\n<h3 id=\"套接字（Socket）\"><a href=\"#套接字（Socket）\" class=\"headerlink\" title=\"套接字（Socket）\"></a>套接字（Socket）</h3><p>对于网络游戏开发来说一般不需要接触到很底层的通信协议，在大多数情况下只需要知道如何使用<b>socket</b>建立连接即可。<br><img src=\"/images/article/Games104/18/Games104_18_13.png\"><span class=\"image-caption\">基于网络套接字的通信</span></p>\n<p>socket是一个非常简单的结构体，我们只需要知道对方的IP地址和端口号就可以使用socket建立连接来发送和接收数据。<br><img src=\"/images/article/Games104/18/Games104_18_14.png\"><span class=\"image-caption\">套接字</span></p>\n<p>建立连接时需要额外注意到底是使用IPv4还是IPv6，使用TCP还是UDP协议等问题。<br><img src=\"/images/article/Games104/18/Games104_18_15.png\"><span class=\"image-caption\">设置套接字</span></p>\n<h3 id=\"传输控制协议（-Transmission-Control-Protocol-TCP）\"><a href=\"#传输控制协议（-Transmission-Control-Protocol-TCP）\" class=\"headerlink\" title=\"传输控制协议（ Transmission Control Protocol - TCP）\"></a>传输控制协议（ Transmission Control Protocol - TCP）</h3><p>TCP是最经典也是著名的网络协议，它可以确保发送端发送的数据包都按照顺序被接收端接收。<br><img src=\"/images/article/Games104/18/Games104_18_16.png\"><span class=\"image-caption\">TCP</span></p>\n<p>TCP的核心是<b>retransmission mechanism</b>，这个机制要求接收端收到消息后会向发送端发送一个ACK，而发送端只有接收到这个ACK之后才会继续发包。当然TCP实际使用的机制要比上述的过程复杂得多。<br><img src=\"/images/article/Games104/18/Games104_18_17.png\"><span class=\"image-caption\">TCP重传机制</span></p>\n<p>当TCP出现网络拥堵时会主动调节单次发包的数量。如果发包都能顺利地接收到则会提高发包数量以提升效率，反之则会减少发包数量以提升稳定性。<br><img src=\"/images/article/Games104/18/Games104_18_18.png\"><span class=\"image-caption\">TCP堵塞控制</span></p>\n<h3 id=\"用户数据报协议（-User-Datagram-Protocol-UDP）\"><a href=\"#用户数据报协议（-User-Datagram-Protocol-UDP）\" class=\"headerlink\" title=\"用户数据报协议（ User Datagram Protocol - UDP）\"></a>用户数据报协议（ User Datagram Protocol - UDP）</h3><p>除了TCP之外人们还开发出了UDP这样的轻量级网络协议。UDP的本质是一个端到端的网络协议，它不需要建立长时间的连接，也不要求发送数据的顺序，因此UDP要比TCP简单得多。<br><img src=\"/images/article/Games104/18/Games104_18_19.png\"><span class=\"image-caption\">UDP</span><br><img src=\"/images/article/Games104/18/Games104_18_20.png\"><span class=\"image-caption\">UDP功能</span></p>\n<p>在现代网络游戏中根据游戏类型的不同使用合适的网络协议，比如说对于实时性要求比较高的游戏会优先选择UDP，而策略类的游戏则会考虑使用TCP。在大型网络游戏中还可能会使用复合类型的协议来支持游戏中不同系统的通信需求。<br><img src=\"/images/article/Games104/18/Games104_18_21.png\"><span class=\"image-caption\">UDP功能</span></p>\n<h3 id=\"可靠的-UDP（Reliable-UDP）\"><a href=\"#可靠的-UDP（Reliable-UDP）\" class=\"headerlink\" title=\"可靠的 UDP（Reliable UDP）\"></a>可靠的 UDP（Reliable UDP）</h3><p>同时现代网络游戏中往往还会对网络协议进行定制。以TCP为例，虽然TCP协议比较稳定但是效率过于低了，而且网络游戏中出现一定的丢包是可以接受的；而对于UDP来说它虽然非常高效但是却不够稳定。<br><img src=\"/images/article/Games104/18/Games104_18_22.png\"><span class=\"image-caption\">TCP不是时间关键型</span><br><img src=\"/images/article/Games104/18/Games104_18_23.png\"><span class=\"image-caption\">UDP的速度很快，但并不可靠</span></p>\n<p>因此现代网络游戏中往往会基于UDP来定制一个网络协议，这样既可以利用UDP的高效性又可以保证数据通信的有序性。<br><img src=\"/images/article/Games104/18/Games104_18_24.png\"><span class=\"image-caption\">为什么我们需要定制协议</span></p>\n<p>ACK及其相关技术是保证数据可靠通信的基本方法。<br><img src=\"/images/article/Games104/18/Games104_18_25.png\"><span class=\"image-caption\">确认信息和序列编号</span></p>\n<h4 id=\"自动重复请求（Automatic-Repeat-Request-ARQ）\"><a href=\"#自动重复请求（Automatic-Repeat-Request-ARQ）\" class=\"headerlink\" title=\"自动重复请求（Automatic Repeat Request - ARQ）\"></a>自动重复请求（Automatic Repeat Request - ARQ）</h4><p><b>ARQ(automatic repeat request)</b>是基于ACK的错误控制方法，所有的通信算法都要事项ARQ的功能。<br><img src=\"/images/article/Games104/18/Games104_18_26.png\"><span class=\"image-caption\">ARQ</span></p>\n<h4 id=\"滑窗协议（Sliding-Window-Protocol）\"><a href=\"#滑窗协议（Sliding-Window-Protocol）\" class=\"headerlink\" title=\"滑窗协议（Sliding Window Protocol）\"></a>滑窗协议（Sliding Window Protocol）</h4><p><b>滑窗协议(sliding window protocol)</b>是经典的ARQ实现方法，它在发送数据时每次发送窗口大小的包然后检验回复的ACK来判断是否出现丢包的情况。<br><img src=\"/images/article/Games104/18/Games104_18_27.png\"><span class=\"image-caption\">滑窗协议</span><br><img src=\"/images/article/Games104/18/Games104_18_28.png\"><span class=\"image-caption\">滑窗协议2</span></p>\n<p>滑窗协议的一个缺陷在于它需要等待接收端的ACK才能继续发送数据，因此在很多情况下它无法完全利用带宽。<br><img src=\"/images/article/Games104/18/Games104_18_29.png\"><span class=\"image-caption\">停止等待ARQ</span></p>\n<h4 id=\"回退n帧的自动重复请求（Go-Back-N-ARQ）\"><a href=\"#回退n帧的自动重复请求（Go-Back-N-ARQ）\" class=\"headerlink\" title=\"回退n帧的自动重复请求（Go-Back-N ARQ）\"></a>回退n帧的自动重复请求（Go-Back-N ARQ）</h4><p>对滑窗协议的一种改进方法是<b>Go-Back-N ARQ</b>，当出现丢包时它只会把窗口内的包重新发送。<br><img src=\"/images/article/Games104/18/Games104_18_30.png\"><span class=\"image-caption\">Go-Back-N ARQ</span></p>\n<h4 id=\"选择性重复的ARQ（Selective-Repeat-ARQ）\"><a href=\"#选择性重复的ARQ（Selective-Repeat-ARQ）\" class=\"headerlink\" title=\"选择性重复的ARQ（Selective Repeat ARQ）\"></a>选择性重复的ARQ（Selective Repeat ARQ）</h4><p>另一种改进方法是<b>selective repeat ARQ</b>，它只会重新发送丢失或损坏的包从而进一步提升带宽的利用率。<br><img src=\"/images/article/Games104/18/Games104_18_31.png\"><span class=\"image-caption\">Selective Repeat ARQ</span></p>\n<h4 id=\"前向纠错（Forward-Error-Correction）\"><a href=\"#前向纠错（Forward-Error-Correction）\" class=\"headerlink\" title=\"前向纠错（Forward Error Correction）\"></a>前向纠错（Forward Error Correction）</h4><p>在网络游戏中需要额外处理丢包的问题，因此我们在自定义网络协议时一般会结合<b>forward error correction(FEC)</b>的方法来避免数据的反复发送。<br><img src=\"/images/article/Games104/18/Games104_18_32.png\"><span class=\"image-caption\">在丢包丢失场景中使UDP可靠</span><br><img src=\"/images/article/Games104/18/Games104_18_33.png\"><span class=\"image-caption\">前向纠错</span></p>\n<p>目前常用的FEC算法包括异或校验位以及Reed-Solomon codes两大类。<br><img src=\"/images/article/Games104/18/Games104_18_34.png\"><span class=\"image-caption\">前向纠错</span></p>\n<h4 id=\"异或（XOR-FEC）\"><a href=\"#异或（XOR-FEC）\" class=\"headerlink\" title=\"异或（XOR FEC）\"></a>异或（XOR FEC）</h4><p>异或校验位是使用<b>异或(XOR)</b>运算来恢复丢失数据的方法。这里需要注意的是当同时有多个包丢失时，使用异或校验位是无法恢复数据的。<br><img src=\"/images/article/Games104/18/Games104_18_35.png\"><span class=\"image-caption\">异或</span><br><img src=\"/images/article/Games104/18/Games104_18_36.png\"><span class=\"image-caption\">异或2</span></p>\n<h4 id=\"Reed-Solomon编码（Reed-Solomon-Codes）\"><a href=\"#Reed-Solomon编码（Reed-Solomon-Codes）\" class=\"headerlink\" title=\"Reed-Solomon编码（Reed-Solomon Codes）\"></a>Reed-Solomon编码（Reed-Solomon Codes）</h4><p><b>Reed-Solomon codes</b>是经典的信息传输算法，它利用Vandemode矩阵及其逆阵来恢复丢失的数据。<br><img src=\"/images/article/Games104/18/Games104_18_37.png\"><span class=\"image-caption\">Reed-Solomon编码</span><br><img src=\"/images/article/Games104/18/Games104_18_38.png\"><span class=\"image-caption\">Reed-Solomon编码2</span><br><img src=\"/images/article/Games104/18/Games104_18_39.png\"><span class=\"image-caption\">Reed-Solomon编码3</span></p>\n<p>总结一下，在自定义UDP时需要考虑ARQ和FEC两类问题。<br><img src=\"/images/article/Games104/18/Games104_18_40.png\"><span class=\"image-caption\">基于ARQ和FEC定制您的UDP</span></p>\n<h2 id=\"时钟同步（Clock-Synchronization）\"><a href=\"#时钟同步（Clock-Synchronization）\" class=\"headerlink\" title=\"时钟同步（Clock Synchronization）\"></a>时钟同步（Clock Synchronization）</h2><p>有了网络协议后就可以开始对网络游戏进行开发了，不过在具体设计游戏前我们还需要考虑不同玩家之间的<b>时钟同步(clock synchronization)</b>问题。</p>\n<h3 id=\"往返时间（Round-Trip-Time-RTT）\"><a href=\"#往返时间（Round-Trip-Time-RTT）\" class=\"headerlink\" title=\"往返时间（Round Trip Time - RTT）\"></a>往返时间（Round Trip Time - RTT）</h3><p>由于网络通信延迟的存在，客户端向服务器端发送一个包后都需要等待一定的时间才能收到回包，这个间隔的时间称为round-trip time(RTT)<b>。RTT的概念类似于ping，不过它们的区别在于ping更加偏向于底层而RTT则位于顶部的应用层。<br><img src=\"/images/article/Games104/18/Games104_18_41.png\"><span class=\"image-caption\">基于ARQ和FEC定制您的UDP</span></b></p><b>\n<h3 id=\"网络时间协议（Network-Time-Protocol）\"><a href=\"#网络时间协议（Network-Time-Protocol）\" class=\"headerlink\" title=\"网络时间协议（Network Time Protocol）\"></a>网络时间协议（Network Time Protocol）</h3><p>利用RTT就可以实现不同设备之间的时间同步。实际上不仅仅是网络游戏，现实生活中的各种电子设备进行同步都使用了RTT的技术。<br><img src=\"/images/article/Games104/18/Games104_18_42.png\"><span class=\"image-caption\">网络时间协议</span></p>\n<p>在实际设备的时间同步过程中一般会利用层次化的结构来进行实现。<br><img src=\"/images/article/Games104/18/Games104_18_43.png\"><span class=\"image-caption\">时间服务器层</span></p>\n<p>NTP的算法实际上非常简单，我们只需要从客户端发送请求然后从服务器接收一个时刻就好，这样就可以得到4个时间戳。如果我们进一步假定网络上行和下行的延迟是一致的，我们可以直接计算出RTT的时间长短以及两个设备之间的时间偏差。当然需要注意的是在实际中网络上行和下行的带宽往往是不一致的，因此这个算法也不是十分的严谨。<br><img src=\"/images/article/Games104/18/Games104_18_44.png\"><span class=\"image-caption\">NTP算法</span><br><img src=\"/images/article/Games104/18/Games104_18_45.png\"><span class=\"image-caption\">NTP算法2</span><br><img src=\"/images/article/Games104/18/Games104_18_46.png\"><span class=\"image-caption\">NTP算法3</span></p>\n<p>实际上我们可以证明在不可靠的通信中是无法严格校准时间的。不过在实践中我们可以通过不断的使用NTP算法来得到一系列RTT值，然后把高于平均值50%的部分丢弃，剩下的RTT平均值的1.5倍就可以作为真实RTT的估计。<br><img src=\"/images/article/Games104/18/Games104_18_47.png\"><span class=\"image-caption\">基于流的时间同步与消除更高阶模式</span><br><img src=\"/images/article/Games104/18/Games104_18_48.png\"><span class=\"image-caption\">基于流的时间同步与消除更高阶模式2</span></p>\n<h2 id=\"远程过程调用（Remote-Procedure-Call-RPC）\"><a href=\"#远程过程调用（Remote-Procedure-Call-RPC）\" class=\"headerlink\" title=\"远程过程调用（Remote Procedure Call - RPC）\"></a>远程过程调用（Remote Procedure Call - RPC）</h2><h3 id=\"套接字编程（Socket-Programming）\"><a href=\"#套接字编程（Socket-Programming）\" class=\"headerlink\" title=\"套接字编程（Socket Programming）\"></a>套接字编程（Socket Programming）</h3><p>尽管利用socket我们可以实现客户端和服务器的通信，但对于网络游戏来说完全基于socket的通信是非常复杂的。这主要是因为网络游戏中客户端需要向服务器发送大量不同类型的消息，同时客户端也需要解析相应类型的反馈，这就会导致游戏逻辑变得无比复杂。<br><img src=\"/images/article/Games104/18/Games104_18_49.png\"><span class=\"image-caption\">套接字编程：仍然不是很好</span><br><img src=\"/images/article/Games104/18/Games104_18_50.png\"><span class=\"image-caption\">与消息通信</span><br><img src=\"/images/article/Games104/18/Games104_18_51.png\"><span class=\"image-caption\">通信方式</span></p>\n<p>另一方面客户端和服务器往往有着不同的硬件和操作系统，这些差异会使得游戏逻辑更加复杂且难以调试。<br><img src=\"/images/article/Games104/18/Games104_18_52.png\"><span class=\"image-caption\">逻辑通信所面临的更多挑战</span></p>\n<h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><p>因此在现代网络游戏中一般会使用<b>RPC(remote procedure call)</b>的方式来实现客户端和服务器的通信。基于RPC的技术在客户端可以像本地调用函数的方式来向服务器发送请求，这样使得开发人员可以专注于游戏逻辑而不是具体底层的实现。<br><img src=\"/images/article/Games104/18/Games104_18_53.png\"><span class=\"image-caption\">RPC</span><br><img src=\"/images/article/Games104/18/Games104_18_54.png\"><span class=\"image-caption\">RPC示例</span><br><img src=\"/images/article/Games104/18/Games104_18_55.png\"><span class=\"image-caption\">为什么RPC？</span></p>\n<p>在RPC中会大量使用<b>IDL(interface definiton language)</b>来定义不同的消息形式。<br><img src=\"/images/article/Games104/18/Games104_18_56.png\"><span class=\"image-caption\">IDL</span></p>\n<p>然后在启动时通过<b>RPC stubs</b>来通知客户端有哪些RPC是可以进行调用的。<br><img src=\"/images/article/Games104/18/Games104_18_57.png\"><span class=\"image-caption\">RPC 存根</span><br><img src=\"/images/article/Games104/18/Games104_18_58.png\"><span class=\"image-caption\">存根编译程序</span></p>\n<p>当然真实游戏中的RPC在实际进行调用时还有很多的消息处理和加密工作。<br><img src=\"/images/article/Games104/18/Games104_18_59.png\"><span class=\"image-caption\">真正的RPC包之旅</span></p>\n<h2 id=\"网络拓扑（Network-Topology）\"><a href=\"#网络拓扑（Network-Topology）\" class=\"headerlink\" title=\"网络拓扑（Network Topology）\"></a>网络拓扑（Network Topology）</h2><h3 id=\"点对点（Peer-to-Peer-P2P）\"><a href=\"#点对点（Peer-to-Peer-P2P）\" class=\"headerlink\" title=\"点对点（Peer-to-Peer - P2P）\"></a>点对点（Peer-to-Peer - P2P）</h3><p>在设计网络游戏时还需要考虑网络自身的架构。最经典的网络架构是<b>P2P(peer-to-peer)</b>，此时每个客户端之间会直接建立通信。<br><img src=\"/images/article/Games104/18/Games104_18_60.png\"><span class=\"image-caption\">P2P</span></p>\n<p>当P2P需要集中所有玩家的信息时则可以选择其中一个客户端作为主机，这样其它的客户端可以通过连接主机的方式来实现联机。<br><img src=\"/images/article/Games104/18/Games104_18_61.png\"><span class=\"image-caption\">带主机服务器的P2P</span></p>\n<p>很多早期经典的游戏都是使用这样的网络架构来实现联网功能。<br><img src=\"/images/article/Games104/18/Games104_18_62.png\"><span class=\"image-caption\">P2P游戏</span></p>\n<h3 id=\"专用服务器（Dedicated-Server）\"><a href=\"#专用服务器（Dedicated-Server）\" class=\"headerlink\" title=\"专用服务器（Dedicated Server）\"></a>专用服务器（Dedicated Server）</h3><p>在现代网络游戏中更多地会使用<b>dedicated server</b>这样的网络架构，此时网络中有一个专门的服务器向其它客户端提供服务。<br><img src=\"/images/article/Games104/18/Games104_18_63.png\"><span class=\"image-caption\">专用服务器</span></p>\n<p>从实践结果来看，对于小型的网络游戏P2P是一个足够好的架构，而对于大型的商业网络游戏则必须使用dedicated server这样的形式。<br><img src=\"/images/article/Games104/18/Games104_18_64.png\"><span class=\"image-caption\">P2P与专用服务器</span><br><img src=\"/images/article/Games104/18/Games104_18_65.png\"><span class=\"image-caption\">当RTT太高时</span></p>\n<h2 id=\"游戏同步（Game-Synchronization）\"><a href=\"#游戏同步（Game-Synchronization）\" class=\"headerlink\" title=\"游戏同步（Game Synchronization）\"></a>游戏同步（Game Synchronization）</h2><p>在前面的课程中我们介绍过游戏世界是分层的。从玩家的角度来看，玩家的操作通过输入层一路向下到达游戏逻辑层，然后通过渲染器展示给玩家。<br><img src=\"/images/article/Games104/18/Games104_18_66.png\"><span class=\"image-caption\">单人游戏</span></p>\n<p>而在网络游戏中，除了单机游戏都需要的分层外我们还需要考虑不同玩家之间的同步。在理想情况下我们希望客户端只负责处理玩家的输入，整个游戏逻辑都放在服务器端。<br><img src=\"/images/article/Games104/18/Games104_18_67.png\"><span class=\"image-caption\">网络游戏</span></p>\n<p>由于延迟的存在，不同玩家视角下的对方可能会有不同的行为表现。<br><img src=\"/images/article/Games104/18/Games104_18_68.png\"><span class=\"image-caption\">游戏同步</span></p>\n<p>因此我们需要使用游戏同步技术来保证玩家的游戏体验是一致的。目前常用的同步技术包括快照同步、帧同步以及状态同步等。<br><img src=\"/images/article/Games104/18/Games104_18_69.png\"><span class=\"image-caption\">同步方法</span></p>\n<h3 id=\"快照同步（Snapshot-Synchronization）\"><a href=\"#快照同步（Snapshot-Synchronization）\" class=\"headerlink\" title=\"快照同步（Snapshot Synchronization）\"></a>快照同步（Snapshot Synchronization）</h3><p><b>快照同步(snapshot synchronization)</b>是一种相对古老的同步技术。在快照同步中客户端只负责向服务器发送当前玩家的数据，由服务器完成整个游戏世界的运行。然后服务器会为游戏世界生成一张快照，再发送给每个客户端来给玩家反馈。<br><img src=\"/images/article/Games104/18/Games104_18_70.png\"><span class=\"image-caption\">快照同步</span></p>\n<p>快照同步可以严格保证每个玩家的状态都是准确的，但其缺陷在于它给服务器提出了非常巨大的挑战。因此在实际游戏中一般会降低服务器上游戏运行的帧率来平衡带宽，然后在客户端上通过插值的方式来获得高帧率。<br><img src=\"/images/article/Games104/18/Games104_18_71.png\"><span class=\"image-caption\">快照同步-抖动和挂接</span><br><img src=\"/images/article/Games104/18/Games104_18_72.png\"><span class=\"image-caption\">快照插值</span></p>\n<p>由于每次生成快照的成本是相对较高的，为了压缩数据我们可以使用状态的变化量来对游戏状态进行表示。<br><img src=\"/images/article/Games104/18/Games104_18_73.png\"><span class=\"image-caption\">差值压缩</span><br><img src=\"/images/article/Games104/18/Games104_18_74.png\"><span class=\"image-caption\">差值压缩2</span></p>\n<p>快照同步非常简单也易于实现，但它基本浪费掉了客户端上的算力同时在服务器上会产生过大的压力。因此在现代网络游戏中基本不会使用快照同步的方式。<br><img src=\"/images/article/Games104/18/Games104_18_75.png\"><span class=\"image-caption\">快照同步</span></p>\n<h3 id=\"帧同步（Lockstep-Synchronization）\"><a href=\"#帧同步（Lockstep-Synchronization）\" class=\"headerlink\" title=\"帧同步（Lockstep Synchronization）\"></a>帧同步（Lockstep Synchronization）</h3><p><b>帧同步(lockstep synchronization)</b>是现代网络游戏中非常常用的同步技术。不同于快照同步完全通过服务器来运行游戏世界，在帧同步中服务器更多地是完成数据的分发工作。玩家的操作通过客户端发送到服务器上，经过服务器汇总后将当前游戏世界的状态返还给客户端，然后在每个客户端上运行游戏世界。<br><img src=\"/images/article/Games104/18/Games104_18_76.png\"><span class=\"image-caption\">帧同步的在线游戏</span></p>\n<h4 id=\"帧同步初始化（Lockstep-Initialization）\"><a href=\"#帧同步初始化（Lockstep-Initialization）\" class=\"headerlink\" title=\"帧同步初始化（Lockstep Initialization）\"></a>帧同步初始化（Lockstep Initialization）</h4><p>使用帧同步时首先需要进行初始化，将客户端上所有的游戏数据与服务器进行同步。这一过程一般是在游戏loading阶段来实现的。<br><img src=\"/images/article/Games104/18/Games104_18_77.png\"><span class=\"image-caption\">帧同步初始化</span></p>\n<h4 id=\"确定性的帧同步（Deterministic-Lockstep）\"><a href=\"#确定性的帧同步（Deterministic-Lockstep）\" class=\"headerlink\" title=\"确定性的帧同步（Deterministic Lockstep）\"></a>确定性的帧同步（Deterministic Lockstep）</h4><p>在游戏过程中客户端会在每一帧将玩家数据发送到服务器上，服务器接收到所有玩家的数据后再统一转发到玩家客户端上，然后由玩家客户端执行游戏逻辑。当然这种同步方式也存在一定的缺陷，当某个玩家的数据滞后了所有玩家都必须要进行等待。这种情况在一些早期的联网游戏中都很常见。<br><img src=\"/images/article/Games104/18/Games104_18_78.png\"><span class=\"image-caption\">确定性的帧同步</span><br><img src=\"/images/article/Games104/18/Games104_18_79.png\"><span class=\"image-caption\">确定性的帧同步2</span><br><img src=\"/images/article/Games104/18/Games104_18_80.png\"><span class=\"image-caption\">玩家脱机在确定性的锁定步骤</span></p>\n<h4 id=\"存储桶同步（Bucket-Synchronization）\"><a href=\"#存储桶同步（Bucket-Synchronization）\" class=\"headerlink\" title=\"存储桶同步（Bucket Synchronization）\"></a>存储桶同步（Bucket Synchronization）</h4><p>为了克服这样的问题，人们提出了<b>bucket synchronization</b>这样的策略。此时服务器只会等待bucket长度的时间，如果超时没有收到客户端发来的数据就越过去，看下一个bucket时间段能否接收到。通过这样的方式其它玩家就无需一直等待了。<br><img src=\"/images/article/Games104/18/Games104_18_81.png\"><span class=\"image-caption\">存储桶同步</span></p>\n<p>bucket synchronization本质是对玩家数据的一致性以及游戏体验进行的一种权衡。<br><img src=\"/images/article/Games104/18/Games104_18_82.png\"><span class=\"image-caption\">在一致性和交互性维护之间的良好权衡</span></p>\n<h4 id=\"确定性困难（Deterministic-Difficulties）\"><a href=\"#确定性困难（Deterministic-Difficulties）\" class=\"headerlink\" title=\"确定性困难（Deterministic Difficulties）\"></a>确定性困难（Deterministic Difficulties）</h4><p>帧同步的一大难点在于它要保证不同客户端上游戏世界在相同输入的情况下有着完全一致的输出。<br><img src=\"/images/article/Games104/18/Games104_18_83.png\"><span class=\"image-caption\">确定性困难</span></p>\n<p>为了保证输出的确定性我们首先要保证浮点数在不同客户端上的一致性，这可以使用IEEE 754标准来实现。<br><img src=\"/images/article/Games104/18/Games104_18_84.png\"><span class=\"image-caption\">浮点数</span></p>\n<p>其次在不同的设备上我们需要保证相关的数学运算函数有一致的行为，对于这种问题则可以使用查表的方式来避免实际的计算。<br><img src=\"/images/article/Games104/18/Games104_18_85.png\"><span class=\"image-caption\">浮点数2</span><br><img src=\"/images/article/Games104/18/Games104_18_86.png\"><span class=\"image-caption\">浮点数3</span></p>\n<p>除此之外还可以使用定点数来替换浮点数，从而避免浮点数导致的各种问题。<br><img src=\"/images/article/Games104/18/Games104_18_87.png\"><span class=\"image-caption\">浮点数4</span></p>\n<p>除了浮点数之外还要考虑随机数的问题，我们要求随机数在不同的客户端上也必须是完全一致的。因此在游戏客户端和服务器进行同步时需要将随机数种子以及随机数生成算法进行同步。<br><img src=\"/images/article/Games104/18/Games104_18_88.png\"><span class=\"image-caption\">随机数</span><br><img src=\"/images/article/Games104/18/Games104_18_89.png\"><span class=\"image-caption\">随机数2</span></p>\n<p>总结一下，保证客户端上游戏世界模拟一致的常用方法如下：<br><img src=\"/images/article/Games104/18/Games104_18_90.png\"><span class=\"image-caption\">确定性困难</span></p>\n<h4 id=\"跟踪和调试（Tracing-and-Debugging）\"><a href=\"#跟踪和调试（Tracing-and-Debugging）\" class=\"headerlink\" title=\"跟踪和调试（Tracing and Debugging）\"></a>跟踪和调试（Tracing and Debugging）</h4><p>现代网络游戏的逻辑往往非常复杂，在玩家进行游玩时可能无法避免地出现一些bug，因此对于服务器来说检测客户端发送的数据是否存在bug就非常重要。一般来说我们会要求客户端每隔一段时间就上传本地的log，由服务器来检查上传数据是否存在bug。<br><img src=\"/images/article/Games104/18/Games104_18_91.png\"><span class=\"image-caption\">跟踪和调试</span></p>\n<h4 id=\"滞后和延迟（Lag-and-Delay）\"><a href=\"#滞后和延迟（Lag-and-Delay）\" class=\"headerlink\" title=\"滞后和延迟（Lag and Delay）\"></a>滞后和延迟（Lag and Delay）</h4><p>为了处理网络延迟的问题我们还可以在客户端上缓存若干帧，当然缓存的大小会在一定程度上影响玩家的游戏体验。<br><img src=\"/images/article/Games104/18/Games104_18_92.png\"><span class=\"image-caption\">滞后和延迟</span></p>\n<p>另一方面我们还可以把游戏逻辑帧和渲染帧进行分离，然后通过插值的方式来获得更加平滑的渲染效果。<br><img src=\"/images/article/Games104/18/Games104_18_93.png\"><span class=\"image-caption\">区分游戏逻辑和渲染功能</span><br><img src=\"/images/article/Games104/18/Games104_18_94.png\"><span class=\"image-caption\">区分游戏逻辑和渲染功能2</span></p>\n<h4 id=\"重新连接问题（Reconnection-Problem）\"><a href=\"#重新连接问题（Reconnection-Problem）\" class=\"headerlink\" title=\"重新连接问题（Reconnection Problem）\"></a>重新连接问题（Reconnection Problem）</h4><p>由于网络的不稳定，玩家可能会不可避免地遇到断线的情况，此时我们还需要设计断线重连的机制。<br><img src=\"/images/article/Games104/18/Games104_18_95.png\"><span class=\"image-caption\">重新连接问题</span></p>\n<p>实际上再进行帧同步时每个若干帧会设置一个关键帧。在关键帧进行同步时还会更新游戏世界的快照，这样可保证即使游戏崩溃了也可以从快照中恢复。<br><img src=\"/images/article/Games104/18/Games104_18_96.png\"><span class=\"image-caption\">客户端游戏状态快照</span></p>\n<p>为了实现这样的功能可以使用<b>quick catch up</b>技术，此时我们暂停游戏的渲染把所有的计算资源用来执行游戏逻辑。<br><img src=\"/images/article/Games104/18/Games104_18_97.png\"><span class=\"image-caption\">快速追赶</span></p>\n<p>而在服务器端也可以使用类似的技术，从而帮助掉线的玩家快速恢复到游戏的当前状态。实际上网络游戏的观战和回放功能也是使用这样的技术来实现的。<br><img src=\"/images/article/Games104/18/Games104_18_98.png\"><span class=\"image-caption\">服务器状态快照优化</span><br><img src=\"/images/article/Games104/18/Games104_18_99.png\"><span class=\"image-caption\">临时脱机，无崩溃</span><br><img src=\"/images/article/Games104/18/Games104_18_100.png\"><span class=\"image-caption\">观战</span><br><img src=\"/images/article/Games104/18/Games104_18_101.png\"><span class=\"image-caption\">重播</span></p>\n<h4 id=\"帧同步作弊问题（Lockstep-Cheating-Issues）\"><a href=\"#帧同步作弊问题（Lockstep-Cheating-Issues）\" class=\"headerlink\" title=\"帧同步作弊问题（Lockstep Cheating Issues）\"></a>帧同步作弊问题（Lockstep Cheating Issues）</h4><p>网络游戏中作弊行为的检查是非常重要的。对于帧同步的游戏，玩家可以通过发送虚假的状态来实现作弊行为，这就要求我们实现一些反作弊机制。<br><img src=\"/images/article/Games104/18/Games104_18_102.png\"><span class=\"image-caption\">帧同步作弊问题</span><br><img src=\"/images/article/Games104/18/Games104_18_103.png\"><span class=\"image-caption\">帧同步作弊问题2</span><br><img src=\"/images/article/Games104/18/Games104_18_104.png\"><span class=\"image-caption\">帧同步作弊问题3</span></p>\n<h4 id=\"帧同步总结（Lockstep-Summary）\"><a href=\"#帧同步总结（Lockstep-Summary）\" class=\"headerlink\" title=\"帧同步总结（Lockstep Summary）\"></a>帧同步总结（Lockstep Summary）</h4><p>总结一下，帧同步会占用更少的带宽也比较适合各种需要实时反馈的游戏。而帧同步的难点主要集中在如何保证在不同客户端上游戏运行的一致性，如何设计断线重连机制等。<br><img src=\"/images/article/Games104/18/Games104_18_105.png\"><span class=\"image-caption\">帧同步总结</span><br><img src=\"/images/article/Games104/18/Games104_18_106.png\"><span class=\"image-caption\">帧同步总结2</span></p>\n<h3 id=\"状态同步（State-Synchronization）\"><a href=\"#状态同步（State-Synchronization）\" class=\"headerlink\" title=\"状态同步（State Synchronization）\"></a>状态同步（State Synchronization）</h3><p><b>状态同步(state synchronization)</b>是目前大型网游非常流行的同步技术，它的基本思想是把玩家的状态和事件进行同步。<br><img src=\"/images/article/Games104/18/Games104_18_107.png\"><span class=\"image-caption\">状态同步</span><br><img src=\"/images/article/Games104/18/Games104_18_108.png\"><span class=\"image-caption\">状态同步2</span></p>\n<p>进行状态同步时由客户端提交玩家的状态数据，而服务器则会在收集到所有玩家的数据后运行游戏逻辑，然后把下一时刻的状态分发给所有的客户端。<br><img src=\"/images/article/Games104/18/Games104_18_109.png\"><span class=\"image-caption\">状态同步3</span><br><img src=\"/images/article/Games104/18/Games104_18_110.png\"><span class=\"image-caption\">服务器授权的游戏世界</span></p>\n<h4 id=\"授权和复制的客户端（Authorized-and-Replicated-Clients）\"><a href=\"#授权和复制的客户端（Authorized-and-Replicated-Clients）\" class=\"headerlink\" title=\"授权和复制的客户端（Authorized and Replicated Clients）\"></a>授权和复制的客户端（Authorized and Replicated Clients）</h4><p>状态同步中服务器称为<b>authorized server</b>，它是整个游戏世界的绝对权威；而玩家的本地客户端称为<b>authorized client</b>，它是玩家操作游戏角色的接口；在其他玩家视角下的同一角色则称为<b>replicated client</b>，表示它们仅仅是authorized client的一个副本。<br><img src=\"/images/article/Games104/18/Games104_18_111.png\"><span class=\"image-caption\">授权和复制的客户端</span></p>\n<h4 id=\"状态同步示例（State-Synchronization-Example）\"><a href=\"#状态同步示例（State-Synchronization-Example）\" class=\"headerlink\" title=\"状态同步示例（State Synchronization Example）\"></a>状态同步示例（State Synchronization Example）</h4><p>当authorized client执行了某种行为时首先会向服务发送相关的数据，然后由服务器驱动游戏逻辑并把相应的状态发布给所有的玩家。当其他客户端接收到更新后的状态时，再驱动replicated client执行authorized client的行为。类似地，authorized client行为产生的后果也是由服务器进行计算再发布给所有的客户端。这样的好处在于我们无需要求每个客户端上的模拟是严格一致的，整个游戏世界本质上仍然是由统一的服务器进行驱动。<br><img src=\"/images/article/Games104/18/Games104_18_112.png\"><span class=\"image-caption\">状态同步示例</span><br><img src=\"/images/article/Games104/18/Games104_18_113.png\"><span class=\"image-caption\">状态同步示例2</span><br><img src=\"/images/article/Games104/18/Games104_18_114.png\"><span class=\"image-caption\">状态同步示例3</span><br><img src=\"/images/article/Games104/18/Games104_18_115.png\"><span class=\"image-caption\">状态同步示例4</span></p>\n<h4 id=\"滞后的客户端问题（Dumb-Client-Problem）\"><a href=\"#滞后的客户端问题（Dumb-Client-Problem）\" class=\"headerlink\" title=\"滞后的客户端问题（Dumb Client Problem）\"></a>滞后的客户端问题（Dumb Client Problem）</h4></b><p><b>由于游戏角色的所有行为都需要经过服务器的确认才能执行，状态同步会产生</b>dumb client<b>的问题，即玩家视角下角色的行为可能是滞后的。<br><img src=\"/images/article/Games104/18/Games104_18_116.png\"><span class=\"image-caption\">滞后的客户端问题</span></b></p><b>\n<p>要缓解这样的问题可以在客户端上对玩家的行为进行预测。比如说当角色需要进行移动时首先在本地移动半步，然后等服务器传来确定的消息后再进行对齐，这样就可以改善玩家的游戏体验。在守望先锋中就使用了这样的方式来保证玩家顺畅的游玩。<br><img src=\"/images/article/Games104/18/Games104_18_117.png\"><span class=\"image-caption\">客户端预测</span><br><img src=\"/images/article/Games104/18/Games104_18_118.png\"><span class=\"image-caption\">监督-客户端预测</span></p>\n<p>由于网络波动的存在，来自服务器的确认消息往往会滞后于本地的预测。因此我们可以使用一个buffer来缓存游戏角色的状态，这样当收到服务器的消息时首先跟buffer中的状态进行检验。当buffer中的状态和服务器的数据不一致时就需要根据服务器的数据来矫正玩家状态。<br><img src=\"/images/article/Games104/18/Games104_18_119.png\"><span class=\"image-caption\">服务器调整</span><br><img src=\"/images/article/Games104/18/Games104_18_120.png\"><span class=\"image-caption\">服务器调整2</span><br><img src=\"/images/article/Games104/18/Games104_18_121.png\"><span class=\"image-caption\">服务器调整3</span><br><img src=\"/images/article/Games104/18/Games104_18_122.png\"><span class=\"image-caption\">服务器调整4</span></p>\n<p>当然这样的机制对于网络条件不好的玩家是不太公平的，他们的角色状态会不断地被服务器修正。<br><img src=\"/images/article/Games104/18/Games104_18_123.png\"><span class=\"image-caption\">服务器对齐示例</span></p>\n<h4 id=\"丢包（Packet-Loss）\"><a href=\"#丢包（Packet-Loss）\" class=\"headerlink\" title=\"丢包（Packet Loss）\"></a>丢包（Packet Loss）</h4><p>对于丢包的问题在服务器端也会维护一个小的buffer来储存玩家的状态。如果buffer被清空则说明可能出现了掉线的情况，此时服务器会复制玩家上一个输入来维持游戏的运行。<br><img src=\"/images/article/Games104/18/Games104_18_124.png\"><span class=\"image-caption\">丢包</span></p>\n<p>帧同步和状态同步两种主流同步技术的对比如下：<br><img src=\"/images/article/Games104/18/Games104_18_125.png\"><span class=\"image-caption\">状态同步与帧同步</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/08/10/GAMES104-NOTES-18.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1La411o7kG/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1HN4y157Zq/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频2</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_PPT_Lecture%2018_Online%20Gaming%20Architecture-Fundamentals.pdf\">课件PPT</a></p>\n</b>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网络游戏的出现是游戏发展历程中的重要里程碑，基于互联网玩家可以同时和全球的其它玩家一起进行游玩。<br><img  src=\"/images/article/Games104/18/Games104_18_01.png\"  ><span class=\"image-caption\">和任何人一起玩</span></p>\n<p>网络游戏和单机游戏相比有很多难点，比如说如何保证每个玩家的游戏状态是一致的、如何进行网络同步、如何处理延迟和丢包、如何检测玩家的作弊行为、如何处理不同的设备和系统、如何设计高性能的服务器系统等等。这些网络游戏专有的问题都为游戏引擎的开发提出了更大的挑战。<br><img  src=\"/images/article/Games104/18/Games104_18_02.png\"  ><span class=\"image-caption\">多人在线游戏中的挑战</span><br><img  src=\"/images/article/Games104/18/Games104_18_03.png\"  ><span class=\"image-caption\">多人在线游戏中的挑战2</span><br><img  src=\"/images/article/Games104/18/Games104_18_04.png\"  ><span class=\"image-caption\">多人在线游戏中的挑战3</span><br><img  src=\"/images/article/Games104/18/Games104_18_05.png\"  ><span class=\"image-caption\">多人在线游戏中的挑战4</span><br><img  src=\"/images/article/Games104/18/Games104_18_06.png\"  ><span class=\"image-caption\">多人在线游戏中的挑战5</span></p>\n<p>所以网络游戏是一个非常复杂庞大的系统，在这一部分我们同样分为两节来介绍相关的技术。<br><img  src=\"/images/article/Games104/18/Games104_18_07.png\"  ><span class=\"image-caption\">大纲</span></p>\n<h2 id=\"网络协议（Network-Protocols）\"><a href=\"#网络协议（Network-Protocols）\" class=\"headerlink\" title=\"网络协议（Network Protocols）\"></a>网络协议（Network Protocols）</h2><p>在介绍网络游戏相关的内容前我们先来介绍一下<b>网络协议(network protocols)</b>。实际上互联网的概念最早是由Vint和Robert提出的，他们设计了TCP&#x2F;IP协议从而实现了不同设备基于电话线和卫星的通信。<br><img  src=\"/images/article/Games104/18/Games104_18_08.png\"  ><span class=\"image-caption\">互联网的开国元勋们</span></p>\n<h3 id=\"通信问题（The-Problem-of-Communication）\"><a href=\"#通信问题（The-Problem-of-Communication）\" class=\"headerlink\" title=\"通信问题（The Problem of Communication）\"></a>通信问题（The Problem of Communication）</h3><p>网络协议要解决的核心问题是如何实现两台计算机之间的数据通信，当软件应用和硬件连接不断地变得复杂时直接进行通信是非常困难的。<br><img  src=\"/images/article/Games104/18/Games104_18_09.png\"  ><span class=\"image-caption\">如何在两台个人电脑之间进行通信</span><br><img  src=\"/images/article/Games104/18/Games104_18_10.png\"  ><span class=\"image-caption\">通信问题</span></p>\n<p>因此人们提出了<b>中间层(intermediate layer)</b>的概念来隔绝掉应用和硬件，使得开发者可以专注于程序本身而不是具体的通信过程。<br><img  src=\"/images/article/Games104/18/Games104_18_11.png\"  ><span class=\"image-caption\">解决方案：分层</span></p>\n<p>在现代计算机网络中人们设计了<b>OSI模型(OSI model)</b>来对通信过程进行封装和抽象。<br><img  src=\"/images/article/Games104/18/Games104_18_12.png\"  ><span class=\"image-caption\">在互联网-OSI模型中的分层</span></p>\n<h3 id=\"套接字（Socket）\"><a href=\"#套接字（Socket）\" class=\"headerlink\" title=\"套接字（Socket）\"></a>套接字（Socket）</h3><p>对于网络游戏开发来说一般不需要接触到很底层的通信协议，在大多数情况下只需要知道如何使用<b>socket</b>建立连接即可。<br><img  src=\"/images/article/Games104/18/Games104_18_13.png\"  ><span class=\"image-caption\">基于网络套接字的通信</span></p>\n<p>socket是一个非常简单的结构体，我们只需要知道对方的IP地址和端口号就可以使用socket建立连接来发送和接收数据。<br><img  src=\"/images/article/Games104/18/Games104_18_14.png\"  ><span class=\"image-caption\">套接字</span></p>\n<p>建立连接时需要额外注意到底是使用IPv4还是IPv6，使用TCP还是UDP协议等问题。<br><img  src=\"/images/article/Games104/18/Games104_18_15.png\"  ><span class=\"image-caption\">设置套接字</span></p>\n<h3 id=\"传输控制协议（-Transmission-Control-Protocol-TCP）\"><a href=\"#传输控制协议（-Transmission-Control-Protocol-TCP）\" class=\"headerlink\" title=\"传输控制协议（ Transmission Control Protocol - TCP）\"></a>传输控制协议（ Transmission Control Protocol - TCP）</h3><p>TCP是最经典也是著名的网络协议，它可以确保发送端发送的数据包都按照顺序被接收端接收。<br><img  src=\"/images/article/Games104/18/Games104_18_16.png\"  ><span class=\"image-caption\">TCP</span></p>\n<p>TCP的核心是<b>retransmission mechanism</b>，这个机制要求接收端收到消息后会向发送端发送一个ACK，而发送端只有接收到这个ACK之后才会继续发包。当然TCP实际使用的机制要比上述的过程复杂得多。<br><img  src=\"/images/article/Games104/18/Games104_18_17.png\"  ><span class=\"image-caption\">TCP重传机制</span></p>\n<p>当TCP出现网络拥堵时会主动调节单次发包的数量。如果发包都能顺利地接收到则会提高发包数量以提升效率，反之则会减少发包数量以提升稳定性。<br><img  src=\"/images/article/Games104/18/Games104_18_18.png\"  ><span class=\"image-caption\">TCP堵塞控制</span></p>\n<h3 id=\"用户数据报协议（-User-Datagram-Protocol-UDP）\"><a href=\"#用户数据报协议（-User-Datagram-Protocol-UDP）\" class=\"headerlink\" title=\"用户数据报协议（ User Datagram Protocol - UDP）\"></a>用户数据报协议（ User Datagram Protocol - UDP）</h3><p>除了TCP之外人们还开发出了UDP这样的轻量级网络协议。UDP的本质是一个端到端的网络协议，它不需要建立长时间的连接，也不要求发送数据的顺序，因此UDP要比TCP简单得多。<br><img  src=\"/images/article/Games104/18/Games104_18_19.png\"  ><span class=\"image-caption\">UDP</span><br><img  src=\"/images/article/Games104/18/Games104_18_20.png\"  ><span class=\"image-caption\">UDP功能</span></p>\n<p>在现代网络游戏中根据游戏类型的不同使用合适的网络协议，比如说对于实时性要求比较高的游戏会优先选择UDP，而策略类的游戏则会考虑使用TCP。在大型网络游戏中还可能会使用复合类型的协议来支持游戏中不同系统的通信需求。<br><img  src=\"/images/article/Games104/18/Games104_18_21.png\"  ><span class=\"image-caption\">UDP功能</span></p>\n<h3 id=\"可靠的-UDP（Reliable-UDP）\"><a href=\"#可靠的-UDP（Reliable-UDP）\" class=\"headerlink\" title=\"可靠的 UDP（Reliable UDP）\"></a>可靠的 UDP（Reliable UDP）</h3><p>同时现代网络游戏中往往还会对网络协议进行定制。以TCP为例，虽然TCP协议比较稳定但是效率过于低了，而且网络游戏中出现一定的丢包是可以接受的；而对于UDP来说它虽然非常高效但是却不够稳定。<br><img  src=\"/images/article/Games104/18/Games104_18_22.png\"  ><span class=\"image-caption\">TCP不是时间关键型</span><br><img  src=\"/images/article/Games104/18/Games104_18_23.png\"  ><span class=\"image-caption\">UDP的速度很快，但并不可靠</span></p>\n<p>因此现代网络游戏中往往会基于UDP来定制一个网络协议，这样既可以利用UDP的高效性又可以保证数据通信的有序性。<br><img  src=\"/images/article/Games104/18/Games104_18_24.png\"  ><span class=\"image-caption\">为什么我们需要定制协议</span></p>\n<p>ACK及其相关技术是保证数据可靠通信的基本方法。<br><img  src=\"/images/article/Games104/18/Games104_18_25.png\"  ><span class=\"image-caption\">确认信息和序列编号</span></p>\n<h4 id=\"自动重复请求（Automatic-Repeat-Request-ARQ）\"><a href=\"#自动重复请求（Automatic-Repeat-Request-ARQ）\" class=\"headerlink\" title=\"自动重复请求（Automatic Repeat Request - ARQ）\"></a>自动重复请求（Automatic Repeat Request - ARQ）</h4><p><b>ARQ(automatic repeat request)</b>是基于ACK的错误控制方法，所有的通信算法都要事项ARQ的功能。<br><img  src=\"/images/article/Games104/18/Games104_18_26.png\"  ><span class=\"image-caption\">ARQ</span></p>\n<h4 id=\"滑窗协议（Sliding-Window-Protocol）\"><a href=\"#滑窗协议（Sliding-Window-Protocol）\" class=\"headerlink\" title=\"滑窗协议（Sliding Window Protocol）\"></a>滑窗协议（Sliding Window Protocol）</h4><p><b>滑窗协议(sliding window protocol)</b>是经典的ARQ实现方法，它在发送数据时每次发送窗口大小的包然后检验回复的ACK来判断是否出现丢包的情况。<br><img  src=\"/images/article/Games104/18/Games104_18_27.png\"  ><span class=\"image-caption\">滑窗协议</span><br><img  src=\"/images/article/Games104/18/Games104_18_28.png\"  ><span class=\"image-caption\">滑窗协议2</span></p>\n<p>滑窗协议的一个缺陷在于它需要等待接收端的ACK才能继续发送数据，因此在很多情况下它无法完全利用带宽。<br><img  src=\"/images/article/Games104/18/Games104_18_29.png\"  ><span class=\"image-caption\">停止等待ARQ</span></p>\n<h4 id=\"回退n帧的自动重复请求（Go-Back-N-ARQ）\"><a href=\"#回退n帧的自动重复请求（Go-Back-N-ARQ）\" class=\"headerlink\" title=\"回退n帧的自动重复请求（Go-Back-N ARQ）\"></a>回退n帧的自动重复请求（Go-Back-N ARQ）</h4><p>对滑窗协议的一种改进方法是<b>Go-Back-N ARQ</b>，当出现丢包时它只会把窗口内的包重新发送。<br><img  src=\"/images/article/Games104/18/Games104_18_30.png\"  ><span class=\"image-caption\">Go-Back-N ARQ</span></p>\n<h4 id=\"选择性重复的ARQ（Selective-Repeat-ARQ）\"><a href=\"#选择性重复的ARQ（Selective-Repeat-ARQ）\" class=\"headerlink\" title=\"选择性重复的ARQ（Selective Repeat ARQ）\"></a>选择性重复的ARQ（Selective Repeat ARQ）</h4><p>另一种改进方法是<b>selective repeat ARQ</b>，它只会重新发送丢失或损坏的包从而进一步提升带宽的利用率。<br><img  src=\"/images/article/Games104/18/Games104_18_31.png\"  ><span class=\"image-caption\">Selective Repeat ARQ</span></p>\n<h4 id=\"前向纠错（Forward-Error-Correction）\"><a href=\"#前向纠错（Forward-Error-Correction）\" class=\"headerlink\" title=\"前向纠错（Forward Error Correction）\"></a>前向纠错（Forward Error Correction）</h4><p>在网络游戏中需要额外处理丢包的问题，因此我们在自定义网络协议时一般会结合<b>forward error correction(FEC)</b>的方法来避免数据的反复发送。<br><img  src=\"/images/article/Games104/18/Games104_18_32.png\"  ><span class=\"image-caption\">在丢包丢失场景中使UDP可靠</span><br><img  src=\"/images/article/Games104/18/Games104_18_33.png\"  ><span class=\"image-caption\">前向纠错</span></p>\n<p>目前常用的FEC算法包括异或校验位以及Reed-Solomon codes两大类。<br><img  src=\"/images/article/Games104/18/Games104_18_34.png\"  ><span class=\"image-caption\">前向纠错</span></p>\n<h4 id=\"异或（XOR-FEC）\"><a href=\"#异或（XOR-FEC）\" class=\"headerlink\" title=\"异或（XOR FEC）\"></a>异或（XOR FEC）</h4><p>异或校验位是使用<b>异或(XOR)</b>运算来恢复丢失数据的方法。这里需要注意的是当同时有多个包丢失时，使用异或校验位是无法恢复数据的。<br><img  src=\"/images/article/Games104/18/Games104_18_35.png\"  ><span class=\"image-caption\">异或</span><br><img  src=\"/images/article/Games104/18/Games104_18_36.png\"  ><span class=\"image-caption\">异或2</span></p>\n<h4 id=\"Reed-Solomon编码（Reed-Solomon-Codes）\"><a href=\"#Reed-Solomon编码（Reed-Solomon-Codes）\" class=\"headerlink\" title=\"Reed-Solomon编码（Reed-Solomon Codes）\"></a>Reed-Solomon编码（Reed-Solomon Codes）</h4><p><b>Reed-Solomon codes</b>是经典的信息传输算法，它利用Vandemode矩阵及其逆阵来恢复丢失的数据。<br><img  src=\"/images/article/Games104/18/Games104_18_37.png\"  ><span class=\"image-caption\">Reed-Solomon编码</span><br><img  src=\"/images/article/Games104/18/Games104_18_38.png\"  ><span class=\"image-caption\">Reed-Solomon编码2</span><br><img  src=\"/images/article/Games104/18/Games104_18_39.png\"  ><span class=\"image-caption\">Reed-Solomon编码3</span></p>\n<p>总结一下，在自定义UDP时需要考虑ARQ和FEC两类问题。<br><img  src=\"/images/article/Games104/18/Games104_18_40.png\"  ><span class=\"image-caption\">基于ARQ和FEC定制您的UDP</span></p>\n<h2 id=\"时钟同步（Clock-Synchronization）\"><a href=\"#时钟同步（Clock-Synchronization）\" class=\"headerlink\" title=\"时钟同步（Clock Synchronization）\"></a>时钟同步（Clock Synchronization）</h2><p>有了网络协议后就可以开始对网络游戏进行开发了，不过在具体设计游戏前我们还需要考虑不同玩家之间的<b>时钟同步(clock synchronization)</b>问题。</p>\n<h3 id=\"往返时间（Round-Trip-Time-RTT）\"><a href=\"#往返时间（Round-Trip-Time-RTT）\" class=\"headerlink\" title=\"往返时间（Round Trip Time - RTT）\"></a>往返时间（Round Trip Time - RTT）</h3><p>由于网络通信延迟的存在，客户端向服务器端发送一个包后都需要等待一定的时间才能收到回包，这个间隔的时间称为</b>round-trip time(RTT)<b>。RTT的概念类似于ping，不过它们的区别在于ping更加偏向于底层而RTT则位于顶部的应用层。<br><img  src=\"/images/article/Games104/18/Games104_18_41.png\"  ><span class=\"image-caption\">基于ARQ和FEC定制您的UDP</span></p>\n<h3 id=\"网络时间协议（Network-Time-Protocol）\"><a href=\"#网络时间协议（Network-Time-Protocol）\" class=\"headerlink\" title=\"网络时间协议（Network Time Protocol）\"></a>网络时间协议（Network Time Protocol）</h3><p>利用RTT就可以实现不同设备之间的时间同步。实际上不仅仅是网络游戏，现实生活中的各种电子设备进行同步都使用了RTT的技术。<br><img  src=\"/images/article/Games104/18/Games104_18_42.png\"  ><span class=\"image-caption\">网络时间协议</span></p>\n<p>在实际设备的时间同步过程中一般会利用层次化的结构来进行实现。<br><img  src=\"/images/article/Games104/18/Games104_18_43.png\"  ><span class=\"image-caption\">时间服务器层</span></p>\n<p>NTP的算法实际上非常简单，我们只需要从客户端发送请求然后从服务器接收一个时刻就好，这样就可以得到4个时间戳。如果我们进一步假定网络上行和下行的延迟是一致的，我们可以直接计算出RTT的时间长短以及两个设备之间的时间偏差。当然需要注意的是在实际中网络上行和下行的带宽往往是不一致的，因此这个算法也不是十分的严谨。<br><img  src=\"/images/article/Games104/18/Games104_18_44.png\"  ><span class=\"image-caption\">NTP算法</span><br><img  src=\"/images/article/Games104/18/Games104_18_45.png\"  ><span class=\"image-caption\">NTP算法2</span><br><img  src=\"/images/article/Games104/18/Games104_18_46.png\"  ><span class=\"image-caption\">NTP算法3</span></p>\n<p>实际上我们可以证明在不可靠的通信中是无法严格校准时间的。不过在实践中我们可以通过不断的使用NTP算法来得到一系列RTT值，然后把高于平均值50%的部分丢弃，剩下的RTT平均值的1.5倍就可以作为真实RTT的估计。<br><img  src=\"/images/article/Games104/18/Games104_18_47.png\"  ><span class=\"image-caption\">基于流的时间同步与消除更高阶模式</span><br><img  src=\"/images/article/Games104/18/Games104_18_48.png\"  ><span class=\"image-caption\">基于流的时间同步与消除更高阶模式2</span></p>\n<h2 id=\"远程过程调用（Remote-Procedure-Call-RPC）\"><a href=\"#远程过程调用（Remote-Procedure-Call-RPC）\" class=\"headerlink\" title=\"远程过程调用（Remote Procedure Call - RPC）\"></a>远程过程调用（Remote Procedure Call - RPC）</h2><h3 id=\"套接字编程（Socket-Programming）\"><a href=\"#套接字编程（Socket-Programming）\" class=\"headerlink\" title=\"套接字编程（Socket Programming）\"></a>套接字编程（Socket Programming）</h3><p>尽管利用socket我们可以实现客户端和服务器的通信，但对于网络游戏来说完全基于socket的通信是非常复杂的。这主要是因为网络游戏中客户端需要向服务器发送大量不同类型的消息，同时客户端也需要解析相应类型的反馈，这就会导致游戏逻辑变得无比复杂。<br><img  src=\"/images/article/Games104/18/Games104_18_49.png\"  ><span class=\"image-caption\">套接字编程：仍然不是很好</span><br><img  src=\"/images/article/Games104/18/Games104_18_50.png\"  ><span class=\"image-caption\">与消息通信</span><br><img  src=\"/images/article/Games104/18/Games104_18_51.png\"  ><span class=\"image-caption\">通信方式</span></p>\n<p>另一方面客户端和服务器往往有着不同的硬件和操作系统，这些差异会使得游戏逻辑更加复杂且难以调试。<br><img  src=\"/images/article/Games104/18/Games104_18_52.png\"  ><span class=\"image-caption\">逻辑通信所面临的更多挑战</span></p>\n<h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><p>因此在现代网络游戏中一般会使用<b>RPC(remote procedure call)</b>的方式来实现客户端和服务器的通信。基于RPC的技术在客户端可以像本地调用函数的方式来向服务器发送请求，这样使得开发人员可以专注于游戏逻辑而不是具体底层的实现。<br><img  src=\"/images/article/Games104/18/Games104_18_53.png\"  ><span class=\"image-caption\">RPC</span><br><img  src=\"/images/article/Games104/18/Games104_18_54.png\"  ><span class=\"image-caption\">RPC示例</span><br><img  src=\"/images/article/Games104/18/Games104_18_55.png\"  ><span class=\"image-caption\">为什么RPC？</span></p>\n<p>在RPC中会大量使用<b>IDL(interface definiton language)</b>来定义不同的消息形式。<br><img  src=\"/images/article/Games104/18/Games104_18_56.png\"  ><span class=\"image-caption\">IDL</span></p>\n<p>然后在启动时通过<b>RPC stubs</b>来通知客户端有哪些RPC是可以进行调用的。<br><img  src=\"/images/article/Games104/18/Games104_18_57.png\"  ><span class=\"image-caption\">RPC 存根</span><br><img  src=\"/images/article/Games104/18/Games104_18_58.png\"  ><span class=\"image-caption\">存根编译程序</span></p>\n<p>当然真实游戏中的RPC在实际进行调用时还有很多的消息处理和加密工作。<br><img  src=\"/images/article/Games104/18/Games104_18_59.png\"  ><span class=\"image-caption\">真正的RPC包之旅</span></p>\n<h2 id=\"网络拓扑（Network-Topology）\"><a href=\"#网络拓扑（Network-Topology）\" class=\"headerlink\" title=\"网络拓扑（Network Topology）\"></a>网络拓扑（Network Topology）</h2><h3 id=\"点对点（Peer-to-Peer-P2P）\"><a href=\"#点对点（Peer-to-Peer-P2P）\" class=\"headerlink\" title=\"点对点（Peer-to-Peer - P2P）\"></a>点对点（Peer-to-Peer - P2P）</h3><p>在设计网络游戏时还需要考虑网络自身的架构。最经典的网络架构是<b>P2P(peer-to-peer)</b>，此时每个客户端之间会直接建立通信。<br><img  src=\"/images/article/Games104/18/Games104_18_60.png\"  ><span class=\"image-caption\">P2P</span></p>\n<p>当P2P需要集中所有玩家的信息时则可以选择其中一个客户端作为主机，这样其它的客户端可以通过连接主机的方式来实现联机。<br><img  src=\"/images/article/Games104/18/Games104_18_61.png\"  ><span class=\"image-caption\">带主机服务器的P2P</span></p>\n<p>很多早期经典的游戏都是使用这样的网络架构来实现联网功能。<br><img  src=\"/images/article/Games104/18/Games104_18_62.png\"  ><span class=\"image-caption\">P2P游戏</span></p>\n<h3 id=\"专用服务器（Dedicated-Server）\"><a href=\"#专用服务器（Dedicated-Server）\" class=\"headerlink\" title=\"专用服务器（Dedicated Server）\"></a>专用服务器（Dedicated Server）</h3><p>在现代网络游戏中更多地会使用<b>dedicated server</b>这样的网络架构，此时网络中有一个专门的服务器向其它客户端提供服务。<br><img  src=\"/images/article/Games104/18/Games104_18_63.png\"  ><span class=\"image-caption\">专用服务器</span></p>\n<p>从实践结果来看，对于小型的网络游戏P2P是一个足够好的架构，而对于大型的商业网络游戏则必须使用dedicated server这样的形式。<br><img  src=\"/images/article/Games104/18/Games104_18_64.png\"  ><span class=\"image-caption\">P2P与专用服务器</span><br><img  src=\"/images/article/Games104/18/Games104_18_65.png\"  ><span class=\"image-caption\">当RTT太高时</span></p>\n<h2 id=\"游戏同步（Game-Synchronization）\"><a href=\"#游戏同步（Game-Synchronization）\" class=\"headerlink\" title=\"游戏同步（Game Synchronization）\"></a>游戏同步（Game Synchronization）</h2><p>在前面的课程中我们介绍过游戏世界是分层的。从玩家的角度来看，玩家的操作通过输入层一路向下到达游戏逻辑层，然后通过渲染器展示给玩家。<br><img  src=\"/images/article/Games104/18/Games104_18_66.png\"  ><span class=\"image-caption\">单人游戏</span></p>\n<p>而在网络游戏中，除了单机游戏都需要的分层外我们还需要考虑不同玩家之间的同步。在理想情况下我们希望客户端只负责处理玩家的输入，整个游戏逻辑都放在服务器端。<br><img  src=\"/images/article/Games104/18/Games104_18_67.png\"  ><span class=\"image-caption\">网络游戏</span></p>\n<p>由于延迟的存在，不同玩家视角下的对方可能会有不同的行为表现。<br><img  src=\"/images/article/Games104/18/Games104_18_68.png\"  ><span class=\"image-caption\">游戏同步</span></p>\n<p>因此我们需要使用游戏同步技术来保证玩家的游戏体验是一致的。目前常用的同步技术包括快照同步、帧同步以及状态同步等。<br><img  src=\"/images/article/Games104/18/Games104_18_69.png\"  ><span class=\"image-caption\">同步方法</span></p>\n<h3 id=\"快照同步（Snapshot-Synchronization）\"><a href=\"#快照同步（Snapshot-Synchronization）\" class=\"headerlink\" title=\"快照同步（Snapshot Synchronization）\"></a>快照同步（Snapshot Synchronization）</h3><p><b>快照同步(snapshot synchronization)</b>是一种相对古老的同步技术。在快照同步中客户端只负责向服务器发送当前玩家的数据，由服务器完成整个游戏世界的运行。然后服务器会为游戏世界生成一张快照，再发送给每个客户端来给玩家反馈。<br><img  src=\"/images/article/Games104/18/Games104_18_70.png\"  ><span class=\"image-caption\">快照同步</span></p>\n<p>快照同步可以严格保证每个玩家的状态都是准确的，但其缺陷在于它给服务器提出了非常巨大的挑战。因此在实际游戏中一般会降低服务器上游戏运行的帧率来平衡带宽，然后在客户端上通过插值的方式来获得高帧率。<br><img  src=\"/images/article/Games104/18/Games104_18_71.png\"  ><span class=\"image-caption\">快照同步-抖动和挂接</span><br><img  src=\"/images/article/Games104/18/Games104_18_72.png\"  ><span class=\"image-caption\">快照插值</span></p>\n<p>由于每次生成快照的成本是相对较高的，为了压缩数据我们可以使用状态的变化量来对游戏状态进行表示。<br><img  src=\"/images/article/Games104/18/Games104_18_73.png\"  ><span class=\"image-caption\">差值压缩</span><br><img  src=\"/images/article/Games104/18/Games104_18_74.png\"  ><span class=\"image-caption\">差值压缩2</span></p>\n<p>快照同步非常简单也易于实现，但它基本浪费掉了客户端上的算力同时在服务器上会产生过大的压力。因此在现代网络游戏中基本不会使用快照同步的方式。<br><img  src=\"/images/article/Games104/18/Games104_18_75.png\"  ><span class=\"image-caption\">快照同步</span></p>\n<h3 id=\"帧同步（Lockstep-Synchronization）\"><a href=\"#帧同步（Lockstep-Synchronization）\" class=\"headerlink\" title=\"帧同步（Lockstep Synchronization）\"></a>帧同步（Lockstep Synchronization）</h3><p><b>帧同步(lockstep synchronization)</b>是现代网络游戏中非常常用的同步技术。不同于快照同步完全通过服务器来运行游戏世界，在帧同步中服务器更多地是完成数据的分发工作。玩家的操作通过客户端发送到服务器上，经过服务器汇总后将当前游戏世界的状态返还给客户端，然后在每个客户端上运行游戏世界。<br><img  src=\"/images/article/Games104/18/Games104_18_76.png\"  ><span class=\"image-caption\">帧同步的在线游戏</span></p>\n<h4 id=\"帧同步初始化（Lockstep-Initialization）\"><a href=\"#帧同步初始化（Lockstep-Initialization）\" class=\"headerlink\" title=\"帧同步初始化（Lockstep Initialization）\"></a>帧同步初始化（Lockstep Initialization）</h4><p>使用帧同步时首先需要进行初始化，将客户端上所有的游戏数据与服务器进行同步。这一过程一般是在游戏loading阶段来实现的。<br><img  src=\"/images/article/Games104/18/Games104_18_77.png\"  ><span class=\"image-caption\">帧同步初始化</span></p>\n<h4 id=\"确定性的帧同步（Deterministic-Lockstep）\"><a href=\"#确定性的帧同步（Deterministic-Lockstep）\" class=\"headerlink\" title=\"确定性的帧同步（Deterministic Lockstep）\"></a>确定性的帧同步（Deterministic Lockstep）</h4><p>在游戏过程中客户端会在每一帧将玩家数据发送到服务器上，服务器接收到所有玩家的数据后再统一转发到玩家客户端上，然后由玩家客户端执行游戏逻辑。当然这种同步方式也存在一定的缺陷，当某个玩家的数据滞后了所有玩家都必须要进行等待。这种情况在一些早期的联网游戏中都很常见。<br><img  src=\"/images/article/Games104/18/Games104_18_78.png\"  ><span class=\"image-caption\">确定性的帧同步</span><br><img  src=\"/images/article/Games104/18/Games104_18_79.png\"  ><span class=\"image-caption\">确定性的帧同步2</span><br><img  src=\"/images/article/Games104/18/Games104_18_80.png\"  ><span class=\"image-caption\">玩家脱机在确定性的锁定步骤</span></p>\n<h4 id=\"存储桶同步（Bucket-Synchronization）\"><a href=\"#存储桶同步（Bucket-Synchronization）\" class=\"headerlink\" title=\"存储桶同步（Bucket Synchronization）\"></a>存储桶同步（Bucket Synchronization）</h4><p>为了克服这样的问题，人们提出了<b>bucket synchronization</b>这样的策略。此时服务器只会等待bucket长度的时间，如果超时没有收到客户端发来的数据就越过去，看下一个bucket时间段能否接收到。通过这样的方式其它玩家就无需一直等待了。<br><img  src=\"/images/article/Games104/18/Games104_18_81.png\"  ><span class=\"image-caption\">存储桶同步</span></p>\n<p>bucket synchronization本质是对玩家数据的一致性以及游戏体验进行的一种权衡。<br><img  src=\"/images/article/Games104/18/Games104_18_82.png\"  ><span class=\"image-caption\">在一致性和交互性维护之间的良好权衡</span></p>\n<h4 id=\"确定性困难（Deterministic-Difficulties）\"><a href=\"#确定性困难（Deterministic-Difficulties）\" class=\"headerlink\" title=\"确定性困难（Deterministic Difficulties）\"></a>确定性困难（Deterministic Difficulties）</h4><p>帧同步的一大难点在于它要保证不同客户端上游戏世界在相同输入的情况下有着完全一致的输出。<br><img  src=\"/images/article/Games104/18/Games104_18_83.png\"  ><span class=\"image-caption\">确定性困难</span></p>\n<p>为了保证输出的确定性我们首先要保证浮点数在不同客户端上的一致性，这可以使用IEEE 754标准来实现。<br><img  src=\"/images/article/Games104/18/Games104_18_84.png\"  ><span class=\"image-caption\">浮点数</span></p>\n<p>其次在不同的设备上我们需要保证相关的数学运算函数有一致的行为，对于这种问题则可以使用查表的方式来避免实际的计算。<br><img  src=\"/images/article/Games104/18/Games104_18_85.png\"  ><span class=\"image-caption\">浮点数2</span><br><img  src=\"/images/article/Games104/18/Games104_18_86.png\"  ><span class=\"image-caption\">浮点数3</span></p>\n<p>除此之外还可以使用定点数来替换浮点数，从而避免浮点数导致的各种问题。<br><img  src=\"/images/article/Games104/18/Games104_18_87.png\"  ><span class=\"image-caption\">浮点数4</span></p>\n<p>除了浮点数之外还要考虑随机数的问题，我们要求随机数在不同的客户端上也必须是完全一致的。因此在游戏客户端和服务器进行同步时需要将随机数种子以及随机数生成算法进行同步。<br><img  src=\"/images/article/Games104/18/Games104_18_88.png\"  ><span class=\"image-caption\">随机数</span><br><img  src=\"/images/article/Games104/18/Games104_18_89.png\"  ><span class=\"image-caption\">随机数2</span></p>\n<p>总结一下，保证客户端上游戏世界模拟一致的常用方法如下：<br><img  src=\"/images/article/Games104/18/Games104_18_90.png\"  ><span class=\"image-caption\">确定性困难</span></p>\n<h4 id=\"跟踪和调试（Tracing-and-Debugging）\"><a href=\"#跟踪和调试（Tracing-and-Debugging）\" class=\"headerlink\" title=\"跟踪和调试（Tracing and Debugging）\"></a>跟踪和调试（Tracing and Debugging）</h4><p>现代网络游戏的逻辑往往非常复杂，在玩家进行游玩时可能无法避免地出现一些bug，因此对于服务器来说检测客户端发送的数据是否存在bug就非常重要。一般来说我们会要求客户端每隔一段时间就上传本地的log，由服务器来检查上传数据是否存在bug。<br><img  src=\"/images/article/Games104/18/Games104_18_91.png\"  ><span class=\"image-caption\">跟踪和调试</span></p>\n<h4 id=\"滞后和延迟（Lag-and-Delay）\"><a href=\"#滞后和延迟（Lag-and-Delay）\" class=\"headerlink\" title=\"滞后和延迟（Lag and Delay）\"></a>滞后和延迟（Lag and Delay）</h4><p>为了处理网络延迟的问题我们还可以在客户端上缓存若干帧，当然缓存的大小会在一定程度上影响玩家的游戏体验。<br><img  src=\"/images/article/Games104/18/Games104_18_92.png\"  ><span class=\"image-caption\">滞后和延迟</span></p>\n<p>另一方面我们还可以把游戏逻辑帧和渲染帧进行分离，然后通过插值的方式来获得更加平滑的渲染效果。<br><img  src=\"/images/article/Games104/18/Games104_18_93.png\"  ><span class=\"image-caption\">区分游戏逻辑和渲染功能</span><br><img  src=\"/images/article/Games104/18/Games104_18_94.png\"  ><span class=\"image-caption\">区分游戏逻辑和渲染功能2</span></p>\n<h4 id=\"重新连接问题（Reconnection-Problem）\"><a href=\"#重新连接问题（Reconnection-Problem）\" class=\"headerlink\" title=\"重新连接问题（Reconnection Problem）\"></a>重新连接问题（Reconnection Problem）</h4><p>由于网络的不稳定，玩家可能会不可避免地遇到断线的情况，此时我们还需要设计断线重连的机制。<br><img  src=\"/images/article/Games104/18/Games104_18_95.png\"  ><span class=\"image-caption\">重新连接问题</span></p>\n<p>实际上再进行帧同步时每个若干帧会设置一个关键帧。在关键帧进行同步时还会更新游戏世界的快照，这样可保证即使游戏崩溃了也可以从快照中恢复。<br><img  src=\"/images/article/Games104/18/Games104_18_96.png\"  ><span class=\"image-caption\">客户端游戏状态快照</span></p>\n<p>为了实现这样的功能可以使用<b>quick catch up</b>技术，此时我们暂停游戏的渲染把所有的计算资源用来执行游戏逻辑。<br><img  src=\"/images/article/Games104/18/Games104_18_97.png\"  ><span class=\"image-caption\">快速追赶</span></p>\n<p>而在服务器端也可以使用类似的技术，从而帮助掉线的玩家快速恢复到游戏的当前状态。实际上网络游戏的观战和回放功能也是使用这样的技术来实现的。<br><img  src=\"/images/article/Games104/18/Games104_18_98.png\"  ><span class=\"image-caption\">服务器状态快照优化</span><br><img  src=\"/images/article/Games104/18/Games104_18_99.png\"  ><span class=\"image-caption\">临时脱机，无崩溃</span><br><img  src=\"/images/article/Games104/18/Games104_18_100.png\"  ><span class=\"image-caption\">观战</span><br><img  src=\"/images/article/Games104/18/Games104_18_101.png\"  ><span class=\"image-caption\">重播</span></p>\n<h4 id=\"帧同步作弊问题（Lockstep-Cheating-Issues）\"><a href=\"#帧同步作弊问题（Lockstep-Cheating-Issues）\" class=\"headerlink\" title=\"帧同步作弊问题（Lockstep Cheating Issues）\"></a>帧同步作弊问题（Lockstep Cheating Issues）</h4><p>网络游戏中作弊行为的检查是非常重要的。对于帧同步的游戏，玩家可以通过发送虚假的状态来实现作弊行为，这就要求我们实现一些反作弊机制。<br><img  src=\"/images/article/Games104/18/Games104_18_102.png\"  ><span class=\"image-caption\">帧同步作弊问题</span><br><img  src=\"/images/article/Games104/18/Games104_18_103.png\"  ><span class=\"image-caption\">帧同步作弊问题2</span><br><img  src=\"/images/article/Games104/18/Games104_18_104.png\"  ><span class=\"image-caption\">帧同步作弊问题3</span></p>\n<h4 id=\"帧同步总结（Lockstep-Summary）\"><a href=\"#帧同步总结（Lockstep-Summary）\" class=\"headerlink\" title=\"帧同步总结（Lockstep Summary）\"></a>帧同步总结（Lockstep Summary）</h4><p>总结一下，帧同步会占用更少的带宽也比较适合各种需要实时反馈的游戏。而帧同步的难点主要集中在如何保证在不同客户端上游戏运行的一致性，如何设计断线重连机制等。<br><img  src=\"/images/article/Games104/18/Games104_18_105.png\"  ><span class=\"image-caption\">帧同步总结</span><br><img  src=\"/images/article/Games104/18/Games104_18_106.png\"  ><span class=\"image-caption\">帧同步总结2</span></p>\n<h3 id=\"状态同步（State-Synchronization）\"><a href=\"#状态同步（State-Synchronization）\" class=\"headerlink\" title=\"状态同步（State Synchronization）\"></a>状态同步（State Synchronization）</h3><p><b>状态同步(state synchronization)</b>是目前大型网游非常流行的同步技术，它的基本思想是把玩家的状态和事件进行同步。<br><img  src=\"/images/article/Games104/18/Games104_18_107.png\"  ><span class=\"image-caption\">状态同步</span><br><img  src=\"/images/article/Games104/18/Games104_18_108.png\"  ><span class=\"image-caption\">状态同步2</span></p>\n<p>进行状态同步时由客户端提交玩家的状态数据，而服务器则会在收集到所有玩家的数据后运行游戏逻辑，然后把下一时刻的状态分发给所有的客户端。<br><img  src=\"/images/article/Games104/18/Games104_18_109.png\"  ><span class=\"image-caption\">状态同步3</span><br><img  src=\"/images/article/Games104/18/Games104_18_110.png\"  ><span class=\"image-caption\">服务器授权的游戏世界</span></p>\n<h4 id=\"授权和复制的客户端（Authorized-and-Replicated-Clients）\"><a href=\"#授权和复制的客户端（Authorized-and-Replicated-Clients）\" class=\"headerlink\" title=\"授权和复制的客户端（Authorized and Replicated Clients）\"></a>授权和复制的客户端（Authorized and Replicated Clients）</h4><p>状态同步中服务器称为<b>authorized server</b>，它是整个游戏世界的绝对权威；而玩家的本地客户端称为<b>authorized client</b>，它是玩家操作游戏角色的接口；在其他玩家视角下的同一角色则称为<b>replicated client</b>，表示它们仅仅是authorized client的一个副本。<br><img  src=\"/images/article/Games104/18/Games104_18_111.png\"  ><span class=\"image-caption\">授权和复制的客户端</span></p>\n<h4 id=\"状态同步示例（State-Synchronization-Example）\"><a href=\"#状态同步示例（State-Synchronization-Example）\" class=\"headerlink\" title=\"状态同步示例（State Synchronization Example）\"></a>状态同步示例（State Synchronization Example）</h4><p>当authorized client执行了某种行为时首先会向服务发送相关的数据，然后由服务器驱动游戏逻辑并把相应的状态发布给所有的玩家。当其他客户端接收到更新后的状态时，再驱动replicated client执行authorized client的行为。类似地，authorized client行为产生的后果也是由服务器进行计算再发布给所有的客户端。这样的好处在于我们无需要求每个客户端上的模拟是严格一致的，整个游戏世界本质上仍然是由统一的服务器进行驱动。<br><img  src=\"/images/article/Games104/18/Games104_18_112.png\"  ><span class=\"image-caption\">状态同步示例</span><br><img  src=\"/images/article/Games104/18/Games104_18_113.png\"  ><span class=\"image-caption\">状态同步示例2</span><br><img  src=\"/images/article/Games104/18/Games104_18_114.png\"  ><span class=\"image-caption\">状态同步示例3</span><br><img  src=\"/images/article/Games104/18/Games104_18_115.png\"  ><span class=\"image-caption\">状态同步示例4</span></p>\n<h4 id=\"滞后的客户端问题（Dumb-Client-Problem）\"><a href=\"#滞后的客户端问题（Dumb-Client-Problem）\" class=\"headerlink\" title=\"滞后的客户端问题（Dumb Client Problem）\"></a>滞后的客户端问题（Dumb Client Problem）</h4><p>由于游戏角色的所有行为都需要经过服务器的确认才能执行，状态同步会产生</b>dumb client<b>的问题，即玩家视角下角色的行为可能是滞后的。<br><img  src=\"/images/article/Games104/18/Games104_18_116.png\"  ><span class=\"image-caption\">滞后的客户端问题</span></p>\n<p>要缓解这样的问题可以在客户端上对玩家的行为进行预测。比如说当角色需要进行移动时首先在本地移动半步，然后等服务器传来确定的消息后再进行对齐，这样就可以改善玩家的游戏体验。在守望先锋中就使用了这样的方式来保证玩家顺畅的游玩。<br><img  src=\"/images/article/Games104/18/Games104_18_117.png\"  ><span class=\"image-caption\">客户端预测</span><br><img  src=\"/images/article/Games104/18/Games104_18_118.png\"  ><span class=\"image-caption\">监督-客户端预测</span></p>\n<p>由于网络波动的存在，来自服务器的确认消息往往会滞后于本地的预测。因此我们可以使用一个buffer来缓存游戏角色的状态，这样当收到服务器的消息时首先跟buffer中的状态进行检验。当buffer中的状态和服务器的数据不一致时就需要根据服务器的数据来矫正玩家状态。<br><img  src=\"/images/article/Games104/18/Games104_18_119.png\"  ><span class=\"image-caption\">服务器调整</span><br><img  src=\"/images/article/Games104/18/Games104_18_120.png\"  ><span class=\"image-caption\">服务器调整2</span><br><img  src=\"/images/article/Games104/18/Games104_18_121.png\"  ><span class=\"image-caption\">服务器调整3</span><br><img  src=\"/images/article/Games104/18/Games104_18_122.png\"  ><span class=\"image-caption\">服务器调整4</span></p>\n<p>当然这样的机制对于网络条件不好的玩家是不太公平的，他们的角色状态会不断地被服务器修正。<br><img  src=\"/images/article/Games104/18/Games104_18_123.png\"  ><span class=\"image-caption\">服务器对齐示例</span></p>\n<h4 id=\"丢包（Packet-Loss）\"><a href=\"#丢包（Packet-Loss）\" class=\"headerlink\" title=\"丢包（Packet Loss）\"></a>丢包（Packet Loss）</h4><p>对于丢包的问题在服务器端也会维护一个小的buffer来储存玩家的状态。如果buffer被清空则说明可能出现了掉线的情况，此时服务器会复制玩家上一个输入来维持游戏的运行。<br><img  src=\"/images/article/Games104/18/Games104_18_124.png\"  ><span class=\"image-caption\">丢包</span></p>\n<p>帧同步和状态同步两种主流同步技术的对比如下：<br><img  src=\"/images/article/Games104/18/Games104_18_125.png\"  ><span class=\"image-caption\">状态同步与帧同步</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/08/10/GAMES104-NOTES-18.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1La411o7kG/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1HN4y157Zq/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频2</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_PPT_Lecture%2018_Online%20Gaming%20Architecture-Fundamentals.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}