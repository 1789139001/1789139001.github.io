{"title":"现代游戏引擎 - 游戏引擎中物理系统的高级应用（十一）","slug":"Games104/11_Physics System_Applications","date":"2023-03-21T14:20:04.000Z","updated":"2023-11-29T02:42:01.739Z","comments":true,"path":"api/articles/Games104/11_Physics System_Applications.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/11/Games104_11_01.png","/images/article/Games104/11/Games104_11_02.png","/images/article/Games104/11/Games104_11_03.png","/images/article/Games104/11/Games104_11_04.png","/images/article/Games104/11/Games104_11_05.png","/images/article/Games104/11/Games104_11_06.png","/images/article/Games104/11/Games104_11_07.png","/images/article/Games104/11/Games104_11_08.png","/images/article/Games104/11/Games104_11_09.png","/images/article/Games104/11/Games104_11_10.png","/images/article/Games104/11/Games104_11_11.png","/images/article/Games104/11/Games104_11_13.png","/images/article/Games104/11/Games104_11_15.png","/images/article/Games104/11/Games104_11_16.png","/images/article/Games104/11/Games104_11_17.png","/images/article/Games104/11/Games104_11_18.png","/images/article/Games104/11/Games104_11_19.png","/images/article/Games104/11/Games104_11_20.png","/images/article/Games104/11/Games104_11_21.png","/images/article/Games104/11/Games104_11_22.png","/images/article/Games104/11/Games104_11_23.png","/images/article/Games104/11/Games104_11_24.png","/images/article/Games104/11/Games104_11_25.png","/images/article/Games104/11/Games104_11_26.png","/images/article/Games104/11/Games104_11_27.png","/images/article/Games104/11/Games104_11_29.png","/images/article/Games104/11/Games104_11_30.png","/images/article/Games104/11/Games104_11_31.png","/images/article/Games104/11/Games104_11_33.png","/images/article/Games104/11/Games104_11_35.png","/images/article/Games104/11/Games104_11_37.png","/images/article/Games104/11/Games104_11_39.png","/images/article/Games104/11/Games104_11_40.png","/images/article/Games104/11/Games104_11_41.png","/images/article/Games104/11/Games104_11_42.png","/images/article/Games104/11/Games104_11_43.png","/images/article/Games104/11/Games104_11_45.png","/images/article/Games104/11/Games104_11_46.png","/images/article/Games104/11/Games104_11_47.png","/images/article/Games104/11/Games104_11_48.png","/images/article/Games104/11/Games104_11_49.png","/images/article/Games104/11/Games104_11_52.png","/images/article/Games104/11/Games104_11_53.png","/images/article/Games104/11/Games104_11_54.png","/images/article/Games104/11/Games104_11_55.png","/images/article/Games104/11/Games104_11_56.png","/images/article/Games104/11/Games104_11_57.png","/images/article/Games104/11/Games104_11_58.png","/images/article/Games104/11/Games104_11_60.png","/images/article/Games104/11/Games104_11_66.png","/images/article/Games104/11/Games104_11_67.png"],"cover":"/images/background/Physics-System-Application.jpg","content":"<h2 id=\"角色控制器（Character-Controller）\"><a href=\"#角色控制器（Character-Controller）\" class=\"headerlink\" title=\"角色控制器（Character Controller）\"></a>角色控制器（Character Controller）</h2><p><b>角色控制器(character controller)</b>是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，<br>角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，<br>而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。<br><img src=\"/images/article/Games104/11/Games104_11_01.png\"><span class=\"image-caption\">角色控制 VS 刚体动力学</span></p>\n<h3 id=\"构建一个控制器（Build-a-Controller-in-Physics-System）\"><a href=\"#构建一个控制器（Build-a-Controller-in-Physics-System）\" class=\"headerlink\" title=\"构建一个控制器（Build a Controller in Physics System）\"></a>构建一个控制器（Build a Controller in Physics System）</h3><p>在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。<br><img src=\"/images/article/Games104/11/Games104_11_02.png\"><span class=\"image-caption\">构建控制器</span></p>\n<h3 id=\"与环境碰撞（Collide-with-Environment）\"><a href=\"#与环境碰撞（Collide-with-Environment）\" class=\"headerlink\" title=\"与环境碰撞（Collide with Environment）\"></a>与环境碰撞（Collide with Environment）</h3><p>在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；<br>而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。<br><img src=\"/images/article/Games104/11/Games104_11_03.png\"><span class=\"image-caption\">与环境碰撞</span></p>\n<h3 id=\"自动步进及其问题（Auto-Stepping）\"><a href=\"#自动步进及其问题（Auto-Stepping）\" class=\"headerlink\" title=\"自动步进及其问题（Auto Stepping）\"></a>自动步进及其问题（Auto Stepping）</h3><p>上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。<br>因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。<br><img src=\"/images/article/Games104/11/Games104_11_04.png\"><span class=\"image-caption\">自动步进及其问题</span></p>\n<p>对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，<br>或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。<br>为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。<br><img src=\"/images/article/Games104/11/Games104_11_05.png\"><span class=\"image-caption\">坡度限制和作用力向下滑动</span></p>\n<h3 id=\"控制器卷更新（Controller-Volume-Update）\"><a href=\"#控制器卷更新（Controller-Volume-Update）\" class=\"headerlink\" title=\"控制器卷更新（Controller Volume Update）\"></a>控制器卷更新（Controller Volume Update）</h3><p>角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，<br>否则容易出现角色卡在门口无法进入的问题。<br><img src=\"/images/article/Games104/11/Games104_11_06.png\"><span class=\"image-caption\">控制器卷更新</span></p>\n<h3 id=\"控制器推送对象（Controller-Push-Objects）\"><a href=\"#控制器推送对象（Controller-Push-Objects）\" class=\"headerlink\" title=\"控制器推送对象（Controller Push Objects）\"></a>控制器推送对象（Controller Push Objects）</h3><p>当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。<br>比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。<br><img src=\"/images/article/Games104/11/Games104_11_07.png\"><span class=\"image-caption\">控制器推送对象</span></p>\n<h3 id=\"站在移动平台上（Standing-on-Moving-Platform）\"><a href=\"#站在移动平台上（Standing-on-Moving-Platform）\" class=\"headerlink\" title=\"站在移动平台上（Standing on Moving Platform）\"></a>站在移动平台上（Standing on Moving Platform）</h3><p>除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，<br>否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。<br><img src=\"/images/article/Games104/11/Games104_11_08.png\"><span class=\"image-caption\">站在移动平台上</span></p>\n<h2 id=\"布娃娃系统（Ragdoll）\"><a href=\"#布娃娃系统（Ragdoll）\" class=\"headerlink\" title=\"布娃娃系统（Ragdoll）\"></a>布娃娃系统（Ragdoll）</h2><p><b>布娃娃(Ragdoll)</b>系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：<br>当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。<br><img src=\"/images/article/Games104/11/Games104_11_09.png\"><span class=\"image-caption\">为什么要使用布偶</span></p>\n<h3 id=\"将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies\"><a href=\"#将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies\" class=\"headerlink\" title=\"将骨架映射到刚体(Map Skeleton to Rigid Bodies)\"></a>将骨架映射到刚体(Map Skeleton to Rigid Bodies)</h3><p>实际上ragdoll与前面介绍过的<a href=\"/posts/b1eb3151.html#骨骼动画-amp-蒙皮\"><b><font color=\"red\">骨骼动画</font></b></a>密切相关。在模拟ragdoll的运动时，<br>我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。<br>不过出于实时计算上的考虑，ragdoll一般只会使用非常少量的节点和骨骼来进行模拟。<br><img src=\"/images/article/Games104/11/Games104_11_10.png\"><span class=\"image-caption\">将骨架映射到刚体</span></p>\n<h3 id=\"人体关节约束（Human-Joint-Constraints）\"><a href=\"#人体关节约束（Human-Joint-Constraints）\" class=\"headerlink\" title=\"人体关节约束（Human Joint Constraints）\"></a>人体关节约束（Human Joint Constraints）</h3><p>同样地，在ragdoll中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。<br><img src=\"/images/article/Games104/11/Games104_11_11.png\"><span class=\"image-caption\">人体关节约束</span><br><img src=\"/images/article/Games104/11/Games104_11_12.png\"><span class=\"image-caption\">联合约束的重要性</span></p>\n<p>一般来说ragdoll关节的约束会由TA进行设置，如果设置的不好会出现一些反直觉的动画效果。<br><img src=\"/images/article/Games104/11/Games104_11_13.png\"><span class=\"image-caption\">约束属性</span><br><img src=\"/images/article/Games104/11/Games104_11_14.png\"><span class=\"image-caption\">精心调整约束</span></p>\n<h3 id=\"布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）\"><a href=\"#布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）\" class=\"headerlink\" title=\"布娃娃的骨架动画（Animating Skeleton by Ragdoll）\"></a>布娃娃的骨架动画（Animating Skeleton by Ragdoll）</h3><p>需要注意的是尽管我们可以使用ragdoll来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。<br>由于ragdoll中的骨骼关节数量一般会少于实际角色的骨骼关节，<br>我们需要使用<a href=\"/posts/649819f1.html#动画重定向（Animation-Retargeting）\"><b><font color=\"red\">动画重定向</font></b></a>技术来将ragdoll计算出的运动映射到实际的角色骨骼上。<br><img src=\"/images/article/Games104/11/Games104_11_15.png\"><span class=\"image-caption\">布娃娃的骨架动画</span></p>\n<h3 id=\"混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）\"><a href=\"#混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）\" class=\"headerlink\" title=\"混合动画和布娃娃（Blending between Animation and Ragdoll）\"></a>混合动画和布娃娃（Blending between Animation and Ragdoll）</h3><p>在使用时还需要注意角色动画切换到ragdoll的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，<br>然后在某一时刻会切换成ragdoll使用物理系统来实时计算角色的行为。<br><img src=\"/images/article/Games104/11/Games104_11_16.png\"><span class=\"image-caption\">混合动画和布娃娃</span></p>\n<p>更进一步，在现代3A游戏中还会将角色动画和ragdoll实时计算出的动画进行混合来提升玩家的代入感和游戏体验。<br><img src=\"/images/article/Games104/11/Games104_11_17.png\"><span class=\"image-caption\">物理动画混合</span></p>\n<h2 id=\"衣料模拟（Cloth）\"><a href=\"#衣料模拟（Cloth）\" class=\"headerlink\" title=\"衣料模拟（Cloth）\"></a>衣料模拟（Cloth）</h2><p>布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，<br>我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，<br>这样就可以实现角色执行不同动作时衣物随之飘动的效果。<br><img src=\"/images/article/Games104/11/Games104_11_18.png\"><span class=\"image-caption\">基于动画的布料模拟</span></p>\n<p>另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。<br>这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。<br><img src=\"/images/article/Games104/11/Games104_11_19.png\"><span class=\"image-caption\">基于刚体的布料模拟</span></p>\n<h3 id=\"基于网格的布料模拟（Mesh-Based-Cloth-Simulation）\"><a href=\"#基于网格的布料模拟（Mesh-Based-Cloth-Simulation）\" class=\"headerlink\" title=\"基于网格的布料模拟（Mesh-Based Cloth Simulation）\"></a>基于网格的布料模拟（Mesh-Based Cloth Simulation）</h3><p>而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，<br>出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。<br><img src=\"/images/article/Games104/11/Games104_11_20.png\"><span class=\"image-caption\">渲染网格 VS 物理网格</span></p>\n<p>同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。<br><img src=\"/images/article/Games104/11/Games104_11_21.png\"><span class=\"image-caption\">布料模拟约束条件</span></p>\n<h3 id=\"质量弹簧系统（Mass-Spring-System）\"><a href=\"#质量弹簧系统（Mass-Spring-System）\" class=\"headerlink\" title=\"质量弹簧系统（Mass-Spring System）\"></a>质量弹簧系统（Mass-Spring System）</h3><p>使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。<br>这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。<br><img src=\"/images/article/Games104/11/Games104_11_22.png\"><span class=\"image-caption\">质量弹簧系统</span></p>\n<p>在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。<br><img src=\"/images/article/Games104/11/Games104_11_23.png\"><span class=\"image-caption\">质量弹簧系统2</span></p>\n<p>最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。<br><img src=\"/images/article/Games104/11/Games104_11_24.png\"><span class=\"image-caption\">质量弹簧系统3</span></p>\n<h3 id=\"韦尔莱积分（Verlet-Integration）\"><a href=\"#韦尔莱积分（Verlet-Integration）\" class=\"headerlink\" title=\"韦尔莱积分（Verlet Integration）\"></a>韦尔莱积分（Verlet Integration）</h3><p>对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些Verlet积分算法。Verlet积分本质仍然是半隐式欧拉积分，<br>不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此Verlet积分不需要保存每一时刻的速度，<br>我们只需要位移和力(加速度)就可以进行计算，从而提高布料仿真的效率。<br><img src=\"/images/article/Games104/11/Games104_11_25.png\"><span class=\"image-caption\">韦尔莱积分</span></p>\n<h3 id=\"自相交（Self-Collision）\"><a href=\"#自相交（Self-Collision）\" class=\"headerlink\" title=\"自相交（Self Collision）\"></a>自相交（Self Collision）</h3><p>布料仿真的一大难点在于如何处理<b>自相交(self collision)</b>问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。<br><img src=\"/images/article/Games104/11/Games104_11_26.png\"><span class=\"image-caption\">自相交</span></p>\n<p>目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些trick来缓解自相交的问题，<br>比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用SDF进行控制等。<br><img src=\"/images/article/Games104/11/Games104_11_27.png\"><span class=\"image-caption\">自相交的常见解决方案</span><br><img src=\"/images/article/Games104/11/Games104_11_28.png\"><span class=\"image-caption\">自相交的常见解决方案2</span></p>\n<h2 id=\"破坏模拟（Destruction）\"><a href=\"#破坏模拟（Destruction）\" class=\"headerlink\" title=\"破坏模拟（Destruction）\"></a>破坏模拟（Destruction）</h2><p>玩家对场景的破坏是通过破坏系统来进行实现。一个好的破坏系统可以极大地提升玩家的游戏体验，有些游戏甚至是以破坏系统为核心玩法进行设计的。<br><img src=\"/images/article/Games104/11/Games104_11_29.png\"><span class=\"image-caption\">破坏的重要性</span></p>\n<h3 id=\"区块层次结构（Chunk-Hierarchy）\"><a href=\"#区块层次结构（Chunk-Hierarchy）\" class=\"headerlink\" title=\"区块层次结构（Chunk Hierarchy）\"></a>区块层次结构（Chunk Hierarchy）</h3><p>我们可以使用一棵树来描述同一物体不同碎片之间的层次关系：树的根节点表示完整的物体，而它下面的每一层表示物体经受一定程度的冲击后所产生的碎片。<br><img src=\"/images/article/Games104/11/Games104_11_30.png\"><span class=\"image-caption\">区块层次结构</span></p>\n<h3 id=\"连通性图（Connectivity-Graph）\"><a href=\"#连通性图（Connectivity-Graph）\" class=\"headerlink\" title=\"连通性图（Connectivity Graph）\"></a>连通性图（Connectivity Graph）</h3><p>当确定了物体承受的冲击后就可以使用一张图来表示不同碎片之间的连接关系：图的节点表示碎片，<br>而图的边则表示相互连接的碎片能够承受的荷载，当冲击大于边上的值时就会发生物体的破碎。<br><img src=\"/images/article/Games104/11/Games104_11_31.png\"><span class=\"image-caption\">连通性图</span><br><img src=\"/images/article/Games104/11/Games104_11_32.png\"><span class=\"image-caption\">连通性值</span></p>\n<h3 id=\"损坏计算（Damage-Calculation）\"><a href=\"#损坏计算（Damage-Calculation）\" class=\"headerlink\" title=\"损坏计算（Damage Calculation）\"></a>损坏计算（Damage Calculation）</h3><p>需要说明的是虽然我们使用了冲击和荷载这样的字眼，实际上在游戏引擎中却不会去计算这些物理量。<br>它们只是一些人工设置的数值，并不具备真实的物理意义。在游戏开发中一般会使用一些经验公式来对冲击以及物体的承载力进行计算。<br><img src=\"/images/article/Games104/11/Games104_11_33.png\"><span class=\"image-caption\">损坏计算</span><br><img src=\"/images/article/Games104/11/Games104_11_34.png\"><span class=\"image-caption\">损坏计算2</span></p>\n<h3 id=\"沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）\"><a href=\"#沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）\" class=\"headerlink\" title=\"沃罗诺伊图压裂（Fracturing with Voronoi Diagram）\"></a>沃罗诺伊图压裂（Fracturing with Voronoi Diagram）</h3><p>那么如何去生成这样的一张图呢？在物理引擎中一般会使用<b>沃罗诺伊图(Voronoi diagram)</b>这样的技术来对原始的物体区域进行划分，<br>划分后的每一个区域即为所需的碎片。<br><img src=\"/images/article/Games104/11/Games104_11_35.png\"><span class=\"image-caption\">通过沃罗诺伊图构建块</span><br><img src=\"/images/article/Games104/11/Games104_11_36.png\"><span class=\"image-caption\">沃罗诺伊图 - 2D网格</span></p>\n<p>对于三维的情况则要更加复杂一些，除了需要使用Voronoi图对空间进行划分还需要使用Delaunay三角化来重新生成碎片的三维网格。<br>同时当物体破碎后还需要为碎片的网格赋予内部材质的纹理，这一般需要使用一些程序化的纹理生成算法。<br><img src=\"/images/article/Games104/11/Games104_11_37.png\"><span class=\"image-caption\">沃罗诺伊图 - 3D网格</span><br><img src=\"/images/article/Games104/11/Games104_11_38.png\"><span class=\"image-caption\">沃罗诺伊图 - 3D网格2</span></p>\n<p>在设置Voronoi图的种子时还可以根据需要设置不同模式的种子，这样可以实现相应的破碎效果。<br><img src=\"/images/article/Games104/11/Games104_11_39.png\"><span class=\"image-caption\">不同的沃罗诺伊图</span></p>\n<h3 id=\"物理系统中的破坏（Destruction-in-Physics-System）\"><a href=\"#物理系统中的破坏（Destruction-in-Physics-System）\" class=\"headerlink\" title=\"物理系统中的破坏（Destruction in Physics System）\"></a>物理系统中的破坏（Destruction in Physics System）</h3><p>从物理系统的计算流程上来看，破碎系统一般是仿真碰撞检测后实际解算之前。这主要是因为很多破碎的事件是由碰撞所导致的，<br>同时在物体破碎后往往还会产生新的物体(碎片)需要计算相应的运动。<br><img src=\"/images/article/Games104/11/Games104_11_40.png\"><span class=\"image-caption\">物理系统中的破坏</span></p>\n<h3 id=\"破坏的问题（Issues-with-Destruction）\"><a href=\"#破坏的问题（Issues-with-Destruction）\" class=\"headerlink\" title=\"破坏的问题（Issues with Destruction）\"></a>破坏的问题（Issues with Destruction）</h3><p>除了物理系统的计算外在处理场景破坏时还需要添加相应的声音和粒子效果，这样可以得到更加真实的游戏体验。<br><img src=\"/images/article/Games104/11/Games104_11_41.png\"><span class=\"image-caption\">更加真实的游戏体验</span></p>\n<p>此外破坏系统的计算是相当昂贵的：当一个物体出现破碎后往往会带来成百上千个碎片需要进行物理仿真，<br>这会极大地增加物理系统的计算负载，因此在使用时需要慎重考虑。<br><img src=\"/images/article/Games104/11/Games104_11_42.png\"><span class=\"image-caption\">破坏的问题</span></p>\n<h3 id=\"流行的破坏实现（Popular-Destruction-Implementations）\"><a href=\"#流行的破坏实现（Popular-Destruction-Implementations）\" class=\"headerlink\" title=\"流行的破坏实现（Popular Destruction Implementations）\"></a>流行的破坏实现（Popular Destruction Implementations）</h3><p>目前很多商业引擎都有现成的破坏系统。<br><img src=\"/images/article/Games104/11/Games104_11_43.png\"><span class=\"image-caption\">流行的破坏实现</span><br><img src=\"/images/article/Games104/11/Games104_11_44.png\"><span class=\"image-caption\">流行的破坏实现2</span></p>\n<h2 id=\"载具模拟（Vehicle）\"><a href=\"#载具模拟（Vehicle）\" class=\"headerlink\" title=\"载具模拟（Vehicle）\"></a>载具模拟（Vehicle）</h2><p>载具系统是现代游戏中重要的组成部分。要对载具进行模拟需要推导相应的动力学模型，<br>以汽车为例整个汽车可以看做通过悬挂系统与地面接触的刚体。<br><img src=\"/images/article/Games104/11/Games104_11_45.png\"><span class=\"image-caption\">车辆机构建模</span></p>\n<p>整个汽车的驱动力来自于引擎产生的扭矩，而扭矩的大小则需要查询引擎的相关曲线来计算。<br><img src=\"/images/article/Games104/11/Games104_11_46.png\"><span class=\"image-caption\">牵引力</span></p>\n<p>在竖直方向上由于地面的起伏车身会产生悬挂系统所导致的振动。<br><img src=\"/images/article/Games104/11/Games104_11_47.png\"><span class=\"image-caption\">悬挂力</span></p>\n<p>在平面上汽车的轮胎会产生平行于前进方向的径向力，同时还会产生的切向力控制车辆的转动。<br><img src=\"/images/article/Games104/11/Games104_11_48.png\"><span class=\"image-caption\">轮胎力</span></p>\n<p>根据车身重量的分布我们还需要计算汽车的重心。实际上重心的位置不仅会控制汽车的振动，还会汽车的转向性能有重要的影响。<br><img src=\"/images/article/Games104/11/Games104_11_49.png\"><span class=\"image-caption\">质心</span><br><img src=\"/images/article/Games104/11/Games104_11_50.png\"><span class=\"image-caption\">质心2</span><br><img src=\"/images/article/Games104/11/Games104_11_51.png\"><span class=\"image-caption\">质心3</span></p>\n<p>同时需要注意的是当车辆进行加速或是刹车时重心的位置也会发生一些变化。<br><img src=\"/images/article/Games104/11/Games104_11_52.png\"><span class=\"image-caption\">重心移动</span></p>\n<p>为了更好地实现转向，现代汽车在设计时会让两个转向轮的转动有微小的差异。在进行模拟时也需要考虑这个微小的角度变化。<br><img src=\"/images/article/Games104/11/Games104_11_53.png\"><span class=\"image-caption\">转向角度</span></p>\n<p>最后需要说明的是在计算地面和车轮求交时需要把轮子看做是球，这样才能模拟出车辆在凹凸不平的地面上行驶的效果。<br><img src=\"/images/article/Games104/11/Games104_11_54.png\"><span class=\"image-caption\">高级轮胎接触点</span></p>\n<h2 id=\"高级：PBD与XPBD\"><a href=\"#高级：PBD与XPBD\" class=\"headerlink\" title=\"高级：PBD与XPBD\"></a>高级：PBD与XPBD</h2><h3 id=\"PBD\"><a href=\"#PBD\" class=\"headerlink\" title=\"PBD\"></a>PBD</h3><p>本节课最后讨论了PBD和XPBD两种更高级的物理仿真技术。和前面介绍过的仿真技术相比，<br>PBD和XPBD是建立在<b>拉格朗日力学(Lagrangian mechanics)</b>基础上的仿真方法。<br>在拉格朗日力学的框架中不再考虑力等物理概念，而是把物理定律视为系统的某种约束来描述运动。<br><img src=\"/images/article/Games104/11/Games104_11_55.png\"><span class=\"image-caption\">求解约束</span></p>\n<p>以匀速圆周运动为例，在拉格朗日力学中我们不会去计算各种改变质点运动状态的力，<br>而是考虑质点运动的位置约束以及速度约束。其中位置约束的导数也称为Jacobian矩阵。<br><img src=\"/images/article/Games104/11/Games104_11_56.png\"><span class=\"image-caption\">环状约束</span></p>\n<p>类似地，弹簧质点系统也可以表示为由约束定义的系统。<br><img src=\"/images/article/Games104/11/Games104_11_57.png\"><span class=\"image-caption\">字符串约束</span></p>\n<p>PBD在求解时，PBD会把整个物理系统描述为关于位置的约束。然后通过不断迭代来计算满足约束的解。<br><img src=\"/images/article/Games104/11/Games104_11_58.png\"><span class=\"image-caption\">PBD - 约束投影</span><br><img src=\"/images/article/Games104/11/Games104_11_59.png\"><span class=\"image-caption\">PBD - 约束投影2</span></p>\n<p>整个PBD的求解流程如下：<br><img src=\"/images/article/Games104/11/Games104_11_60.png\"><span class=\"image-caption\">PBD - 求解流程</span><br><img src=\"/images/article/Games104/11/Games104_11_61.png\"><span class=\"image-caption\">PBD - 求解流程2</span><br><img src=\"/images/article/Games104/11/Games104_11_62.png\"><span class=\"image-caption\">PBD - 求解流程3</span><br><img src=\"/images/article/Games104/11/Games104_11_63.png\"><span class=\"image-caption\">PBD - 求解流程4</span><br><img src=\"/images/article/Games104/11/Games104_11_64.png\"><span class=\"image-caption\">PBD - 求解流程5</span><br><img src=\"/images/article/Games104/11/Games104_11_65.png\"><span class=\"image-caption\">PBD - 求解流程6</span></p>\n<p>PBD是目前游戏行业非常热门的物理仿真技术，和传统仿真技术相比PBD往往会得到更稳定的解。<br><img src=\"/images/article/Games104/11/Games104_11_66.png\"><span class=\"image-caption\">PBD应用</span></p>\n<h3 id=\"XPBD\"><a href=\"#XPBD\" class=\"headerlink\" title=\"XPBD\"></a>XPBD</h3><p>XPBD可以看做是对PBD的一种推广，它在PBD的基础上引入了<b>刚度(stiffness)</b>的概念来描述不同约束的强弱。<br><img src=\"/images/article/Games104/11/Games104_11_67.png\"><span class=\"image-caption\">基于动力学的拓展</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/06/05/GAMES104-NOTES-11.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Ya411j7ds/?spm_id_from=333.788&amp;vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture11_Physics%20System_Applications.pdf\">课件PPT</a></p>\n","more":"<h2 id=\"角色控制器（Character-Controller）\"><a href=\"#角色控制器（Character-Controller）\" class=\"headerlink\" title=\"角色控制器（Character Controller）\"></a>角色控制器（Character Controller）</h2><p><b>角色控制器(character controller)</b>是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，<br>角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，<br>而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。<br><img  src=\"/images/article/Games104/11/Games104_11_01.png\"  ><span class=\"image-caption\">角色控制 VS 刚体动力学</span></p>\n<h3 id=\"构建一个控制器（Build-a-Controller-in-Physics-System）\"><a href=\"#构建一个控制器（Build-a-Controller-in-Physics-System）\" class=\"headerlink\" title=\"构建一个控制器（Build a Controller in Physics System）\"></a>构建一个控制器（Build a Controller in Physics System）</h3><p>在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。<br><img  src=\"/images/article/Games104/11/Games104_11_02.png\"  ><span class=\"image-caption\">构建控制器</span></p>\n<h3 id=\"与环境碰撞（Collide-with-Environment）\"><a href=\"#与环境碰撞（Collide-with-Environment）\" class=\"headerlink\" title=\"与环境碰撞（Collide with Environment）\"></a>与环境碰撞（Collide with Environment）</h3><p>在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；<br>而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。<br><img  src=\"/images/article/Games104/11/Games104_11_03.png\"  ><span class=\"image-caption\">与环境碰撞</span></p>\n<h3 id=\"自动步进及其问题（Auto-Stepping）\"><a href=\"#自动步进及其问题（Auto-Stepping）\" class=\"headerlink\" title=\"自动步进及其问题（Auto Stepping）\"></a>自动步进及其问题（Auto Stepping）</h3><p>上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。<br>因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。<br><img  src=\"/images/article/Games104/11/Games104_11_04.png\"  ><span class=\"image-caption\">自动步进及其问题</span></p>\n<p>对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，<br>或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。<br>为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。<br><img  src=\"/images/article/Games104/11/Games104_11_05.png\"  ><span class=\"image-caption\">坡度限制和作用力向下滑动</span></p>\n<h3 id=\"控制器卷更新（Controller-Volume-Update）\"><a href=\"#控制器卷更新（Controller-Volume-Update）\" class=\"headerlink\" title=\"控制器卷更新（Controller Volume Update）\"></a>控制器卷更新（Controller Volume Update）</h3><p>角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，<br>否则容易出现角色卡在门口无法进入的问题。<br><img  src=\"/images/article/Games104/11/Games104_11_06.png\"  ><span class=\"image-caption\">控制器卷更新</span></p>\n<h3 id=\"控制器推送对象（Controller-Push-Objects）\"><a href=\"#控制器推送对象（Controller-Push-Objects）\" class=\"headerlink\" title=\"控制器推送对象（Controller Push Objects）\"></a>控制器推送对象（Controller Push Objects）</h3><p>当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。<br>比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。<br><img  src=\"/images/article/Games104/11/Games104_11_07.png\"  ><span class=\"image-caption\">控制器推送对象</span></p>\n<h3 id=\"站在移动平台上（Standing-on-Moving-Platform）\"><a href=\"#站在移动平台上（Standing-on-Moving-Platform）\" class=\"headerlink\" title=\"站在移动平台上（Standing on Moving Platform）\"></a>站在移动平台上（Standing on Moving Platform）</h3><p>除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，<br>否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。<br><img  src=\"/images/article/Games104/11/Games104_11_08.png\"  ><span class=\"image-caption\">站在移动平台上</span></p>\n<h2 id=\"布娃娃系统（Ragdoll）\"><a href=\"#布娃娃系统（Ragdoll）\" class=\"headerlink\" title=\"布娃娃系统（Ragdoll）\"></a>布娃娃系统（Ragdoll）</h2><p><b>布娃娃(Ragdoll)</b>系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：<br>当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。<br><img  src=\"/images/article/Games104/11/Games104_11_09.png\"  ><span class=\"image-caption\">为什么要使用布偶</span></p>\n<h3 id=\"将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies\"><a href=\"#将骨架映射到刚体-Map-Skeleton-to-Rigid-Bodies\" class=\"headerlink\" title=\"将骨架映射到刚体(Map Skeleton to Rigid Bodies)\"></a>将骨架映射到刚体(Map Skeleton to Rigid Bodies)</h3><p>实际上ragdoll与前面介绍过的<a href=\"/posts/b1eb3151.html#骨骼动画-amp-蒙皮\"><b><font color=\"red\">骨骼动画</font></b></a>密切相关。在模拟ragdoll的运动时，<br>我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。<br>不过出于实时计算上的考虑，ragdoll一般只会使用非常少量的节点和骨骼来进行模拟。<br><img  src=\"/images/article/Games104/11/Games104_11_10.png\"  ><span class=\"image-caption\">将骨架映射到刚体</span></p>\n<h3 id=\"人体关节约束（Human-Joint-Constraints）\"><a href=\"#人体关节约束（Human-Joint-Constraints）\" class=\"headerlink\" title=\"人体关节约束（Human Joint Constraints）\"></a>人体关节约束（Human Joint Constraints）</h3><p>同样地，在ragdoll中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。<br><img  src=\"/images/article/Games104/11/Games104_11_11.png\"  ><span class=\"image-caption\">人体关节约束</span><br><img  src=\"/images/article/Games104/11/Games104_11_12.png\"  ><span class=\"image-caption\">联合约束的重要性</span></p>\n<p>一般来说ragdoll关节的约束会由TA进行设置，如果设置的不好会出现一些反直觉的动画效果。<br><img  src=\"/images/article/Games104/11/Games104_11_13.png\"  ><span class=\"image-caption\">约束属性</span><br><img  src=\"/images/article/Games104/11/Games104_11_14.png\"  ><span class=\"image-caption\">精心调整约束</span></p>\n<h3 id=\"布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）\"><a href=\"#布娃娃的骨架动画（Animating-Skeleton-by-Ragdoll）\" class=\"headerlink\" title=\"布娃娃的骨架动画（Animating Skeleton by Ragdoll）\"></a>布娃娃的骨架动画（Animating Skeleton by Ragdoll）</h3><p>需要注意的是尽管我们可以使用ragdoll来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。<br>由于ragdoll中的骨骼关节数量一般会少于实际角色的骨骼关节，<br>我们需要使用<a href=\"/posts/649819f1.html#动画重定向（Animation-Retargeting）\"><b><font color=\"red\">动画重定向</font></b></a>技术来将ragdoll计算出的运动映射到实际的角色骨骼上。<br><img  src=\"/images/article/Games104/11/Games104_11_15.png\"  ><span class=\"image-caption\">布娃娃的骨架动画</span></p>\n<h3 id=\"混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）\"><a href=\"#混合动画和布娃娃（Blending-between-Animation-and-Ragdoll）\" class=\"headerlink\" title=\"混合动画和布娃娃（Blending between Animation and Ragdoll）\"></a>混合动画和布娃娃（Blending between Animation and Ragdoll）</h3><p>在使用时还需要注意角色动画切换到ragdoll的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，<br>然后在某一时刻会切换成ragdoll使用物理系统来实时计算角色的行为。<br><img  src=\"/images/article/Games104/11/Games104_11_16.png\"  ><span class=\"image-caption\">混合动画和布娃娃</span></p>\n<p>更进一步，在现代3A游戏中还会将角色动画和ragdoll实时计算出的动画进行混合来提升玩家的代入感和游戏体验。<br><img  src=\"/images/article/Games104/11/Games104_11_17.png\"  ><span class=\"image-caption\">物理动画混合</span></p>\n<h2 id=\"衣料模拟（Cloth）\"><a href=\"#衣料模拟（Cloth）\" class=\"headerlink\" title=\"衣料模拟（Cloth）\"></a>衣料模拟（Cloth）</h2><p>布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，<br>我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，<br>这样就可以实现角色执行不同动作时衣物随之飘动的效果。<br><img  src=\"/images/article/Games104/11/Games104_11_18.png\"  ><span class=\"image-caption\">基于动画的布料模拟</span></p>\n<p>另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。<br>这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。<br><img  src=\"/images/article/Games104/11/Games104_11_19.png\"  ><span class=\"image-caption\">基于刚体的布料模拟</span></p>\n<h3 id=\"基于网格的布料模拟（Mesh-Based-Cloth-Simulation）\"><a href=\"#基于网格的布料模拟（Mesh-Based-Cloth-Simulation）\" class=\"headerlink\" title=\"基于网格的布料模拟（Mesh-Based Cloth Simulation）\"></a>基于网格的布料模拟（Mesh-Based Cloth Simulation）</h3><p>而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，<br>出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。<br><img  src=\"/images/article/Games104/11/Games104_11_20.png\"  ><span class=\"image-caption\">渲染网格 VS 物理网格</span></p>\n<p>同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。<br><img  src=\"/images/article/Games104/11/Games104_11_21.png\"  ><span class=\"image-caption\">布料模拟约束条件</span></p>\n<h3 id=\"质量弹簧系统（Mass-Spring-System）\"><a href=\"#质量弹簧系统（Mass-Spring-System）\" class=\"headerlink\" title=\"质量弹簧系统（Mass-Spring System）\"></a>质量弹簧系统（Mass-Spring System）</h3><p>使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。<br>这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。<br><img  src=\"/images/article/Games104/11/Games104_11_22.png\"  ><span class=\"image-caption\">质量弹簧系统</span></p>\n<p>在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。<br><img  src=\"/images/article/Games104/11/Games104_11_23.png\"  ><span class=\"image-caption\">质量弹簧系统2</span></p>\n<p>最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。<br><img  src=\"/images/article/Games104/11/Games104_11_24.png\"  ><span class=\"image-caption\">质量弹簧系统3</span></p>\n<h3 id=\"韦尔莱积分（Verlet-Integration）\"><a href=\"#韦尔莱积分（Verlet-Integration）\" class=\"headerlink\" title=\"韦尔莱积分（Verlet Integration）\"></a>韦尔莱积分（Verlet Integration）</h3><p>对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些Verlet积分算法。Verlet积分本质仍然是半隐式欧拉积分，<br>不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此Verlet积分不需要保存每一时刻的速度，<br>我们只需要位移和力(加速度)就可以进行计算，从而提高布料仿真的效率。<br><img  src=\"/images/article/Games104/11/Games104_11_25.png\"  ><span class=\"image-caption\">韦尔莱积分</span></p>\n<h3 id=\"自相交（Self-Collision）\"><a href=\"#自相交（Self-Collision）\" class=\"headerlink\" title=\"自相交（Self Collision）\"></a>自相交（Self Collision）</h3><p>布料仿真的一大难点在于如何处理<b>自相交(self collision)</b>问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。<br><img  src=\"/images/article/Games104/11/Games104_11_26.png\"  ><span class=\"image-caption\">自相交</span></p>\n<p>目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些trick来缓解自相交的问题，<br>比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用SDF进行控制等。<br><img  src=\"/images/article/Games104/11/Games104_11_27.png\"  ><span class=\"image-caption\">自相交的常见解决方案</span><br><img  src=\"/images/article/Games104/11/Games104_11_28.png\"  ><span class=\"image-caption\">自相交的常见解决方案2</span></p>\n<h2 id=\"破坏模拟（Destruction）\"><a href=\"#破坏模拟（Destruction）\" class=\"headerlink\" title=\"破坏模拟（Destruction）\"></a>破坏模拟（Destruction）</h2><p>玩家对场景的破坏是通过破坏系统来进行实现。一个好的破坏系统可以极大地提升玩家的游戏体验，有些游戏甚至是以破坏系统为核心玩法进行设计的。<br><img  src=\"/images/article/Games104/11/Games104_11_29.png\"  ><span class=\"image-caption\">破坏的重要性</span></p>\n<h3 id=\"区块层次结构（Chunk-Hierarchy）\"><a href=\"#区块层次结构（Chunk-Hierarchy）\" class=\"headerlink\" title=\"区块层次结构（Chunk Hierarchy）\"></a>区块层次结构（Chunk Hierarchy）</h3><p>我们可以使用一棵树来描述同一物体不同碎片之间的层次关系：树的根节点表示完整的物体，而它下面的每一层表示物体经受一定程度的冲击后所产生的碎片。<br><img  src=\"/images/article/Games104/11/Games104_11_30.png\"  ><span class=\"image-caption\">区块层次结构</span></p>\n<h3 id=\"连通性图（Connectivity-Graph）\"><a href=\"#连通性图（Connectivity-Graph）\" class=\"headerlink\" title=\"连通性图（Connectivity Graph）\"></a>连通性图（Connectivity Graph）</h3><p>当确定了物体承受的冲击后就可以使用一张图来表示不同碎片之间的连接关系：图的节点表示碎片，<br>而图的边则表示相互连接的碎片能够承受的荷载，当冲击大于边上的值时就会发生物体的破碎。<br><img  src=\"/images/article/Games104/11/Games104_11_31.png\"  ><span class=\"image-caption\">连通性图</span><br><img  src=\"/images/article/Games104/11/Games104_11_32.png\"  ><span class=\"image-caption\">连通性值</span></p>\n<h3 id=\"损坏计算（Damage-Calculation）\"><a href=\"#损坏计算（Damage-Calculation）\" class=\"headerlink\" title=\"损坏计算（Damage Calculation）\"></a>损坏计算（Damage Calculation）</h3><p>需要说明的是虽然我们使用了冲击和荷载这样的字眼，实际上在游戏引擎中却不会去计算这些物理量。<br>它们只是一些人工设置的数值，并不具备真实的物理意义。在游戏开发中一般会使用一些经验公式来对冲击以及物体的承载力进行计算。<br><img  src=\"/images/article/Games104/11/Games104_11_33.png\"  ><span class=\"image-caption\">损坏计算</span><br><img  src=\"/images/article/Games104/11/Games104_11_34.png\"  ><span class=\"image-caption\">损坏计算2</span></p>\n<h3 id=\"沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）\"><a href=\"#沃罗诺伊图压裂（Fracturing-with-Voronoi-Diagram）\" class=\"headerlink\" title=\"沃罗诺伊图压裂（Fracturing with Voronoi Diagram）\"></a>沃罗诺伊图压裂（Fracturing with Voronoi Diagram）</h3><p>那么如何去生成这样的一张图呢？在物理引擎中一般会使用<b>沃罗诺伊图(Voronoi diagram)</b>这样的技术来对原始的物体区域进行划分，<br>划分后的每一个区域即为所需的碎片。<br><img  src=\"/images/article/Games104/11/Games104_11_35.png\"  ><span class=\"image-caption\">通过沃罗诺伊图构建块</span><br><img  src=\"/images/article/Games104/11/Games104_11_36.png\"  ><span class=\"image-caption\">沃罗诺伊图 - 2D网格</span></p>\n<p>对于三维的情况则要更加复杂一些，除了需要使用Voronoi图对空间进行划分还需要使用Delaunay三角化来重新生成碎片的三维网格。<br>同时当物体破碎后还需要为碎片的网格赋予内部材质的纹理，这一般需要使用一些程序化的纹理生成算法。<br><img  src=\"/images/article/Games104/11/Games104_11_37.png\"  ><span class=\"image-caption\">沃罗诺伊图 - 3D网格</span><br><img  src=\"/images/article/Games104/11/Games104_11_38.png\"  ><span class=\"image-caption\">沃罗诺伊图 - 3D网格2</span></p>\n<p>在设置Voronoi图的种子时还可以根据需要设置不同模式的种子，这样可以实现相应的破碎效果。<br><img  src=\"/images/article/Games104/11/Games104_11_39.png\"  ><span class=\"image-caption\">不同的沃罗诺伊图</span></p>\n<h3 id=\"物理系统中的破坏（Destruction-in-Physics-System）\"><a href=\"#物理系统中的破坏（Destruction-in-Physics-System）\" class=\"headerlink\" title=\"物理系统中的破坏（Destruction in Physics System）\"></a>物理系统中的破坏（Destruction in Physics System）</h3><p>从物理系统的计算流程上来看，破碎系统一般是仿真碰撞检测后实际解算之前。这主要是因为很多破碎的事件是由碰撞所导致的，<br>同时在物体破碎后往往还会产生新的物体(碎片)需要计算相应的运动。<br><img  src=\"/images/article/Games104/11/Games104_11_40.png\"  ><span class=\"image-caption\">物理系统中的破坏</span></p>\n<h3 id=\"破坏的问题（Issues-with-Destruction）\"><a href=\"#破坏的问题（Issues-with-Destruction）\" class=\"headerlink\" title=\"破坏的问题（Issues with Destruction）\"></a>破坏的问题（Issues with Destruction）</h3><p>除了物理系统的计算外在处理场景破坏时还需要添加相应的声音和粒子效果，这样可以得到更加真实的游戏体验。<br><img  src=\"/images/article/Games104/11/Games104_11_41.png\"  ><span class=\"image-caption\">更加真实的游戏体验</span></p>\n<p>此外破坏系统的计算是相当昂贵的：当一个物体出现破碎后往往会带来成百上千个碎片需要进行物理仿真，<br>这会极大地增加物理系统的计算负载，因此在使用时需要慎重考虑。<br><img  src=\"/images/article/Games104/11/Games104_11_42.png\"  ><span class=\"image-caption\">破坏的问题</span></p>\n<h3 id=\"流行的破坏实现（Popular-Destruction-Implementations）\"><a href=\"#流行的破坏实现（Popular-Destruction-Implementations）\" class=\"headerlink\" title=\"流行的破坏实现（Popular Destruction Implementations）\"></a>流行的破坏实现（Popular Destruction Implementations）</h3><p>目前很多商业引擎都有现成的破坏系统。<br><img  src=\"/images/article/Games104/11/Games104_11_43.png\"  ><span class=\"image-caption\">流行的破坏实现</span><br><img  src=\"/images/article/Games104/11/Games104_11_44.png\"  ><span class=\"image-caption\">流行的破坏实现2</span></p>\n<h2 id=\"载具模拟（Vehicle）\"><a href=\"#载具模拟（Vehicle）\" class=\"headerlink\" title=\"载具模拟（Vehicle）\"></a>载具模拟（Vehicle）</h2><p>载具系统是现代游戏中重要的组成部分。要对载具进行模拟需要推导相应的动力学模型，<br>以汽车为例整个汽车可以看做通过悬挂系统与地面接触的刚体。<br><img  src=\"/images/article/Games104/11/Games104_11_45.png\"  ><span class=\"image-caption\">车辆机构建模</span></p>\n<p>整个汽车的驱动力来自于引擎产生的扭矩，而扭矩的大小则需要查询引擎的相关曲线来计算。<br><img  src=\"/images/article/Games104/11/Games104_11_46.png\"  ><span class=\"image-caption\">牵引力</span></p>\n<p>在竖直方向上由于地面的起伏车身会产生悬挂系统所导致的振动。<br><img  src=\"/images/article/Games104/11/Games104_11_47.png\"  ><span class=\"image-caption\">悬挂力</span></p>\n<p>在平面上汽车的轮胎会产生平行于前进方向的径向力，同时还会产生的切向力控制车辆的转动。<br><img  src=\"/images/article/Games104/11/Games104_11_48.png\"  ><span class=\"image-caption\">轮胎力</span></p>\n<p>根据车身重量的分布我们还需要计算汽车的重心。实际上重心的位置不仅会控制汽车的振动，还会汽车的转向性能有重要的影响。<br><img  src=\"/images/article/Games104/11/Games104_11_49.png\"  ><span class=\"image-caption\">质心</span><br><img  src=\"/images/article/Games104/11/Games104_11_50.png\"  ><span class=\"image-caption\">质心2</span><br><img  src=\"/images/article/Games104/11/Games104_11_51.png\"  ><span class=\"image-caption\">质心3</span></p>\n<p>同时需要注意的是当车辆进行加速或是刹车时重心的位置也会发生一些变化。<br><img  src=\"/images/article/Games104/11/Games104_11_52.png\"  ><span class=\"image-caption\">重心移动</span></p>\n<p>为了更好地实现转向，现代汽车在设计时会让两个转向轮的转动有微小的差异。在进行模拟时也需要考虑这个微小的角度变化。<br><img  src=\"/images/article/Games104/11/Games104_11_53.png\"  ><span class=\"image-caption\">转向角度</span></p>\n<p>最后需要说明的是在计算地面和车轮求交时需要把轮子看做是球，这样才能模拟出车辆在凹凸不平的地面上行驶的效果。<br><img  src=\"/images/article/Games104/11/Games104_11_54.png\"  ><span class=\"image-caption\">高级轮胎接触点</span></p>\n<h2 id=\"高级：PBD与XPBD\"><a href=\"#高级：PBD与XPBD\" class=\"headerlink\" title=\"高级：PBD与XPBD\"></a>高级：PBD与XPBD</h2><h3 id=\"PBD\"><a href=\"#PBD\" class=\"headerlink\" title=\"PBD\"></a>PBD</h3><p>本节课最后讨论了PBD和XPBD两种更高级的物理仿真技术。和前面介绍过的仿真技术相比，<br>PBD和XPBD是建立在<b>拉格朗日力学(Lagrangian mechanics)</b>基础上的仿真方法。<br>在拉格朗日力学的框架中不再考虑力等物理概念，而是把物理定律视为系统的某种约束来描述运动。<br><img  src=\"/images/article/Games104/11/Games104_11_55.png\"  ><span class=\"image-caption\">求解约束</span></p>\n<p>以匀速圆周运动为例，在拉格朗日力学中我们不会去计算各种改变质点运动状态的力，<br>而是考虑质点运动的位置约束以及速度约束。其中位置约束的导数也称为Jacobian矩阵。<br><img  src=\"/images/article/Games104/11/Games104_11_56.png\"  ><span class=\"image-caption\">环状约束</span></p>\n<p>类似地，弹簧质点系统也可以表示为由约束定义的系统。<br><img  src=\"/images/article/Games104/11/Games104_11_57.png\"  ><span class=\"image-caption\">字符串约束</span></p>\n<p>PBD在求解时，PBD会把整个物理系统描述为关于位置的约束。然后通过不断迭代来计算满足约束的解。<br><img  src=\"/images/article/Games104/11/Games104_11_58.png\"  ><span class=\"image-caption\">PBD - 约束投影</span><br><img  src=\"/images/article/Games104/11/Games104_11_59.png\"  ><span class=\"image-caption\">PBD - 约束投影2</span></p>\n<p>整个PBD的求解流程如下：<br><img  src=\"/images/article/Games104/11/Games104_11_60.png\"  ><span class=\"image-caption\">PBD - 求解流程</span><br><img  src=\"/images/article/Games104/11/Games104_11_61.png\"  ><span class=\"image-caption\">PBD - 求解流程2</span><br><img  src=\"/images/article/Games104/11/Games104_11_62.png\"  ><span class=\"image-caption\">PBD - 求解流程3</span><br><img  src=\"/images/article/Games104/11/Games104_11_63.png\"  ><span class=\"image-caption\">PBD - 求解流程4</span><br><img  src=\"/images/article/Games104/11/Games104_11_64.png\"  ><span class=\"image-caption\">PBD - 求解流程5</span><br><img  src=\"/images/article/Games104/11/Games104_11_65.png\"  ><span class=\"image-caption\">PBD - 求解流程6</span></p>\n<p>PBD是目前游戏行业非常热门的物理仿真技术，和传统仿真技术相比PBD往往会得到更稳定的解。<br><img  src=\"/images/article/Games104/11/Games104_11_66.png\"  ><span class=\"image-caption\">PBD应用</span></p>\n<h3 id=\"XPBD\"><a href=\"#XPBD\" class=\"headerlink\" title=\"XPBD\"></a>XPBD</h3><p>XPBD可以看做是对PBD的一种推广，它在PBD的基础上引入了<b>刚度(stiffness)</b>的概念来描述不同约束的强弱。<br><img  src=\"/images/article/Games104/11/Games104_11_67.png\"  ><span class=\"image-caption\">基于动力学的拓展</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://peng00bo00.github.io/2022/06/05/GAMES104-NOTES-11.html\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Ya411j7ds/?spm_id_from=333.788&vd_source=371bc0e94a8c97f991c4ac20af0b2d53\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture11_Physics%20System_Applications.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}