{"title":"现代游戏引擎 - 如何构建游戏世界（三）","slug":"Games104/03_How to Build a Game World","date":"2022-09-01T12:33:21.000Z","updated":"2023-11-29T02:42:01.736Z","comments":true,"path":"api/articles/Games104/03_How to Build a Game World.json","realPath":null,"excerpt":null,"covers":["/images/article/Games104/03/Games104_03_01.png","/images/article/Games104/03/Games104_03_02.png","/images/article/Games104/03/Games104_03_03.png","/images/article/Games104/03/Games104_03_04.png","/images/article/Games104/03/Games104_03_05.png","/images/article/Games104/03/Games104_03_06.png","/images/article/Games104/03/Games104_03_07.png","/images/article/Games104/03/Games104_03_08.png","/images/article/Games104/03/Games104_03_09.png","/images/article/Games104/03/Games104_03_10.png"],"cover":"/images/background/How-Build-Game-World.jpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"如何让游戏世界活动起来\"><a href=\"#如何让游戏世界活动起来\" class=\"headerlink\" title=\"如何让游戏世界活动起来\"></a>如何让游戏世界活动起来</h2><h3 id=\"游戏对象类型\"><a href=\"#游戏对象类型\" class=\"headerlink\" title=\"游戏对象类型\"></a>游戏对象类型</h3><ul>\n<li>现代游戏中的对象通常分为：动态物体、静态物体、地形系统以及其它物件。</li>\n<li>为了统一游戏中对象，我们通常会用GameObject来指代游戏中的所有对象。</li>\n</ul>\n<p><img src=\"/images/article/Games104/03/Games104_03_01.png\"><span class=\"image-caption\">GameObject</span></p>\n<h3 id=\"游戏对象功能组织\"><a href=\"#游戏对象功能组织\" class=\"headerlink\" title=\"游戏对象功能组织\"></a>游戏对象功能组织</h3><p>以面向对象的思维，一个游戏对象由属性和行为组成。 但游戏中的对象十分复杂，通过水陆两栖坦克继承车还是船的案例表达难以清晰得区分继承关系。<br><img src=\"/images/article/Games104/03/Games104_03_02.png\"><span class=\"image-caption\">分类</span></p>\n<p>游戏引擎中通常使用组件化的方式，抽离行为逻辑，使得游戏对象的设计更加方便。通过接口、组合的方法更加符合人的直觉。<br>基于组件化的思想，我们通常会抽象出一个ComponentBase，不同组件实现基类的方法，所有组件由统一的外部管理对象调用。<br><img src=\"/images/article/Games104/03/Games104_03_03.png\"><span class=\"image-caption\">组件</span></p>\n<p>装备不同功能的组件实现不同的无人机<br><img src=\"/images/article/Games104/03/Games104_03_04.png\"><span class=\"image-caption\">无人机组件</span></p>\n<ol>\n<li>在游戏世界中，一切都是一个GameObject对象</li>\n<li>游戏对象可以以基于组件的方式来描述</li>\n</ol>\n<h3 id=\"逻辑何时执行\"><a href=\"#逻辑何时执行\" class=\"headerlink\" title=\"逻辑何时执行\"></a>逻辑何时执行</h3><p>Tick的方式：</p>\n<ol>\n<li>基于对象为基础的Tick</li>\n<li>基于组件为基础的Tick</li>\n</ol>\n<p><img src=\"/images/article/Games104/03/Games104_03_05.png\"><span class=\"image-caption\">GO Tick VS Component Tick</span><br>现代游戏引擎中通常不是按照GameObject来执行Tick，而是根据功能系统。这样能够处理连续内存数据，效率更高。（类似ECS思路）</p>\n<h3 id=\"对象通讯\"><a href=\"#对象通讯\" class=\"headerlink\" title=\"对象通讯\"></a>对象通讯</h3><p>想想这样一个场景：一辆坦克被炮弹击中，坦克爆炸需要对周围单位造成伤害。<br>一种处理方案是，找到坦克周围的对象，依次处理受击逻辑。<br>这样的处理方式对于复杂的游戏来说，难以阅读维护成本很高。<br><img src=\"/images/article/Games104/03/Games104_03_06.png\"><span class=\"image-caption\">遍历处理逻辑</span></p>\n<p>通常会使用event机制来解耦这些逻辑：坦克发出爆炸消息，受影响的对象自己接受消息，并执行逻辑。相当于把事件解耦成发生和处理。<br><img src=\"/images/article/Games104/03/Games104_03_07.png\"><span class=\"image-caption\">消息事件处理逻辑</span></p>\n<h2 id=\"如何管理游戏对象\"><a href=\"#如何管理游戏对象\" class=\"headerlink\" title=\"如何管理游戏对象\"></a>如何管理游戏对象</h2><p>游戏对象是处于游戏场景中的，游戏对象通过唯一id来进行识别：unique ID(uid)，游戏对象处于特定位置。</p>\n<p>继续上述的例子，当坦克发生爆炸时，所有接收到事件的对象都会进行处理。但游戏场景中存在大量对象时，<br>这样的处理方式难以适用（每个游戏对象都可能和其它游戏对象互动，此时算法复杂度为n^2）。<br>因此就需要根据游戏对象在场景中的分布进行管理，以优化场景对象的查找。</p>\n<p>简单的场景可以通过画格子的方式处理。<br><img src=\"/images/article/Games104/03/Games104_03_08.png\"><span class=\"image-caption\">简单处理方式</span></p>\n<p>常见场景对象数据结构：二分树、四叉树（八叉树）、BVH。游戏引擎一般实现多种算法供上层开发选择。<br><img src=\"/images/article/Games104/03/Games104_03_09.png\"><span class=\"image-caption\">多种处理方式</span></p>\n<h2 id=\"其他需要处理的负责情况（时序问题）\"><a href=\"#其他需要处理的负责情况（时序问题）\" class=\"headerlink\" title=\"其他需要处理的负责情况（时序问题）\"></a>其他需要处理的负责情况（时序问题）</h2><p>不同系统之间可能相互影响，出现循环依赖。比如人在行走时，踢到一块石头，触发物理系统，同时反过来影响动画系统。此时就会涉及到逻辑处理的时序问题。</p>\n<p>现代引擎是在多核CPU上行执行的，也可能出现两个对象相互影响，出现时序问题。</p>\n<p>例子：引入一个邮局，通过将事件发送到邮局统一处理后分发到对应GO处理（通常的处理方式是引入第三方，隔帧处理）</p>\n<p><img src=\"/images/article/Games104/03/Games104_03_10.png\"><span class=\"image-caption\">组件依赖</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://zhuanlan.zhihu.com/p/490186435\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1YY4y1p74P/?spm_id_from=333.788&amp;vd_source=422a2ce23eb94fdbdfc2824aa2898ea5\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture03_How%20to%20Build%20a%20Game%20World.pdf\">课件PPT</a></p>\n","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"如何让游戏世界活动起来\"><a href=\"#如何让游戏世界活动起来\" class=\"headerlink\" title=\"如何让游戏世界活动起来\"></a>如何让游戏世界活动起来</h2><h3 id=\"游戏对象类型\"><a href=\"#游戏对象类型\" class=\"headerlink\" title=\"游戏对象类型\"></a>游戏对象类型</h3><ul>\n<li>现代游戏中的对象通常分为：动态物体、静态物体、地形系统以及其它物件。</li>\n<li>为了统一游戏中对象，我们通常会用GameObject来指代游戏中的所有对象。</li>\n</ul>\n<p><img  src=\"/images/article/Games104/03/Games104_03_01.png\"  ><span class=\"image-caption\">GameObject</span></p>\n<h3 id=\"游戏对象功能组织\"><a href=\"#游戏对象功能组织\" class=\"headerlink\" title=\"游戏对象功能组织\"></a>游戏对象功能组织</h3><p>以面向对象的思维，一个游戏对象由属性和行为组成。 但游戏中的对象十分复杂，通过水陆两栖坦克继承车还是船的案例表达难以清晰得区分继承关系。<br><img  src=\"/images/article/Games104/03/Games104_03_02.png\"  ><span class=\"image-caption\">分类</span></p>\n<p>游戏引擎中通常使用组件化的方式，抽离行为逻辑，使得游戏对象的设计更加方便。通过接口、组合的方法更加符合人的直觉。<br>基于组件化的思想，我们通常会抽象出一个ComponentBase，不同组件实现基类的方法，所有组件由统一的外部管理对象调用。<br><img  src=\"/images/article/Games104/03/Games104_03_03.png\"  ><span class=\"image-caption\">组件</span></p>\n<p>装备不同功能的组件实现不同的无人机<br><img  src=\"/images/article/Games104/03/Games104_03_04.png\"  ><span class=\"image-caption\">无人机组件</span></p>\n<ol>\n<li>在游戏世界中，一切都是一个GameObject对象</li>\n<li>游戏对象可以以基于组件的方式来描述</li>\n</ol>\n<h3 id=\"逻辑何时执行\"><a href=\"#逻辑何时执行\" class=\"headerlink\" title=\"逻辑何时执行\"></a>逻辑何时执行</h3><p>Tick的方式：</p>\n<ol>\n<li>基于对象为基础的Tick</li>\n<li>基于组件为基础的Tick</li>\n</ol>\n<p><img  src=\"/images/article/Games104/03/Games104_03_05.png\"  ><span class=\"image-caption\">GO Tick VS Component Tick</span><br>现代游戏引擎中通常不是按照GameObject来执行Tick，而是根据功能系统。这样能够处理连续内存数据，效率更高。（类似ECS思路）</p>\n<h3 id=\"对象通讯\"><a href=\"#对象通讯\" class=\"headerlink\" title=\"对象通讯\"></a>对象通讯</h3><p>想想这样一个场景：一辆坦克被炮弹击中，坦克爆炸需要对周围单位造成伤害。<br>一种处理方案是，找到坦克周围的对象，依次处理受击逻辑。<br>这样的处理方式对于复杂的游戏来说，难以阅读维护成本很高。<br><img  src=\"/images/article/Games104/03/Games104_03_06.png\"  ><span class=\"image-caption\">遍历处理逻辑</span></p>\n<p>通常会使用event机制来解耦这些逻辑：坦克发出爆炸消息，受影响的对象自己接受消息，并执行逻辑。相当于把事件解耦成发生和处理。<br><img  src=\"/images/article/Games104/03/Games104_03_07.png\"  ><span class=\"image-caption\">消息事件处理逻辑</span></p>\n<h2 id=\"如何管理游戏对象\"><a href=\"#如何管理游戏对象\" class=\"headerlink\" title=\"如何管理游戏对象\"></a>如何管理游戏对象</h2><p>游戏对象是处于游戏场景中的，游戏对象通过唯一id来进行识别：unique ID(uid)，游戏对象处于特定位置。</p>\n<p>继续上述的例子，当坦克发生爆炸时，所有接收到事件的对象都会进行处理。但游戏场景中存在大量对象时，<br>这样的处理方式难以适用（每个游戏对象都可能和其它游戏对象互动，此时算法复杂度为n^2）。<br>因此就需要根据游戏对象在场景中的分布进行管理，以优化场景对象的查找。</p>\n<p>简单的场景可以通过画格子的方式处理。<br><img  src=\"/images/article/Games104/03/Games104_03_08.png\"  ><span class=\"image-caption\">简单处理方式</span></p>\n<p>常见场景对象数据结构：二分树、四叉树（八叉树）、BVH。游戏引擎一般实现多种算法供上层开发选择。<br><img  src=\"/images/article/Games104/03/Games104_03_09.png\"  ><span class=\"image-caption\">多种处理方式</span></p>\n<h2 id=\"其他需要处理的负责情况（时序问题）\"><a href=\"#其他需要处理的负责情况（时序问题）\" class=\"headerlink\" title=\"其他需要处理的负责情况（时序问题）\"></a>其他需要处理的负责情况（时序问题）</h2><p>不同系统之间可能相互影响，出现循环依赖。比如人在行走时，踢到一块石头，触发物理系统，同时反过来影响动画系统。此时就会涉及到逻辑处理的时序问题。</p>\n<p>现代引擎是在多核CPU上行执行的，也可能出现两个对象相互影响，出现时序问题。</p>\n<p>例子：引入一个邮局，通过将事件发送到邮局统一处理后分发到对应GO处理（通常的处理方式是引入第三方，隔帧处理）</p>\n<p><img  src=\"/images/article/Games104/03/Games104_03_10.png\"  ><span class=\"image-caption\">组件依赖</span></p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p><a href=\"https://zhuanlan.zhihu.com/p/490186435\">参考文章</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1YY4y1p74P/?spm_id_from=333.788&vd_source=422a2ce23eb94fdbdfc2824aa2898ea5\">课程视频</a></p>\n<p><a href=\"https://cdn.boomingtech.com/games104_static/upload/GAMES104_Lecture03_How%20to%20Build%20a%20Game%20World.pdf\">课件PPT</a></p>\n","categories":[{"name":"游戏引擎","path":"api/categories/游戏引擎.json"}],"tags":[{"name":"游戏引擎","path":"api/tags/游戏引擎.json"},{"name":"games104","path":"api/tags/games104.json"}]}